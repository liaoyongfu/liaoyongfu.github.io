<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[创建一个React项目]]></title>
    <url>%2F2017%2F10%2F31%2Freact%2F%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAReact%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[React由Facebook所写，由虚拟Dom、组件化获得广大前端开发者的青睐，下面我们通过一个示例来演示创建React项目的步骤： 为什么用ReactReact解决了创建大型项目性能以及复用性问题，React可以有两种写法： 使用React.createClass语法 var HelloComponent = React.createClass({ render: function() { return ( &lt;div className=&quot;hello&quot;&gt; Hello, world! &lt;/div&gt; ); } }); 使用ES6语法 class HelloComponent extends React.Component { render() { return ( &lt;div className=&quot;hello&quot;&gt; Hello, world! &lt;/div&gt; ); } } 创建React项目 安装Node.js和NPM，然后运行npm init创建一个package.json文件. 在控制台中运行：npm install react react-dom babel-core babel-loader babel-preset-es2015 babel-preset-react webpack webpack-dev-server --save 创建webpack.config.js配置文件，这个的作用是帮我们打包资源，转换JSX为JS文件、合并、压缩、编译等等等。。。 一个简单的webpack.config.js大致如下： var debug = process.env.NODE_ENV !== &quot;production&quot;; var webpack = require(&apos;webpack&apos;); var path = require(&apos;path&apos;); module.exports = { context: path.join(__dirname, &quot;src&quot;), devtool: debug ? &quot;inline-sourcemap&quot; : null, entry: &quot;./js/App.js&quot;, devServer: { inline: true, port: 3333 }, module: { loaders: [ { test: /\.jsx?$/, exclude: /(node_modules|bower_components)/, loader: &apos;babel-loader&apos;, query: { presets: [&apos;react&apos;, &apos;es2015&apos;], plugins: [&apos;react-html-attrs&apos;, &apos;transform-class-properties&apos;, &apos;transform-decorators-legacy&apos;], } } ] }, output: { path: __dirname + &quot;/src/&quot;, filename: &quot;bundle.min.js&quot; }, plugins: debug ? [] : [ new webpack.optimize.DedupePlugin(), new webpack.optimize.OccurenceOrderPlugin(), new webpack.optimize.UglifyJsPlugin({ mangle: false, sourcemap: false }), ], }; 程序的入口通过entry设置，即页面第一次加载运行的文件，Webpack将把所有的JS和JSX文件到文件的输出对象，通过devServer设置webpack开发服务器为内联，并设置端口为3333，在module配置中，我们配置babel转换规则：使用react和es2015,plugins增加了类的属性和装饰器的功能。 热加载首先安装热加载模块： npm install --save-dev babel-preset-react-hmre 然后加到配置中： .... query: { presets: [&apos;react&apos;, &apos;es2015&apos;, &apos;react-hmre&apos;], plugins: [&apos;react-html-attrs&apos;, &apos;transform-class-properties&apos;, &apos;transform-decorators-legacy&apos;], } 另一个选择是安装react-hot-loader然后添加react-hot到webpack.config.js配置中： ... loader: [&apos;babel-loader&apos;, &apos;react-hot&apos;] ... 为了运行项目更简单，我们一般会使用package.json的命令： { &quot;scripts&quot;: { &quot;start&quot;: &quot;node_modules/.bin/webpack-dev-server --progress --inline --hot&quot;, } } 注意：我们命令中添加了--hot，这个启动了热加载模式. 路由路由是一个应用非常重要的一部分，在React中比较受欢迎的莫属React Router了，事实上，很多开发者认为它就是React官方版的路由，当然，你得先安装它： npm install --save react-router 一个简单的示例看起来是这样子的： import React from &apos;react&apos;; import { render } from &apos;react-dom&apos;; import { browserHistory, Router, Route, IndexRoute } from &apos;react-router&apos; import App from &apos;../components/App&apos; import Home from &apos;../components/Home&apos; import About from &apos;../components/About&apos; import Features from &apos;../components/Features&apos; render( &lt;Router history={browserHistory}&gt; &lt;Route path=&apos;/&apos; component={App}&gt; &lt;IndexRoute component={Home} /&gt; &lt;Route path=&apos;about&apos; component={About} /&gt; &lt;Route path=&apos;features&apos; component={Features} /&gt; &lt;/Route&gt; &lt;/Router&gt;, document.getElementById(&apos;app&apos;) ) 国际化(I18N)通过react-intl你可以很轻松地实现国际化，它支持超过150中不同语言，默认是英文，呃~ 权限认证Authentication is an important part of any application. The best way to do user authentication for single page apps is via JSON Web Tokens (JWT). A typical authentication flow is this: A user signs up/logs in, generate JWT token and return it to the client Store the JWT token on the client and send it via headers/query parameters for future requests A comprehensive example of adding authentication to a ReactJS app is here. Using Redux? Here is a good example of setting up authentication in your ReactJS application. 数据持久化Without a backend, you can persist data in your Single Page App by using Firebase. In a Reactjs app, all you simply need is ReactFire. It is a ReactJS mixin for easy Firebase integration. With ReactFire, it only takes a few lines of JavaScript to integrate Firebase data into React apps via the ReactFireMixin npm install --save reactfire react firebase TodoList Example import React from &apos;react&apos;; class TodoList extends React.Component { render() { var _this = this; var createItem = (item, index) =&gt; { return ( &lt;li key={ index }&gt; { item.text } &lt;span onClick={ _this.props.removeItem.bind(null, item[&apos;.key&apos;]) } style=&gt; X &lt;/span&gt; &lt;/li&gt; ); }; return &lt;ul&gt;{ this.props.items.map(createItem) }&lt;/ul&gt;; } } class TodoApp extends React.Component { getInitialState() { return { items: [], text: &apos;&apos; }; } componentWillMount() { this.firebaseRef = firebase.database().ref(&apos;todoApp/items&apos;); this.firebaseRef.limitToLast(25).on(&apos;value&apos;, function(dataSnapshot) { var items = []; dataSnapshot.forEach(childSnapshot =&gt; { const item = childSnapshot.val(); item[&apos;.key&apos;] = childSnapshot.key; items.push(item); }); this.setState({ items: items }); }.bind(this)); } componentWillUnmount() { this.firebaseRef.off(); } onChange(e) { this.setState({text: e.target.value}); } removeItem(key) { var firebaseRef = firebase.database().ref(&apos;todoApp/items&apos;);; firebaseRef.child(key).remove(); } handleSubmit(e) { e.preventDefault(); if (this.state.text &amp;&amp; this.state.text.trim().length !== 0) { this.firebaseRef.push({ text: this.state.text }); this.setState({ text: &apos;&apos; }); } } render() { return ( &lt;div&gt; &lt;TodoList items={ this.state.items } removeItem={ this.removeItem } /&gt; &lt;form onSubmit={ this.handleSubmit }&gt; &lt;input onChange={ this.onChange } value={ this.state.text } /&gt; &lt;button&gt;{ &apos;Add #&apos; + (this.state.items.length + 1) }&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; ); } } ReactDOM.render(&lt;TodoApp /&gt;, document.getElementById(&apos;todoApp&apos;)); More information about persisting your data using ReactFire here. 测试Most projects become a mountain of spaghetti code at some point during development due to lack of solid tests or no tests at all. ReactJS apps are no different, but this can be avoided if you know some core principles. When writing tests for ReactJS code, it is helpful to pull out any functionality that doesn’t have to do with any UI components into separate modules, so that they can be tested separately. Tools for unit testing those functionalities are mocha, expect, chai, jasmine. Testing becomes tricky in a ReactJS application when you have to deal with components. How do you test stateless components? How do you test components with state? Now, ReactJS provides a nice set of test utilities that allow us to inspect and examine the components we build. A particular concept worthy of mention is Shallow Rendering. Instead of rendering into a DOM the idea of shallow rendering is to instantiate a component and get the result of its render method. You can also check its props and children and verify they work as expected. More information here. Facebook uses Jest to test React applications. AirBnB uses Enzyme. When bootstrapping your ReactJS application, you can set up any of these awesome tools to implement testing. 脚手架和模板A lot of tools have been mentioned in this post in relation to setting up different parts of a ReactJS app. If you don’t intend writing your app from scratch, there are lots of generators and boilerplates that tie all these tools together to give you a great starting point for your app. One fantastic example is React Starter Kit. It has a Yeoman generator. It’s an isomorphic web app boilerplate that contains almost everything you need to build a ReactJS app. Another boilerplate is React Static boilerplate, it helps you build a web app that can be hosted directly from CDNs like Firebase and Github Pages. Other alternatives are React redux starter kit and React webpack generator. Recently, a nice and effective tool called create-react-app was released by the guys at Facebook. It’s a CLI tool that helps create React apps with no build configuration! 结语There are several tools that will help bootstrap your React app, we looked at a couple that we consider quite good and will have your application up and running in no time. But feel free to search for your own tools, and if you think that we are missing something, let us know in the comments. Setting up a React project should be painless! “Setting up a React project should be painless!”]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React遇到的坑.md]]></title>
    <url>%2F2017%2F10%2F31%2Freact%2FReact%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[当input框输入值时输入框自动被失去了焦点，原因是在render函数里又用了render。 参考网址：https://stackoverflow.com/questions/25385578/nested-react-input-element-loses-focus-on-typing input值不会随着属性改变而改变123&lt;Parent&gt; &lt;Child inputVal=&#123;this.state.inputVal&#125;/&gt;&lt;/Parent&gt; 当Child组件的value为null后input的值不会更改。所以一般要判断是否存在null值： 1&lt;FormControl value=&#123;this.props.inputVal || &apos;&apos;&#125;/&gt; UglifyJs编辑后有些arguments无效升级uglifyjs-webpack-plugin和uglify-js： 12&quot;uglify-js&quot;: &quot;^3.1.6&quot;,&quot;uglifyjs-webpack-plugin&quot;: &quot;^1.0.1&quot;,]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React入门——简介]]></title>
    <url>%2F2017%2F10%2F31%2Freact%2FReact%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[一、什么是React？ React是Facebook开源的一个用于构建用户界面的Javascript库，他不是一个框架，而是专注于MVC架构中的V，即视图。这使得React很容易和开发者已有的开发栈进行融合。React顺应了Web开发组件化的趋势。应用React时，你总是应该从UI出发抽象出不同的组件，然后像搭积木一样把它们拼装起来。 二、React能做什么？ 补充：桌面应用程序（NW.js和Electron.js） 二、React全家桶 自身库： react.js、react-dom.js、add-ons 语法：ES5/ES6、JSX 构建工具：Fis3、webpack、babel 状态管理：Redux、Flux、react-redux、Immutable 路由：react-router、react-redux-router 日志：redux-logger 中间件：redux-thunk 主题：react-bootstrap 表单：redux-form]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css样式遇到的坑]]></title>
    <url>%2F2017%2F10%2F31%2Fcss%2Fcss%E6%A0%B7%E5%BC%8F%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[bootstrap-datetime-picker在模态框中会随着页面滚动而错位解决方法：在options中增加container: &#39;#modalId .modal-dialog&#39;，默认的container是body，所以要改成.modal-dialog。]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express入门]]></title>
    <url>%2F2017%2F10%2F12%2Fnodejs%2Fexpress%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[配置handlebars12345678910111213//须安装express-handlebarsvar exhbs = require(&apos;express-handlebars&apos;);var index = require(&apos;./routes/index&apos;);var users = require(&apos;./routes/users&apos;);var app = express();// view engine setup，这边名称如果为.hbs，则文件命名结尾也是.hbs（extname无效？）app.engine(&apos;.hbs&apos;, exhbs(&#123; extname: &apos;.hbs&apos;&#125;));app.set(&apos;views&apos;, path.join(__dirname, &apos;views&apos;));app.set(&apos;view engine&apos;, &apos;.hbs&apos;); 使用supervisor进行热部署安装： 1npm install -g supervisor 如果你使用的是 Linux 或 Mac，直接键入上面的命令很可能会有权限错误。原因是 npm需要把 supervisor 安装到系统目录，需要管理员授权，可以使用 sudo npm install -g supervisor 命令来安装。 接下来，更改pcakge.json中的start字段： 1&quot;start&quot;: &quot;supervisor bin/www&quot; 之后运行npm start既可，命令行窗口会显示启动成功信息，即开启了代码监听。 开放API123456789101112131415161718192021222324252627282930313233343536var express = require(&apos;express&apos;);var router = express.Router();var mysql = require(&apos;mysql&apos;);var conncection = mysql.createConnection(&#123; host: &apos;localhost&apos;, user: &apos;root&apos;, password: &apos;*****&apos;, database: &apos;test&apos;, port: 3306&#125;);conncection.connect();router.get(&apos;/getFamilyList&apos;, function(req, res, next)&#123; conncection.query(&apos;select * from family&apos;, function(err, results, fields)&#123; if(err) throw err; res.json(results); &#125;);&#125;);router.get(&apos;/getFamilyById&apos;, function (req, res, next) &#123; conncection.query(&apos;select * from family where id=?&apos;, [req.query.id], function(err, results, fields)&#123; if(err) throw err; res.json(results[0]); &#125;);&#125;);router.post(&apos;/updateFamilyById&apos;, function (req, res, next) &#123; conncection.query(&apos;update family set name=?,age=? where id=?&apos;, [req.body.name, req.body.age, req.body.id], function(err, results, fields)&#123; if(err) throw err; res.json(&#123; status: true &#125;); &#125;);&#125;);module.exports = router;]]></content>
      <tags>
        <tag>express</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 16新增功能]]></title>
    <url>%2F2017%2F09%2F29%2Freact%2FReact%2016%E6%96%B0%E5%A2%9E%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[官网介绍https://facebook.github.io/react/blog/2017/09/26/react-v16.0.html render函数不必在包一层元素123456789render() &#123; // No need to wrap list items in an extra element! return [ // Don&apos;t forget the keys :) &lt;li key=&quot;A&quot;&gt;First item&lt;/li&gt;, &lt;li key=&quot;B&quot;&gt;Second item&lt;/li&gt;, &lt;li key=&quot;C&quot;&gt;Third item&lt;/li&gt;, ];&#125; 更好的错误处理以前的版本，如果子组件有报错整个组件本身直接不渲染，而现在可以通过componentDidCatch捕获错误信息： 123456789101112131415161718192021222324252627282930313233class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; error: null, errorInfo: null &#125;; &#125; componentDidCatch(error, errorInfo) &#123; // Catch errors in any components below and re-render with error message this.setState(&#123; error: error, errorInfo: errorInfo &#125;) // You can also log error messages to an error reporting service here &#125; render() &#123; if (this.state.errorInfo) &#123; // Error path return ( &lt;div&gt; &lt;h2&gt;Something went wrong.&lt;/h2&gt; &lt;details style=&#123;&#123; whiteSpace: &apos;pre-wrap&apos; &#125;&#125;&gt; &#123;this.state.error &amp;&amp; this.state.error.toString()&#125; &lt;br /&gt; &#123;this.state.errorInfo.componentStack&#125; &lt;/details&gt; &lt;/div&gt; ); &#125; // Normally, just render children return this.props.children; &#125;&#125; Portals现在可以通过React.createPortal(&lt;SomeComponent/&gt;, document.getElementById(&#39;root&#39;))的形式在react应用容器之外修改或增加DOM： 12345678render() &#123; // React does *not* create a new div. It renders the children into `domNode`. // `domNode` is any valid DOM node, regardless of its location in the DOM. return ReactDOM.createPortal( this.props.children, domNode, );&#125; 这样对于像要创建模态框就很容易了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Overlay extends React.Component&#123; constructor()&#123; super(); this.overlayContainer = document.createElement(&apos;div&apos;); document.body.appendChild(this.overlayContainer); &#125; componentWillUnmount()&#123; document.body.removeChild(this.overlayContainer); &#125; render()&#123; return ReactDOM.createPortal( &lt;div className=&quot;overlay&quot; style=&#123;&#123;position: &apos;absolute&apos;, top: 0, right: 0, bottom: 0, left: 0, background: &apos;rgba(0,0,0, 0.5)&apos;, color: &apos;#fff&apos;&#125;&#125;&gt; &#123;this.props.children&#125; &lt;/div&gt;, this.overlayContainer ) &#125;&#125;class Demo extends React.Component&#123; constructor()&#123; super(); this.state = &#123; overlayActive: true &#125;; &#125; render()&#123; return ( &lt;div&gt; &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; this.setState(&#123; user: null &#125;)&#125;&gt;Update&lt;/button&gt; &#123;this.state.overlayActive &amp;&amp; ( &lt;Overlay onClose=&#123;() =&gt; this.setState(&#123;overlayActive: false&#125;)&#125;&gt; hello modal!!! &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; this.setState(&#123;overlayActive: false&#125;)&#125;&gt;Close&lt;/button&gt; &lt;/Overlay&gt; )&#125; &lt;/div&gt; ); &#125;&#125; 更好的服务端渲染省略。。。 支持自定义DOM属性以前是直接忽视无法识别的属性，而现在是直接渲染给DOM，这也直接节省了很多代码。 具体参考：https://facebook.github.io/react/blog/2017/09/08/dom-attributes-in-react-16.html 文件减少 react is 5.3 kb (2.2 kb gzipped), down from 20.7 kb (6.9 kb gzipped). react-dom is 103.7 kb (32.6 kb gzipped), down from 141 kb (42.9 kb gzipped). react + react-dom is 109 kb (34.8 kb gzipped), down from 161.7 kb (49.8 kb gzipped). MIT协议妥协了… 新的核心架构Fiber]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native中FlatList的使用]]></title>
    <url>%2F2017%2F09%2F29%2Freact-native%2Freact-native%E4%B8%ADFlatList%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[原文地址：https://medium.com/react-native-development/how-to-use-the-flatlist-component-react-native-basics-92c482816fe6 简介自从0.43版本以来，react-native新增了两个新的列表视图组件：FlatList以及SectionList，现在我们来看看FlatList组件的使用。 简单示例在FlatList中有个比较重要的属性：data和renderItem属性，data为object数组，renderItem可以控制每个item的渲染规则。 这边的示例我们将会从Random User Generator API中拿，UI渲染将会使用react-native-elements的组件。 点击查看完整源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//FlatListDemo.jsimport React, &#123; Component &#125; from &quot;react&quot;;import &#123; View, Text, FlatList &#125; from &quot;react-native&quot;;class FlatListDemo extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; loading: false, data: [], page: 1, seed: 1, error: null, refreshing: false, &#125;; &#125; componentDidMount() &#123; this.makeRemoteRequest(); &#125; makeRemoteRequest = () =&gt; &#123; const &#123; page, seed &#125; = this.state; const url = `https://randomuser.me/api/?seed=$&#123;seed&#125;&amp;page=$&#123;page&#125;&amp;results=20`; this.setState(&#123; loading: true &#125;); fetch(url) .then(res =&gt; res.json()) .then(res =&gt; &#123; this.setState(&#123; data: page === 1 ? res.results : [...this.state.data, ...res.results], error: res.error || null, loading: false, refreshing: false &#125;); &#125;) .catch(error =&gt; &#123; this.setState(&#123; error, loading: false &#125;); &#125;); &#125;; render() &#123; return ( &lt;View style=&#123;&#123; flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; &#125;&#125;&gt; &lt;Text&gt;Coming soon...&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;export default FlatListDemo; 然后外边就可以使用： 12345678910111213141516171819202122import FlatList from &apos;./FlatListDemo.js&apos;;import React from &apos;react&apos;;import &#123; List, ListItem &#125; from &apos;react-native-elements&apos;;class AwesomeProject extends React.Component&#123; render()&#123; &lt;List&gt; &lt;FlatList data=&#123;this.state.data&#125; renderItem=&#123;(&#123; item &#125;) =&gt; ( &lt;ListItem roundAvatar title=&#123;`$&#123;item.name.first&#125; $&#123;item.name.last&#125;`&#125; subtitle=&#123;item.email&#125; avatar=&#123;&#123; uri: item.picture.thumbnail &#125;&#125; keyExtractor=&#123;item =&gt; item.email&#125; /&gt; )&#125; /&gt; &lt;/List&gt; &#125;&#125; 效果图如下：]]></content>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React高阶组件]]></title>
    <url>%2F2017%2F08%2F02%2Freact%2FReact%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[链接：https://zhuanlan.zhihu.com/p/24776678?group_id=802649040843051008 摘要这篇文章主要面向想要使用 HOC（Higher Order Component，高阶组件） 模式的进阶开发者。如果你是 React 新手，建议你从阅读 React 的文档开始。 高阶组件是一种很好的模式，很多 React 库已经证明了其价值。这篇文章中我们将会详细的讲解什么是 HOC，你能用它做什么，它有哪些局限，如何实现它。 在附录中有一些相关的话题，可能不是 HOC 的核心，但是我认为应该提到。 这篇文章尽量做到详尽无遗，如果你发现任何遗漏的，请提出来，我会做出必要的改动。 这篇文章假设你已经了解 ES6。 让我们开始吧！ 什么是高阶组件？ 高阶组件就是一个 React 组件包裹着另外一个 React 组件 这种模式通常使用函数来实现，基本上是一个类工厂（是的，一个类工厂！），它的函数签名可以用类似 haskell 的伪代码表示 1hocFactory:: W: React.Component =&gt; E: React.Component 其中 W (WrappedComponent) 指被包裹的 React.Component，E (EnhancedComponent) 指返回类型为 React.Component 的新的 HOC。 我们有意模糊了定义中“包裹”的概念，因为它可能会有以下两种不同的含义之一： Props Proxy： HOC 对传给 WrappedComponent W 的 porps 进行操作; Inheritance Inversion： HOC 继承 WrappedComponent W。 （译注：原作者在评论中提到希望对 Props Proxy 和 Inheritance Inversion 不做翻译，故保留原文） 我们会深入地探究这两种模式。 HOC 工厂的实现方法这一节我们将会研究 React 中两种 HOC 的实现方法：Props Proxy (PP) and Inheritance Inversion (II)。两种方法都可以操作 WrappedComponent。 Props ProxyProps Proxy (PP) 的最简实现： 1234567function ppHOC(WrappedComponent) &#123; return class PP extends React.Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125;/&gt; &#125; &#125; &#125; 这里主要是 HOC 在 render 方法中 返回 了一个 WrappedComponent 类型的 React Element。我们还传入了 HOC 接收到的 props，这就是名字 Props Proxy 的由来。 123&lt;WrappedComponent &#123;...this.props&#125;/&gt;// 等价于React.createElement(WrappedComponent, this.props, null) 在 React 内部的一致化处理（reconciliation process）中，两者都创建了一个 React Element 用于渲染。如果你想了解关于 React Elements vs Components ，请看 Dan Abramov 的这篇文章，想了解一致化处理请参考文档。 （译注：一致化处理（reconciliation process）可理解为 React 内部将虚拟 DOM 同步更新到真实 DOM 的过程，包括新旧虚拟 DOM 的比较及计算最小 DOM 操作） 使用 Props Proxy 可以做什么？ 操作 props 通过 Refs 访问到组件实例 提取 state 用其他元素包裹 WrappedComponent 操作 props你可以读取、添加、编辑、删除传给 WrappedComponent 的 props。 当删除或者编辑重要的 props 时要小心，你可能应该通过命名空间（命名空间是什么鬼？）确保高阶组件的 props 不会破坏 WrappedComponent。 例子：添加新的 props。在这个应用中，当前登录的用户可以在 WrappedComponent 中通过 this.props.user 访问到。 12345678910function ppHOC(WrappedComponent) &#123; return class PP extends React.Component &#123; render() &#123; const newProps = &#123; user: currentLoggedInUser &#125; return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125;/&gt; &#125; &#125;&#125; 通过 Refs 访问到组件实例你可以通过引用（ref）访问到 this （WrappedComponent 的实例），但为了得到引用，WrappedComponent 还需要一个初始渲染，意味着你需要在 HOC 的 render 方法中返回 WrappedComponent 元素，让 React 开始它的一致化处理，你就可以得到 WrappedComponent 的实例的引用。 例子：如何通过 refs 访问到实例的方法和实例本身： 123456789101112function refsHOC(WrappedComponent) &#123; return class RefsHOC extends React.Component &#123; proc(wrappedComponentInstance) &#123; wrappedComponentInstance.method() &#125; render() &#123; const props = Object.assign(&#123;&#125;, this.props, &#123;ref: this.proc.bind(this)&#125;) return &lt;WrappedComponent &#123;...props&#125;/&gt; &#125; &#125;&#125; Ref 的回调函数会在 WrappedComponent 渲染时执行，你就可以得到 WrappedComponent 的引用。这可以用来读取/添加实例的 props ，调用实例的方法。 提取 state你可以通过传入 props 和回调函数把 state 提取出来，类似于 smart component 与 dumb component。更多关于 dumb and smart component。 提取 state 的例子：提取了 input 的 value 和 onChange 方法。这个简单的例子不是很常规，但足够说明问题。 1234567891011121314151617181920212223242526function ppHOC(WrappedComponent) &#123; return class PP extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; name: &apos;&apos; &#125; this.onNameChange = this.onNameChange.bind(this) &#125; onNameChange(event) &#123; this.setState(&#123; name: event.target.value &#125;) &#125; render() &#123; const newProps = &#123; name: &#123; value: this.state.name, onChange: this.onNameChange &#125; &#125; return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125;/&gt; &#125; &#125;&#125; 你可以这样用： 123456@ppHOCclass Example extends React.Component &#123; render() &#123; return &lt;input name=&quot;name&quot; &#123;...this.props.name&#125;/&gt; &#125;&#125; 这个 input 会自动成为受控input。 更多关于常规的双向绑定 HOC 请点击 链接 用其他元素包裹 WrappedComponent为了封装样式、布局或别的目的，你可以用其它组件和元素包裹 WrappedComponent。基本方法是使用父组件（附录 B）实现，但通过 HOC 你可以得到更多灵活性。 例子：包裹样式 1234567891011function ppHOC(WrappedComponent) &#123; return class PP extends React.Component &#123; render() &#123; return ( &lt;div style=&#123;&#123;display: &apos;block&apos;&#125;&#125;&gt; &lt;WrappedComponent &#123;...this.props&#125;/&gt; &lt;/div&gt; ) &#125; &#125;&#125; Inheritance InversionInheritance Inversion (II) 的最简实现： 1234567function iiHOC(WrappedComponent) &#123; return class Enhancer extends WrappedComponent &#123; render() &#123; return super.render() &#125; &#125;&#125; 你可以看到，返回的 HOC 类（Enhancer）继承了 WrappedComponent。之所以被称为 Inheritance Inversion 是因为 WrappedComponent 被 Enhancer 继承了，而不是 WrappedComponent 继承了 Enhancer。在这种方式中，它们的关系看上去被反转（inverse）了。 Inheritance Inversion 允许 HOC 通过 this 访问到 WrappedComponent，意味着它可以访问到 state、props、组件生命周期方法和 render 方法。 关于生命周期方法可以用来做什么，我不想细说，因为它是 React 的特性而不是 HOC 的特性。但请注意通过 II 你可以创建新的生命周期方法。为了不破坏 WrappedComponent，记得调用 super.[lifecycleHook]。 一致化处理（Reconciliation process）开始之前我们先理清一些概念。 React 元素决定描述了在 React 执行一致化处理时它要渲染什么。 React 元素有两种类型：字符串和函数。字符串类型的 React 元素代表 DOM 节点，函数类型的 React 元素代表继承 React.Component 的组件。更多关于元素（Element）和组件（Component）请看这篇文章。 函数类型的 React 元素会在一致化处理中被解析成一个完全由字符串类型 React 组件组成的树（而最后的结果永远是 DOM 元素）。 这很重要，意味着 Inheritance Inversion 的高阶组件不一定会解析完整子树 Inheritance Inversion 的高阶组件不一定会解析完整子树 这在学习渲染劫持（Render Highjacking）时非常重要。 你可以用 Inheritance Inversion 做什么？ 渲染劫持（Render Highjacking） 操作 state 渲染劫持之所以被称为渲染劫持是因为 HOC 控制着 WrappedComponent 的渲染输出，可以用它做各种各样的事。 通过渲染劫持你可以： 在由 render输出的任何 React 元素中读取、添加、编辑、删除 props 读取和修改由 render 输出的 React 元素树 有条件地渲染元素树 把样式包裹进元素树（就像在 Props Proxy 中的那样） *render 指 WrappedComponent.render 方法 你不能编辑或添加 WrappedComponent 实例的 props，因为 React 组件不能编辑它接收到的 props，但你可以修改由 render 方法返回的组件的 props。 就像我们刚才学到的，II 类型的 HOC 不一定会解析完整子树，意味着渲染劫持有一些限制。根据经验，使用渲染劫持你可以完全操作 WrappedComponent 的 render 方法返回的元素树。但是如果元素树包括一个函数类型的 React 组件，你就不能操作它的子组件了。（被 React 的一致化处理推迟到了真正渲染到屏幕时） 例1：条件渲染。当 this.props.loggedIn 为 true 时，这个 HOC 会完全渲染 WrappedComponent 的渲染结果。（假设 HOC 接收到了 loggedIn 这个 prop） 1234567891011function iiHOC(WrappedComponent) &#123; return class Enhancer extends WrappedComponent &#123; render() &#123; if (this.props.loggedIn) &#123; return super.render() &#125; else &#123; return null &#125; &#125; &#125;&#125; 例2：修改由 render 方法输出的 React 组件树。 1234567891011121314function iiHOC(WrappedComponent) &#123; return class Enhancer extends WrappedComponent &#123; render() &#123; const elementsTree = super.render() let newProps = &#123;&#125;; if (elementsTree &amp;&amp; elementsTree.type === &apos;input&apos;) &#123; newProps = &#123;value: &apos;may the force be with you&apos;&#125; &#125; const props = Object.assign(&#123;&#125;, elementsTree.props, newProps) const newElementsTree = React.cloneElement(elementsTree, props, elementsTree.props.children) return newElementsTree &#125; &#125;&#125; 在这个例子中，如果 WrappedComponent 的输出在最顶层有一个 input，那么就把它的 value 设为 “may the force be with you”。 你可以在这里做各种各样的事，你可以遍历整个元素树，然后修改元素树中任何元素的 props。这也正是样式处理库 Radium 所用的方法（案例分析一节中有更多关于 Radium 的信息）。 注：在 Props Proxy 中不能做到渲染劫持。 虽然通过 WrappedComponent.prototype.render 你可以访问到 render 方法，不过还需要模拟 WrappedComponent 的实例和它的 props，还可能亲自处理组件的生命周期，而不是交给 React。根据我的实验，这么做不值，你要是想做到渲染劫持你应该用 Inheritance Inversion 而不是 Props Proxy。记住，React 在内部处理了组件实例，你处理实例的唯一方法是通过 this 或者 refs。 操作 stateHOC 可以读取、编辑和删除 WrappedComponent 实例的 state，如果你需要，你也可以给它添加更多的 state。记住，这会搞乱 WrappedComponent 的 state，导致你可能会破坏某些东西。要限制 HOC 读取或添加 state，添加 state 时应该放在单独的命名空间里，而不是和 WrappedComponent 的 state 混在一起。 例子：通过访问 WrappedComponent 的 props 和 state 来做调试。 1234567891011121314export function IIHOCDEBUGGER(WrappedComponent) &#123; return class II extends WrappedComponent &#123; render() &#123; return ( &lt;div&gt; &lt;h2&gt;HOC Debugger Component&lt;/h2&gt; &lt;p&gt;Props&lt;/p&gt; &lt;pre&gt;&#123;JSON.stringify(this.props, null, 2)&#125;&lt;/pre&gt; &lt;p&gt;State&lt;/p&gt;&lt;pre&gt;&#123;JSON.stringify(this.state, null, 2)&#125;&lt;/pre&gt; &#123;super.render()&#125; &lt;/div&gt; ) &#125; &#125;&#125; 这里 HOC 用其他元素包裹着 WrappedComponent，还输出了 WrappedComponent 实例的 props 和 state。JSON.stringify 的小技巧是由 Ryan Florence 和 Michael Jackson 教我的。这个调试器完整的实现在这里。 命名用 HOC 包裹了一个组件会使它失去原本 WrappedComponent 的名字，可能会影响开发和调试。 通常会用 WrappedComponent 的名字加上一些 前缀作为 HOC 的名字。下面的代码来自 React-Redux： 12345678HOC.displayName = `HOC($&#123;getDisplayName(WrappedComponent)&#125;)`//或class HOC extends ... &#123; static displayName = `HOC($&#123;getDisplayName(WrappedComponent)&#125;)` ...&#125; getDisplayName 函数： 12345function getDisplayName(WrappedComponent) &#123; return WrappedComponent.displayName || WrappedComponent.name || ‘Component’&#125; 实际上你不用自己写，recompose 提供了这个函数。]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js浅拷贝和深拷贝]]></title>
    <url>%2F2017%2F08%2F02%2Fjavascript%2Fjs%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[javaScript的变量类型（1）基本类型： 5种基本数据类型Undefined、Null、Boolean、Number 和 String，变量是直接按值存放的，存放在栈内存中的简单数据段，可以直接访问。 （2）引用类型： 存放在堆内存中的对象，变量保存的是一个指针，这个指针指向另一个位置。当需要访问引用类型（如对象，数组等）的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据。 JavaScript存储对象都是存地址的，所以浅拷贝会导致 obj1 和obj2 指向同一块内存地址。改变了其中一方的内容，都是在原来的内存上做修改会导致拷贝对象和源对象都发生改变，而深拷贝是开辟一块新的内存地址，将原对象的各个属性逐个复制进去。对拷贝对象和源对象各自的操作互不影响。 例如：数组拷贝 123456//浅拷贝，双向改变,指向同一片内存空间var arr1 = [1, 2, 3];var arr2 = arr1;arr1[0] = &apos;change&apos;;console.log(&apos;shallow copy: &apos; + arr1 + &quot; ); //shallow copy: change,2,3console.log(&apos;shallow copy: &apos; + arr2 + &quot; ); //shallow copy: change,2,3 浅拷贝的实现 简单的引用复制1234567891011121314function shallowClone(copyObj) &#123; var obj = &#123;&#125;; for ( var i in copyObj) &#123; obj[i] = copyObj[i]; &#125; return obj;&#125;var x = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [ 1, 2, 3 ]&#125;;var y = shallowClone(x);console.log(y.b.f === x.b.f); // true Object.assign()Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。 1234567var x = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [ 1, 2, 3 ]&#125;;var y = Object.assign(&#123;&#125;, x);console.log(y.b.f === x.b.f); // true 深拷贝的实现Array的slice和concat方法Array的slice和concat方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。之所以把它放在深拷贝里，是因为它看起来像是深拷贝。而实际上它是浅拷贝。原数组的元素会按照下述规则拷贝： 如果该元素是个对象引用 （不是实际的对象），slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。 对于字符串、数字及布尔值来说（不是 String、Number 或者 Boolean 对象），slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。 如果向两个数组任一中添加了新元素，则另一个不会受到影响。例子如下： 1234567var array = [1,2,3]; var array_shallow = array; var array_concat = array.concat(); var array_slice = array.slice(0); console.log(array === array_shallow); //true console.log(array === array_slice); //false，“看起来”像深拷贝console.log(array === array_concat); //false，“看起来”像深拷贝 可以看出，concat和slice返回的不同的数组实例，这与直接的引用复制是不同的。而从另一个例子可以看出Array的concat和slice并不是真正的深复制，数组中的对象元素(Object,Array等)只是复制了引用。如下： 123456789var array = [1, [1,2,3], &#123;name:&quot;array&quot;&#125;]; var array_concat = array.concat();var array_slice = array.slice(0);array_concat[1][0] = 5; //改变array_concat中数组元素的值 console.log(array[1]); //[5,2,3] console.log(array_slice[1]); //[5,2,3] array_slice[2].name = &quot;array_slice&quot;; //改变array_slice中对象元素的值 console.log(array[2].name); //array_sliceconsole.log(array_concat[2].name); //array_slice JSON对象的parse和stringifyJSON对象是ES5中引入的新的类型（支持的浏览器为IE8+），JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串，借助这两个方法，也可以实现对象的深拷贝。 123456789101112131415161718//例1var source = &#123; name:&quot;source&quot;, child:&#123; name:&quot;child&quot; &#125; &#125; var target = JSON.parse(JSON.stringify(source));target.name = &quot;target&quot;; //改变target的name属性console.log(source.name); //source console.log(target.name); //targettarget.child.name = &quot;target child&quot;; //改变target的child console.log(source.child.name); //child console.log(target.child.name); //target child//例2var source = &#123; name:function()&#123;console.log(1);&#125;, child:&#123; name:&quot;child&quot; &#125; &#125; var target = JSON.parse(JSON.stringify(source));console.log(target.name); //undefined//例3var source = &#123; name:function()&#123;console.log(1);&#125;, child:new RegExp(&quot;e&quot;) &#125;var target = JSON.parse(JSON.stringify(source));console.log(target.name); //undefinedconsole.log(target.child); //Object &#123;&#125; 这种方法使用较为简单，可以满足基本的深拷贝需求，而且能够处理JSON格式能表示的所有数据类型，但是对于正则表达式类型、函数类型等无法进行深拷贝(而且会直接丢失相应的值)。还有一点不好的地方是它会抛弃对象的constructor。也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object。同时如果对象中存在循环引用的情况也无法正确处理。 jQuery.extend()方法源码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354jQuery.extend = jQuery.fn.extend = function() &#123; //给jQuery对象和jQuery原型对象都添加了extend扩展方法 var options, name, src, copy, copyIsArray, clone, target = arguments[0] || &#123;&#125;, i = 1, length = arguments.length, deep = false; //以上其中的变量：options是一个缓存变量，用来缓存arguments[i]，name是用来接收将要被扩展对象的key，src改变之前target对象上每个key对应的value。 //copy传入对象上每个key对应的value，copyIsArray判定copy是否为一个数组，clone深拷贝中用来临时存对象或数组的src。 // 处理深拷贝的情况 if (typeof target === &quot;boolean&quot;) &#123; deep = target; target = arguments[1] || &#123;&#125;; //跳过布尔值和目标 i++; &#125; // 控制当target不是object或者function的情况 if (typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction(target)) &#123; target = &#123;&#125;; &#125; // 当参数列表长度等于i的时候，扩展jQuery对象自身。 if (length === i) &#123; target = this; --i; &#125; for (; i &lt; length; i++) &#123; if ((options = arguments[i]) != null) &#123; // 扩展基础对象 for (name in options) &#123; src = target[name]; copy = options[name]; // 防止永无止境的循环，这里举个例子，如var i = &#123;&#125;;i.a = i;$.extend(true,&#123;&#125;,i);如果没有这个判断变成死循环了 if (target === copy) &#123; continue; &#125; if (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) &#123; if (copyIsArray) &#123; copyIsArray = false; clone = src &amp;&amp; jQuery.isArray(src) ? src: []; // 如果src存在且是数组的话就让clone副本等于src否则等于空数组。 &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject(src) ? src: &#123;&#125;; // 如果src存在且是对象的话就让clone副本等于src否则等于空数组。 &#125; // 递归拷贝 target[name] = jQuery.extend(deep, clone, copy); &#125; else if (copy !== undefined) &#123; target[name] = copy; // 若原对象存在name属性，则直接覆盖掉；若不存在，则创建新的属性。 &#125; &#125; &#125; &#125; // 返回修改的对象 return target;&#125;; jQuery的extend方法使用基本的递归思路实现了浅拷贝和深拷贝，但是这个方法也无法处理源对象内部循环引用，例如： 12345var a = &#123;&quot;name&quot;:&quot;aaa&quot;&#125;;var b = &#123;&quot;name&quot;:&quot;bbb&quot;&#125;;a.child = b;b.parent = a;$.extend(true,&#123;&#125;,a);//直接报了栈溢出。Uncaught RangeError: Maximum call stack size exceeded 自己动手实现一个拷贝方法12345678910111213141516171819202122232425262728293031323334353637var $ = (function()&#123; var types = &apos;Array Object String Date RegExp Function Boolean Number Null Undefined&apos;.split(&apos; &apos;); function type() &#123; return Object.prototype.toString.call(this).slice(8, -1); &#125; for (var i = types.length; i--;) &#123; $[&apos;is&apos; + types[i]] = (function (self) &#123; return function (elem) &#123; return type.call(elem) === self; &#125;; &#125;)(types[i]); &#125; return $;&#125;)();//类型判断 function copy(obj,deep)&#123; if(obj === null || (!$.isObject(obj) &amp;&amp; !$.isFunction(obj)))&#123; return obj; &#125; if($.isFunction(obj))&#123; return new Function(&quot;return &quot; + obj.toString())(); &#125;else&#123; var name, target = $.isArray(obj) ? [] : &#123;&#125;, value; for(name in obj)&#123; value = obj[name]; if(value === obj) &#123; continue; &#125; if(deep &amp;&amp; ($.isArray(value) || $.isObject(value)))&#123; target[name] = copy(value,deep); &#125;else&#123; target[name] = value; &#125; &#125; return target; &#125; &#125;]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react文档-css动画]]></title>
    <url>%2F2017%2F08%2F02%2Freact%2Freact%E6%96%87%E6%A1%A3-css%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[TransitionGroup和CSSTransitionGroup已移动到react-transition-group有社区维护。它的1.x分支与现有插件的API是完全兼容的。 TransitionGroup是一个具有低级API的动画组件，而CSSTransitionGroup是一个基于css的animation和transition更容易被使用的组件。 高级API：CSSTransitionGroup123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import &#123; CSSTransitionGroup &#125; from &apos;react-transition-group&apos; // ES6var CSSTransitionGroup = require(&apos;react-transition-group/CSSTransitionGroup&apos;) // ES5 with npmclass TodoList extends React.Component&#123; constructor()&#123; super(); this.state = &#123; items: [ &apos;hello&apos;, &apos;world&apos;, &apos;click&apos;, &apos;me&apos; ] &#125;; this.handleAdd = this.handleAdd.bind(this); &#125; handleAdd() &#123; const newItems = this.state.items.concat([ prompt(&apos;Enter some text&apos;) ]); this.setState(&#123;items: newItems&#125;); &#125; handleRemove(i) &#123; let newItems = this.state.items.slice(); newItems.splice(i, 1); this.setState(&#123;items: newItems&#125;); &#125; render()&#123; const items = this.state.items.map((item, i) =&gt; ( &lt;div key=&#123;i&#125; onClick=&#123;() =&gt; this.handleRemove(i)&#125;&gt; &#123;item&#125; &lt;/div&gt; )); return ( &lt;div&gt; &lt;button type=&quot;button&quot; onClick=&#123;this.handleAdd&#125;&gt;Add Item&lt;/button&gt; &lt;CSSTransitionGroup transitionName=&quot;example&quot; transitionEnterTimeout=&#123;500&#125; transitionLeaveTimeout=&#123;300&#125; &gt; &#123;items&#125; &lt;/CSSTransitionGroup&gt; &lt;/div&gt; ); &#125;&#125; 在这个组件中，当一个新的Item被添加时，ReactCSSTransitionGroup将获得一个example-enter的类和example-enter-active的类，这些类名是基于trnasitionName的值。 您可以使用这些类来触发css动画或转换。例如：尝试添加如下样式： 1234567891011121314.example-enter&#123; opacity: 0.01;&#125;.example-enter.example-enter-active&#123; opacity: 1; transition: opacity 500ms ease-in;&#125;.example-leave&#123; opacity: 1;&#125;.example-leavel.example-leavel-active&#123; opacity: 0.01; transition: opacity 300ms ease-in;&#125; 初始化加载动画ReactCSSTransitionGroup提供一个可选的属性transitionAppear，以在组件的初始渲染时添加额外的过渡阶段。默认为false： 123456789101112render() &#123; return ( &lt;CSSTransitionGroup transitionName=&quot;example&quot; transitionAppear=&#123;true&#125; transitionAppearTimeout=&#123;500&#125; transitionEnter=&#123;false&#125; transitionLeave=&#123;false&#125;&gt; &lt;h1&gt;Fading at Initial Mount&lt;/h1&gt; &lt;/CSSTransitionGroup&gt; );&#125; 在初始化渲染ReactCSSTransitionGroup过程中，example-appear类和example-appear-active类将被添加。 1234567.example-appear &#123; opacity: 0.01;&#125;.example-appear.example-appear-active &#123; opacity: 1; transition: opacity .5s ease-in;&#125; 在初始化渲染阶段，所有ReactCSSTransitionGroup的孩子节点将会appear而不是enter，然而，所有孩子稍后被渲染后将会触发enter而不是appear。 注意： 属性transitionAppear在0.13版本中才被添加进入ReactCSSTransitionGroup中，为了向后兼容，默认值为false。 然而，transitionEnter和transtionLeave默认为true，所以你默认只要指定transitionEnterTimeout和transitionLeaveTimeout。 自定义类名当然，我们也可以使用自定义类名代替每一步默认的类名。你可以通过传递一个包含enter或leave或appear等等的对象给transitionName而不是字符串。 如果未提供active时，默认会为添加-active后的类名： 12345678910111213141516171819202122&lt;CSSTransitionGroup transitionName=&#123; &#123; enter: &apos;enter&apos;, enterActive: &apos;enterActive&apos;, leave: &apos;leave&apos;, leaveActive: &apos;leaveActive&apos;, appear: &apos;appear&apos;, appearActive: &apos;appearActive&apos; &#125; &#125;&gt;&#123;item&#125;&lt;/CSSTransitionGroup&gt;&lt;CSSTransitionGroup transitionName=&#123; &#123; enter: &apos;enter&apos;, leave: &apos;leave&apos;, appear: &apos;appear&apos; &#125; &#125;&gt; &#123;item2&#125;&lt;/CSSTransitionGroup&gt; 动画组必须已经被渲染到DOM为了时其子节点的动画能够生效，ReactCSSTransitionGroup必须已经被加载进DOM中，或者transitionAppear必须为true。 下面的例子将不会正常运行，因为ReactCSSTransitionGroup被和新的item一起渲染，而不是新的item渲染进其子节点： 123456789101112131415render() &#123; const items = this.state.items.map((item, i) =&gt; ( &lt;div key=&#123;item&#125; onClick=&#123;() =&gt; this.handleRemove(i)&#125;&gt; &lt;CSSTransitionGroup transitionName=&quot;example&quot;&gt; &#123;item&#125; &lt;/CSSTransitionGroup&gt; &lt;/div&gt; )); return ( &lt;div&gt; &lt;button onClick=&#123;this.handleAdd&#125;&gt;Add Item&lt;/button&gt; &#123;items&#125; &lt;/div&gt; );&#125; 渲染一个或零个子节点在上面的例子中，我们渲染了一个列表节点，当然，ReactCSSTransitionGroup也可以渲染一个或零个节点： 12345678910111213import ReactCSSTransitionGroup from &apos;react-addons-css-transition-group&apos;;function ImageCarousel(props) &#123; return ( &lt;div&gt; &lt;CSSTransitionGroup transitionName=&quot;carousel&quot; transitionEnterTimeout=&#123;300&#125; transitionLeaveTimeout=&#123;300&#125;&gt; &lt;img src=&#123;props.imageSrc&#125; key=&#123;props.imageSrc&#125; /&gt; &lt;/CSSTransitionGroup&gt; &lt;/div&gt; );&#125; 禁用动画可以通过设置false来禁用指定阶段，如：transitionEnter为false禁用进入后的动画效果。 注意：使用ReactCSSTransitionGroup你没办法知道一个transition已经结束或其他更详细的细节，如果你需要，则得使用低级APIReactTransitionGroup，它提供更多的钩子让你能够监听。 低级API：TransitionGroup12import TransitionGroup from &apos;react-transition-group/TransitionGroup&apos; // ES6var TransitionGroup = require(&apos;react-transition-group/TransitionGroup&apos;) // ES5 with npm ReactTransitionGroup是动画的基础。当子节点添加或删除，下面这些钩子函数将会被调用： componentWillAppear(callback) 这个方法将在渲染到节点时调用，它将阻塞其他当前正在发生的动画，知道callback被调用。这个方法仅仅在初始化渲染TransitionGroup时被调用。 componentDidAppear() 这个方法将在componentWillAppear的callback被调用后被调用。 componentWillEnter(callback) 当有新元素被添加到TransitionGroup时调用，它将会阻塞其他动画知道callback调用。 componentDidEnter() 在componentWillEnter的callback调用后触发。 componentWillLeave(callback) 当有元素被移除时触发，尽管元素已经被删除，但它还是还将保留在DOM中，直到callback被调用。 componentDidLeave() 在componentWillLeave的callback被调用时触发（和componentWillUnmount()同时触发）。 渲染其他组件TransitionGroup默认渲染为一个span，你通过增加一个compoennt属性改变默认行为： 123&lt;TransitionGroup component=&quot;ul&quot;&gt; &#123;/*...*/&#125;&lt;/TranstionGroup&gt; 另外，用户自定义的属性也会对应增加到组件的属性，如下例子，ul也将会得到className属性： 123&lt;TransitionGroup component=&quot;ul&quot; className=&quot;animated-list&quot;&gt; &#123;/* ... */&#125;&lt;/TransitionGroup&gt; 所有react可以渲染的组件都可以成为component，它不是必须为一个DOM节点，如：component={CustomList}，那么，TransitionGroup的子节点传递给CustomList组件的属性this.props.children。 渲染单独的子节点我们经常会用TransitionGroup来作为单独子节点的渲染和移除时的效果，诸如手风琴效果的面板。 正常情况下，TransitionGroup把其子节点包裹在一个span（或者自定义的component中），这是因为react的render函数必须返回单独子节点，但是TransitionGroup并不需要这样的规则。 然而，如果你需要只渲染一个单独子节点，你可以通过定义一个只渲染第一个子节点的组件： 1234function FirstChild(props) &#123; const childrenArray = React.Children.toArray(props.children); return childrenArray[0] || null;&#125; 现在你可以指定TransitionGroup的component属性为FirstChild来避免包裹外层组件： 123&lt;TransitionGroup component=&#123;FirstChild&#125;&gt; &#123;someCondition ? &lt;MyComponent /&gt; : null&#125;&lt;/TransitionGroup&gt; 这仅仅在你只想要渲染一个子节点时有用，在需要渲染多个节点时没有效果。]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flexbox布局兼容性总结]]></title>
    <url>%2F2017%2F08%2F02%2Fcss%2FFlexbox%E5%B8%83%E5%B1%80%E5%85%BC%E5%AE%B9%E6%80%A7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[写在前面IE9不支持…试了一下flexibility库，发现支持还好，就是嵌套的时候会有问题，因为它是通过定位的方式，暂时无解…… 入门教程传送门 W3C各个版本的flex 2009 version标志：display: box; or a property that is box-{*} (eg. box-pack) 2011 version标志：display: flexbox; or the flex() function or flex-pack property 2012 version标志：display: flex/inline-flex; and flex-{*} properties 2014 version新增了对flex项z-index的规定 2015 W3C Editor’s Draft没有大的改动 P.S.注意2015的是W3C Editor’s Draft，只是个草案，还处于修修改改的阶段，还没有征集浏览器供应商的意见。 浏览器兼容性关于flex的W3C规范： http://dev.w3.org/csswg/css-flexbox-1/ 浏览器兼容性可以参考CanIUse： http://caniuse.com/#feat=flexbox 根据CanIUse的数据可以总结如下： IE10部分支持2012，需要-ms-前缀 Android4.1/4.2-4.3部分支持2009 ，需要-webkit-前缀 Safari7/7.1/8部分支持2012， 需要-webkit-前缀 IOS Safari7.0-7.1/8.1-8.3部分支持2012，需要-webkit-前缀 所以需要考虑新版本2012： http://www.w3.org/TR/2012/CR-css3-flexbox-20120918/ 而Android需要考虑旧版本2009： http://www.w3.org/TR/2009/WD-css3-flexbox-20090723/ 浏览器兼容的flex语法上面分析得很清楚，针对需要兼容的目标使用对应版本的语法就好了，下面给出常用的布局代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/* 子元素-平均分栏 */.flex1 &#123; -webkit-box-flex: 1; /* OLD - iOS 6-, Safari 3.1-6 */ -moz-box-flex: 1; /* OLD - Firefox 19- */ width: 20%; /* For old syntax, otherwise collapses. */ -webkit-flex: 1; /* Chrome */ -ms-flex: 1; /* IE 10 */ flex: 1; /* NEW, Spec - Opera 12.1, Firefox 20+ */&#125;/* 父元素-横向排列（主轴） */.flex-h &#123; display: box; /* OLD - Android 4.4- */ display: -webkit-box; /* OLD - iOS 6-, Safari 3.1-6 */ display: -moz-box; /* OLD - Firefox 19- (buggy but mostly works) */ display: -ms-flexbox; /* TWEENER - IE 10 */ display: -webkit-flex; /* NEW - Chrome */ display: flex; /* NEW, Spec - Opera 12.1, Firefox 20+ */ /* 09版 */ -webkit-box-orient: horizontal; /* 12版 */ -webkit-flex-direction: row; -moz-flex-direction: row; -ms-flex-direction: row; -o-flex-direction: row; flex-direction: row;&#125;/* 父元素-横向换行 */.flex-hw &#123; /* 09版 */ /*-webkit-box-lines: multiple;*/ /* 12版 */ -webkit-flex-wrap: wrap; -moz-flex-wrap: wrap; -ms-flex-wrap: wrap; -o-flex-wrap: wrap; flex-wrap: wrap;&#125;/* 父元素-水平居中（主轴是横向才生效） */.flex-hc &#123; /* 09版 */ -webkit-box-pack: center; /* 12版 */ -webkit-justify-content: center; -moz-justify-content: center; -ms-justify-content: center; -o-justify-content: center; justify-content: center; /* 其它取值如下： align-items 主轴原点方向对齐 flex-end 主轴延伸方向对齐 space-between 等间距排列，首尾不留白 space-around 等间距排列，首尾留白 */&#125;/* 父元素-纵向排列（主轴） */.flex-v &#123; display: box; /* OLD - Android 4.4- */ display: -webkit-box; /* OLD - iOS 6-, Safari 3.1-6 */ display: -moz-box; /* OLD - Firefox 19- (buggy but mostly works) */ display: -ms-flexbox; /* TWEENER - IE 10 */ display: -webkit-flex; /* NEW - Chrome */ display: flex; /* NEW, Spec - Opera 12.1, Firefox 20+ */ /* 09版 */ -webkit-box-orient: vertical; /* 12版 */ -webkit-flex-direction: column; -moz-flex-direction: column; -ms-flex-direction: column; -o-flex-direction: column; flex-direction: column;&#125;/* 父元素-纵向换行 */.flex-vw &#123; /* 09版 */ /*-webkit-box-lines: multiple;*/ /* 12版 */ -webkit-flex-wrap: wrap; -moz-flex-wrap: wrap; -ms-flex-wrap: wrap; -o-flex-wrap: wrap; flex-wrap: wrap;&#125;/* 父元素-竖直居中（主轴是横向才生效） */.flex-vc &#123; /* 09版 */ -webkit-box-align: center; /* 12版 */ -webkit-align-items: center; -moz-align-items: center; -ms-align-items: center; -o-align-items: center; align-items: center;&#125;/* 子元素-显示在从左向右（从上向下）第1个位置，用于改变源文档顺序显示 */.flex-1 &#123; -webkit-box-ordinal-group: 1; /* OLD - iOS 6-, Safari 3.1-6 */ -moz-box-ordinal-group: 1; /* OLD - Firefox 19- */ -ms-flex-order: 1; /* TWEENER - IE 10 */ -webkit-order: 1; /* NEW - Chrome */ order: 1; /* NEW, Spec - Opera 12.1, Firefox 20+ */&#125;/* 子元素-显示在从左向右（从上向下）第2个位置，用于改变源文档顺序显示 */.flex-2 &#123; -webkit-box-ordinal-group: 2; /* OLD - iOS 6-, Safari 3.1-6 */ -moz-box-ordinal-group: 2; /* OLD - Firefox 19- */ -ms-flex-order: 2; /* TWEENER - IE 10 */ -webkit-order: 2; /* NEW - Chrome */ order: 2; /* NEW, Spec - Opera 12.1, Firefox 20+ */&#125;为了更好的兼容性，我们需要给容器声明flex-h/flex-v，而不是一般的flex：/* 父元素-flex容器 */.flex &#123; display: box; /* OLD - Android 4.4- */ display: -webkit-box; /* OLD - iOS 6-, Safari 3.1-6 */ display: -moz-box; /* OLD - Firefox 19- (buggy but mostly works) */ display: -ms-flexbox; /* TWEENER - IE 10 */ display: -webkit-flex; /* NEW - Chrome */ display: flex; /* NEW, Spec - Opera 12.1, Firefox 20+ */&#125; 所以，建议在需要兼容Android时（2009版语法）采用flex-h/flex-v声明容器使用flex模式，在不需要兼容Android时（2012版语法）使用flex设置容器 注意：上面给的代码并不是完全兼容各个高端浏览器的，但要比任何其它现有代码兼容性好，具体兼容性测试结果请看Demo sass定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107@mixin flex&#123; display: box; /* old - Android 4.4- */ display: -webkit-box; /* old - IOS 6-, Safari 3.1-6 */ display: -moz-box; /* old - Firefox 19 - (buggy but most works) */ display: -ms-flexbox; /* IE 10 */ display: -webkit-flex; /* New - Chrome */ display: flex; -js-display: flex;&#125;@mixin flexDirection($type: row)&#123; /* 09版 */ @if $type == &apos;row&apos;&#123; -webkit-box-orient: horizontal; &#125;@else if $type == &apos;row-reverse&apos;&#123; -webkit-box-orient: horizontal; &#125;@else if $type == &apos;column&apos;&#123; -webkit-box-orient: vertical; &#125;@else if $type == &apos;column-reverse&apos;&#123; -webkit-box-orient: vertical; &#125; /* 12版 */ -webkit-flex-direction: $type; -moz-flex-direction: $type; -ms-flex-direction: $type; -o-flex-direction: $type; flex-direction: $type; -js-flex-direction: $type;&#125;@mixin flexWrap($type: nowrap)&#123; /* 09版 */ /*-webkit-box-lines: multiple;*/ /* 12版 */ -webkit-flex-wrap: $type; -moz-flex-wrap: $type; -ms-flex-wrap: $type; -o-flex-wrap: $type; flex-wrap: $type; -js-flex-wrap: $type;&#125;@mixin justifyContent($type: flex-start)&#123; /* 09版 */ //-webkit-box-pack: justify; /* 12版 */ -webkit-justify-content: $type; -moz-justify-content: $type; -ms-justify-content: $type; -o-justify-content: $type; justify-content: $type; /* 其它取值如下： align-items 主轴原点方向对齐 flex-end 主轴延伸方向对齐 space-between 等间距排列，首尾不留白 space-around 等间距排列，首尾留白 */ -js-justify-content: $type;&#125;@mixin alignItems($type: stretch)&#123; /* 09版 */ //-webkit-box-align: center; /* 12版 */ -webkit-align-items: $type; -moz-align-items: $type; -ms-align-items: $type; -o-align-items: $type; align-items: $type; -js-align-items: $type;&#125;@mixin alignContent($type: stretch)&#123; /* 09版 */ //-webkit-box-align: center; /* 12版 */ -webkit-align-content: $type; -moz-align-content: $type; -ms-align-content: $type; -o-align-content: $type; align-content: $type; -js-align-content: $type;&#125;@mixin flexOrder($val: 0)&#123; -webkit-box-ordinal-group: $val; /* OLD - iOS 6-, Safari 3.1-6 */ -moz-box-ordinal-group: $val; /* OLD - Firefox 19- */ -ms-flex-order: $val; /* TWEENER - IE 10 */ -webkit-order: $val; /* NEW - Chrome */ order: $val; /* NEW, Spec - Opera 12.1, Firefox 20+ */ -js-order: $val;&#125;@mixin flexGrow($val: 0)&#123; -webkit-box-flex-grow: $val; /* OLD - iOS 6-, Safari 3.1-6 */ -moz-box-flex-grow: $val; /* OLD - Firefox 19- */ -webkit-flex-grow: $val; /* Chrome */ -ms-flex-grow: $val; /* IE 10 */ flex-grow: $val; /* NEW, Spec - Opera 12.1, Firefox 20+ */ -js-flex-grow: $val;&#125;@mixin flexShrink($val: 1)&#123; -webkit-box-flex-shrink: $val; /* OLD - iOS 6-, Safari 3.1-6 */ -moz-box-flex-shrink: $val; /* OLD - Firefox 19- */ -webkit-flex-shrink: $val; /* Chrome */ -ms-flex-shrink: $val; /* IE 10 */ flex-shrink: $val; /* NEW, Spec - Opera 12.1, Firefox 20+ */ -js-flex-shrink: $val;&#125;//横向.#&#123;$namespace&#125;flex-h&#123; @include flex(); @include flexDirection();&#125;]]></content>
      <tags>
        <tag>css</tag>
        <tag>flexbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于同一元素下dbClick触发两次click的问题]]></title>
    <url>%2F2017%2F08%2F02%2Fjavascript%2F%E5%85%B3%E4%BA%8E%E5%90%8C%E4%B8%80%E5%85%83%E7%B4%A0%E4%B8%8BdbClick%E8%A7%A6%E5%8F%91%E4%B8%A4%E6%AC%A1click%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题将处理程序绑定到相同元素的click和dblclick事件是不合适的。 触发的事件顺序因浏览器而异，有些在dblclick之前接收到两个点击事件，而其他事件只有一个。 双击灵敏度（双击检测到的点击之间的最大时间）可能因操作系统和浏览器而异，并且通常是用户可配置的。 所以最好不要在同一个元素下绑定click和dbclick事件。 解决方法方法一： 12345678910111213141516var v_Result; function OneClick(event) &#123; console.log(&quot;detail&quot;,event.detail); //if (event.detail == 2) // return ; v_Result = false; window.setTimeout(check, 300); function check() &#123; if (v_Result != false) return; console.log(&quot;单击&quot;); &#125; &#125; function TwoClick() &#123; v_Result = true; console.log(&quot;双击&quot;); &#125; 方法二： 123456789101112131415161718192021222324252627var clickTimer = null; function _click() &#123; if (clickTimer) &#123; console.log(&quot;clearTimeout&quot;, clickTimer); window.clearTimeout(clickTimer); clickTimer = null; &#125; clickTimer = window.setTimeout(function() &#123; // your click process code here console.log(&quot;你单击了我&quot;); &#125;, 300); console.log(&quot;setTimeout&quot;, clickTimer); &#125; function _dblclick() &#123; console.log(&quot;dblclick&quot;); if (clickTimer) &#123; console.log(&quot;=clearTimeout&quot;, clickTimer); window.clearTimeout(clickTimer); clickTimer = null; &#125; // your click process code here console.log(&quot;你双击了我&quot;); &#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6的坑]]></title>
    <url>%2F2017%2F08%2F02%2Fjavascript%2FES6%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[IE8下用babel转换会报错： function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; } 解决方法： $ npm install --save-dev babel-plugin-transform-es2015-modules-simple-commonjs 配置： //webpack.config.js &quot;plugins&quot;: [&quot;transform-es2015-modules-simple-commonjs&quot;] ES6 + angular1 + webpack，遇到controller文件里的constructor运行2次？ 那是因为声明了2次controller，在配置中配了app.controller(&#39;MyController&#39;)，然后又在页面中使用了ng-controller，导致运行了2次，坑爹~ Babel转ES5后IE8下的兼容性解决方法。 1)webpack配置文件，增加插件transform-es3-property-literals和transform-es3-member-expression-literals const webpackdevConfig = { entry: entry, output: { path: path.join(__dirname, &apos;dist/js&apos;), filename: &apos;[name].js&apos;, publicPath: &apos;/static/&apos; }, plugins: [ new webpack.NoErrorsPlugin(), ], module: { loaders: [ { test: /\.js$/, loader: [&apos;babel&apos;], include: [path.join(new_dir, &apos;src&apos;)], query:{ &quot;presets&quot;: [&quot;es2015&quot;, &quot;stage-0&quot;], &quot;plugins&quot; : [ &quot;transform-es3-property-literals&quot;, &quot;transform-es3-member-expression-literals&quot;, ] } }, {test: /\.scss$/, loaders: [&apos;style&apos;, &apos;css&apos;, &apos;sass&apos;], include: path.join(new_dir, &apos;src/style&apos;)}, {test: /\.(jpg|png)$/, loader: &apos;url-loader?limit=8192&apos;, include: path.join(new_dir, &apos;src/img&apos;)} ] } } 2)模块导出不能使用 export default ，改为export { xxx } 3)模块引入使用 import { } from ‘xxx’ 4)引入es5-shim.min.js和es5-sham.min.js]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React获取父组件或子组件属性]]></title>
    <url>%2F2017%2F08%2F02%2Freact%2Freact%E8%8E%B7%E5%8F%96%E7%88%B6%E7%BB%84%E4%BB%B6%E6%88%96%E5%AD%90%E7%BB%84%E4%BB%B6%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[获取子组件的方法可以通过递归this.props.children中得到 获取父组件的方法方法一：可以通过react内部私有函数this._reactInternalInstance._currentElement._owner._instance获取 12345678910111213141516171819var Parent = React.createClass(&#123; render() &#123; return &lt;Child v=&quot;test&quot; /&gt;; &#125;, doAThing() &#123; console.log(&quot;I&apos;m the parent, doing a thing.&quot;, this.props.testing); &#125;&#125;);var Child = React.createClass(&#123; render() &#123; return &lt;button onClick=&#123;this.onClick&#125;&gt;&#123;this.props.v&#125;&lt;/button&gt; &#125;, onClick() &#123; var parent = this._reactInternalInstance._currentElement._owner._instance; console.log(&quot;parent:&quot;, parent); parent.doAThing(); &#125;&#125;);ReactDOM.render(&lt;Parent testing=&#123;true&#125; /&gt;, container); 但是这种方法是不推荐的。 方法二：通过属性传递给子组件 12345678910111213class Parent extends React.Component &#123; constructor(props) &#123; super(props) this.fn = this.fn.bind(this) &#125; fn() &#123; console.log(&apos;parent&apos;) &#125; render() &#123; return &lt;Child fn=&#123;this.fn&#125; /&gt; &#125;&#125;const Child = (&#123; fn &#125;) =&gt; &lt;button onClick=&#123;fn&#125;&gt;Click me!&lt;/button&gt; 但是这种只在Child组件在Parent组件中时才可以用。 方法三：使用上下文（没有直接的父/子关系） 123456789101112131415161718192021222324class Parent extends React.Component &#123; constructor(props) &#123; super(props) this.fn = this.fn.bind(this) &#125; getChildContext() &#123; return &#123; fn: this.fn, &#125; &#125; fn() &#123; console.log(&apos;parent&apos;) &#125; render() &#123; return &lt;Child fn=&#123;this.fn&#125; /&gt; &#125;&#125;Parent.childContextTypes = &#123; fn: React.PropTypes.func,&#125;const Child = (props, &#123; fn &#125;) =&gt; &lt;button onClick=&#123;fn&#125;&gt;Click me!&lt;/button&gt;Child.contextTypes = &#123; fn: React.PropTypes.func,&#125; 给子组件（没有直接父/子关系）添加属性1return React.cloneElement(this.props.children, &#123;/*要添加的属性*/&#125;) React关于子组件的APIReact.chlidren.map1React.Children.map(children, function[(thisArg)]) 对包含在 children 中的每个直接子元素调用一个函数，使用 this 设置 thisArg 。 如果 children 是一个键片段（keyed fragment）或数组，它将被遍历：该函数永远不会传递容器对象（container objects）。 如果 children 为 null 或 undefined ，返回 null 或 undefined，而不是一个数组。 12345678910111213141516171819202122232425262728import React from &apos;react&apos;;const Salmonize = (&#123; children &#125;) =&gt; ( &lt;div&gt; &#123;React.Children.map(children, child =&gt; ( React.cloneElement(child, &#123; style: &#123; backgroundColor: &apos;salmon&apos;, color: &apos;seagreen&apos;, &#125; &#125;) ))&#125; &lt;/div&gt;);const SalmonBlog = (&#123; title, posts &#125;) =&gt; ( &lt;div&gt; &lt;Salmonize&gt; &lt;NavBar title=&#123;title&#125; /&gt; &lt;/Salmonize&gt; &#123;posts.map(post =&gt; ( &lt;Post key=&#123;post.id&#125;&gt; &lt;Salmonize&gt; &lt;PostHeader title=&#123;post.title&#125; /&gt; &lt;/Salmonize&gt; &lt;PostBody text=&#123;post.text&#125; /&gt; &lt;/Post&gt; ))&#125; &lt;/div&gt;); 在上面这个例子中，Salmonize组件并不需要在乎谁是它的子组件，它通过遍历克隆每个子组件，通过React.cloneElement给子组件增加属性。 在React中编写真正可重复使用的组件肯定有点棘手，如果你遇到这样的麻烦，那么这种map和clone方法可以帮助到你。 React.children.forEach1React.Children.forEach(children, function[(thisArg)]) 类似React.children.map，但是没有返回值。 React.Children.count1React.Children.count(children) 返回 children 中的组件总数，等于传递给 map 或 forEach 的回调将被调用的次数。 React.Children.only1React.Children.only(children) 返回 children 中的唯一子集。否则抛出异常。当您想要确保组件只有一个子级时，这可能会派上用场，如果不满足此条件，则会抛出错误。 12345678export default React.createClass(&#123; // ... render: function() &#123; const &#123;name, selectedValue, onChange, children&#125; = this.props; const renderedChildren = children(radio(name, selectedValue, onChange)); return renderedChildren &amp;&amp; React.Children.only(renderedChildren); &#125;&#125;); React.Children.toArray1React.Children.toArray(children) 将 children 不透明数据结构作为一个平面数组返回，并且 key 分配给每个子集。 如果你想在渲染方法中操作children集合，特别是如果你想在传递它之前重新排序或切割 this.props.children ，这将非常有用。 该方法将children组件的支持转换为纯JavaScript数组，这可以使您比React.Children.map提供更多的灵活性。React.Children.toArray最近在我想要渲染一个分隔符的列表中时，它们之间散布着很方便。这导致我创建一个完成这个的组件。 123456789101112131415161718192021import React from &apos;react&apos;;const IntersperseDividers = (&#123; children &#125;) =&gt; ( &lt;div&gt; &#123;React.Children.toArray(children).reduce((elements, child, i, array) =&gt; &#123; elements.push(child); if (i &lt; array.length - 1) &#123; elements.push(&lt;hr key=&#123;`$&#123;i&#125;--divider`&#125; /&gt;); &#125; return elements; &#125;, [])&#125; &lt;/div&gt;);const List = (&#123; data &#125;) =&gt; ( &lt;IntersperseDividers&gt; &#123;data.map((item, i) =&gt; ( &lt;div key=&#123;i&#125;&gt; &#123;item.value&#125; &lt;/div&gt; ))&#125; &lt;/IntersperseDividers&gt;);]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React要手动绑定方法的原因]]></title>
    <url>%2F2017%2F08%2F02%2Freact%2FReact%E8%A6%81%E6%89%8B%E5%8A%A8%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%E7%9A%84%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[我们从javascript开始吧在js中，函数的上下文是指函数调用的时候，而不是定义的时候。 有以下四中调用函数的模式： 函数调用模式 方法调用模式 构造函数调用模式 应用调用模式 所有这些使用的模式都不同地定义函数上下文。接下来我们看看各种模式的区别。 函数调用模式定义：如果在调用时没有.操作，那么上下文可能为window。 调用函数最直接的方法就是直接调用它： 1234var func = function()&#123; //...&#125;;func(); 这时的上下文（this）将会设置成javascript操作环境的全局变量，在浏览器中，它是window变量。 我们再来看另一个例子： 12345var unicorns = &#123; func: function() &#123; // ... &#125;&#125;;var fun = unicorns.func;fun(); 你认为在func中的上下文为uniconrns对象？那是错误的，由于上下文时通过调用此函数时确定的，所以这里的上下文还是window。 方法调用模式定义：如果函数调用中有点操作，则上下文将会是一序列点中最右边的那个变量。 如上面的例子中，如果我们直接调用unicorns.func()，上下文会是unicorns对象。 123456789var frog = &#123; RUN_SOUND: &quot;POP!!&quot;, run: function() &#123; return this.RUN_SOUND; &#125;&#125;;frog.run(); // returns &quot;POP!!&quot; since this points to the `frog` object.var runningFun = frog.run;runningFun(); // returns &quot;undefined&quot; since this points to the window 构造函数模式定义：每次看到一个new函数名后，你this将指向一个新创建的新对象。 123function Wizard() &#123; this.castSpell = function() &#123; return &quot;KABOOM&quot;; &#125;&#125; 直接调用它将会是window（因为它是一个函数调用），但是如果通过new来调用： 12345function Wizard() &#123; this.castSpell = function() &#123; return &quot;KABOOM&quot;; &#125;;&#125;var merlin = new Wizard(); // this is set to an empty object &#123;&#125;. Returns `this` implicitly.merlin.castSpell() // returns &quot;KABOOM&quot;; 这将会发生两件事： 函数将会有一个指向当前对象的上下文this。 如果没有指定return或者这个函数返回一个非对象值，this将从这个函数返回。 应用调用模式当你对函数有引用的时候，你可以通过两种方法来手动提供上下文： call apply 1234567function addAndSetX(a, b) &#123; this.x += a + b;&#125;var obj1 = &#123; x: 1, y: 2 &#125;;addAndSetX.call(obj1, 1, 1); // this = obj1, obj1 after call = &#123; x: 3, y : 2 &#125;// It is the same as:// addAndSetX.apply(obj1, [1, 1]); 如果您需要调用从某个其他地方传递的函数（例如，作为参数到函数中）与某个上下文对象，这是非常方便的。它不是非常可用于异步回调，因为绑定与一个函数调用相结合。 要使用回调设置正确的上下文，您可能需要另一种方便的技术 - 您可以从中创建有界函数。 绑定功能有界函数是一个限定给定上下文的函数，这意味着无论你怎么调用它，它的上下文都是不变的。唯一例外是总是返回一个新上下文的new运算符。 要是普通函数变成有界函数，应该使用bind方法，bind方法将您要将函数绑定到的上下文作为第一个参数。其余的参数是将始终传递给这样的函数的参数。 结果返回有界函数。我们来看一个例子： 12345678910function add(x, y) &#123; this.result += x + y;&#125;var computation1 = &#123; result: 0 &#125;;var boundedAdd = add.bind(computation1);boundedAdd(1, 2); // `this` is set to `computation1`. // computation1 after call: &#123; result: 3 &#125;var boundedAddPlusTwo = add.bind(computation1, 2);boundedAddPlusTwo(4); // `this` is set to `computation1`. // computation1 after call: &#123; result: 9 &#125; 被绑定了的函数甚至不能在通过call或apply改变上下文： 123456789var obj = &#123; boundedPlusTwo: boundedAddPlusTwo &#125;;obj.boundedPlusTwo(4); // `this` is set to `computation1`. // even though method is called on `obj`. // computation1 after call: &#123; result: 15 &#125;var computation2 = &#123; result: 0 &#125;;boundedAdd.call(computation2, 1, 2); // `this` is set to `computation1`. // even though context passed to call is // `computation2` // computation1 after call: &#123; result: 18 &#125; 您现在已经掌握了关于JavaScript的知识，现在让我们来看react中的情况。 怎么绑定以及绑定什么ECMAScript 2015（ECMAScript 6）引入了一种新的类语法，可用于创建React组件类。实际上，这个类语法是面向对象JavaScript 的旧的原型系统的语法糖。 这意味着ES2015类中的函数上下文调用遵循与其余JavaScript相同的原则。 123456789101112class Foo &#123; constructor() &#123; this.x = 2; this.y = 4; &#125; bar() &#123; // ... &#125; baz() &#123; // ... &#125;&#125; 与以下大致相同： 123456function Foo() &#123; this.x = 2; this.y = 4; this.bar = function() &#123; // ... &#125;; this.baz = function() &#123; // ... &#125;;&#125; 记住这只是一个简化。在确定函数上下文调用的情况下，这个更复杂的逻辑遵循与上面的代码片段相同的原理。 React.createClass在这个语法下，绑定问题是不存在的，在传递给对象的对象中定义的所有方法React.createClass将自动绑定到组件实例。这意味着你可以随时使用setState，访问props和state等等这些方法。 尽管在99％的情况下可能完全可以接受，但它限制了您对任意设置上下文的能力 - 这可能是更复杂的代码库中的一个大问题。 ECMAScript 2015 classes在ECMAScript 2015 classes写法中，你需要手动绑定方法。 以下是React库中是可以识别为方法调用模式执行调用： 组件生命周期方法。它仅仅通过component.componentDidUpdate(…)方式调用（因此，this已经正确绑定到组件实例本身）。 render方法。它也是被识别为方法调用模式执行调用。大多数的非事件处理函数在render方法中调用，它已经被自动绑定到组件实例，所以你可以放心使用。 但是，传递给事件处理属性的函数可能有许多来源，甚至可能通过顶级组件的属性从非React级别传递给他们。 在React.createClassReact假定它们来自您的组件并自动绑定它们。但是在ES2015 classes中你有自由。在引擎中，它们被以函数调用模式调用。 这意味这，在默认情况下，你无法在事件处理程序中读取组件属性、状态和组件的方法，为此，你需要明确地绑定他们。 绑定事件处理程序的最佳位置是构造函数： 1234567891011121314class InputExample extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; text: &apos;&apos; &#125;; this.change = this.change.bind(this); &#125; change(ev) &#123; this.setState(&#123; text: ev.target.value &#125;); &#125; render() &#123; let &#123; text &#125; = this.state; return (&lt;input type=&quot;text&quot; value=&#123;text&#125; onChange=&#123;this.change&#125; /&gt;); &#125;&#125; 这样你的事件处理程序的上下文将会绑定到组件实例中。 类属性有一个实验功能，称为类属性，可以帮助您明确避免绑定方法。它是用于在构造函数中定义字段和函数的语法糖。看起来像这样： 1234class InputExample extends React.Component &#123; state = &#123; text: &apos;&apos; &#125;; // ...&#125; 并编译成以下： 1234567class InputExample extends React.Component &#123; constructor(...arguments) &#123; super(...arguments); this.state = &#123; text: &apos;&apos; &#125;; &#125; // ...&#125; 那么怎么定义一个方法呢？ 1234567class InputExample extends React.Component &#123; state = &#123; text: &apos;&apos; &#125;; change = function(ev) &#123; this.setState(&#123; text: ev.target.value &#125;); &#125;; // ...&#125; 所以现在，你得到一个等同于以下类： 12345678910class InputExample extends React.Component &#123; constructor(...arguments) &#123; super(...arguments); this.state = &#123; text: &apos;&apos; &#125;; this.change = function(ev) &#123; this.setState(&#123; text: ev.target.value &#125;); &#125;; &#125; // ...&#125; 但是这样有一个问题，this.change函数上下文还是错误的，所以我们要结合箭头函数： 12345678class InputExample extends React.Component &#123; state = &#123; text: &apos;&apos; &#125;; change = ev =&gt; this.setState(&#123;text: ev.target.value&#125;); render() &#123; let &#123;text&#125; = this.state; return (&lt;input type=&quot;text&quot; value=&#123;text&#125; onChange=&#123;this.change&#125; /&gt;); &#125;&#125; 该解决方案的缺点是类属性仍处于实验阶段。这意味着此功能可以在ECMAScript 2016（也称为ECMAScript 7或ES7）的后续迭代中被删除，而不会发出警告。 createClass以及class语法编译完的不同我们先来看类写法： 12345678910111213141516class Todo extends Component&#123; handleClick()&#123; console.info(this); &#125; method()&#123; console.info(this); &#125; render()&#123; this.method(); return ( &lt;div&gt; &lt;p onClick=&#123;this.handleClick&#125;&gt;Hello&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; 编译完： 1234567891011121314151617181920212223242526var Todo = function (_Component) &#123; _inherits(Todo, _Component); function Todo() &#123; _classCallCheck(this, Todo); return _possibleConstructorReturn(this, _Component.apply(this, arguments)); &#125; Todo.prototype.handleClick = function handleClick() &#123; console.info(this); &#125;; Todo.prototype.method = function method() &#123; console.info(this); &#125;; Todo.prototype.render = function render() &#123; this.method(); return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement( &apos;div&apos;, null, __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement( &apos;p&apos;, &#123; onClick: this.handleClick &#125;, &apos;Hello&apos; ) ); &#125;; return Todo;&#125;(__WEBPACK_IMPORTED_MODULE_0_react__[&quot;Component&quot;]); this.handleClick被放在{onClick: this.handleClick}中，所以当被调用的时候会被识别为函数调用模式，所以这时的上下文是null（为什么不是window或其他的？？？）]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F08%2F02%2Fwebpack%2F%E8%BF%81%E7%A7%BB%E5%88%B0webpack2%2F</url>
    <content type="text"><![CDATA[迁移到webpack2Webpack is on the verge of having its latest major version released, and it’s expected to drop very soon. However, the main thing holding the release back is documentation, and the code is mostly written. I recently took the time to update our work project from Webpack 1 to 2, and thought I’d document the steps taken for anyone else who wants to make the move. You can also check out the migration guide on the Webpack documentation. Install the webpack2 The first thing to do is install the latest version. Because it’s not a stable release, you have to specify the exact beta version you’d like. At the time of writing it’s 2.1.0-beta.25: npm install --save-dev webpack@2.1.0-beta.25 If you’re using any other Webpack plugins, be aware that they might need updating. For example, the Extract Text Plugin has a v2 in beta also: npm install --save-dev extract-text-webpack-plugin@2.0.0-beta.4 module.loaders =&gt; module.rules This is not a breaking change because module.loaders will continue to be supported, but in the future it will be deprecated in favour of module.rules. This is just an easy renaming step. // before modules: { loaders: {...} } // after modules: { rules: {...} } resolve.modulesDirectories =&gt; resolve.modules Another renaming step, the resolve options have been renamed: // before resolve: { modulesDirectories: [...], } // after resolve: { modules: [...], } No webpack.optimize.OccurenceOrderPlugin It’s now included by default, so there is no need to have this in our config. Configuring loaders At work we’re using postcss and postcss-loader to load our CSS through Webpack. The loader used to expect a top level postcss key in the Webpack config. As of Webpack 2 this is no longer allowed; we can instead define an options key when we configure the loader. This replaces the query option from Webpack 1. Any plugin that looked for top level configuration will have to be swapped to this style. // before, in Webpack top level postcss: { plugins: ... } // after module: { rules: [{ test: /\.scss$/, use: [ { loader: &apos;postcss-loader&apos;, options: { plugins: ... } }, &apos;sass-loader&apos; ] }] } ExtractTextPlugin changes The above change to loader configuration also makes it way easier to configure multiple loaders; previously it would only be possible to pass an array of loaders in string form to some plugins, such as ExtractTextPlugin: // Webpack 1 ExtractTextPlugin.extract( &apos;style-loader&apos;, &apos;css-loader!postcss-loader!sass-loader&apos; ); This quickly got very hard to work with if you had to pass options: // Webpack 1 ExtractTextPlugin.extract( &apos;style-loader&apos;, &apos;css-loader?modules-true!postcss-loader!sass-loader&apos; ); But now Webpack 2 can deal with arrays of objects to configure loaders. We can replace the above with: // Webpack 2 var loaders = [ { loader: &apos;css-loader&apos;, options: { modules: true } }, { loader: &apos;postcss-loader&apos; }, { loader: &apos;sass-loader&apos; } ] Whereas in Webpack 1 we used the key query for configuring loaders, we now use options. ExtractTextPlugin can now take this array, rather than only allowing the string form: // Webpack 2 ExtractTextPlugin.extract({ fallbackLoader: &apos;style-loader&apos;, loader: loaders, }) Stop Babel from compiling ES2015 modules Webpack 1 wasn’t able to parse ES2015 modules, so Babel would convert them into CommonJS. Webpack 2 can parse ES2015 modules, and is able to eliminate dead code based on which modules are used, so it’s recommended that you tell Babel not to convert modules into CommonJS. You can do this by changing your .babelrc: // before &quot;presets&quot;: [&quot;es2015&quot;] // after &quot;presets&quot;: [ [&quot;es2015&quot;, { &quot;modules&quot;: false }] ] We’ve seen a good file size saving by doing this, and hopefully this will continue to improve in the future! Fin Webpack 2 offers better performance, improved bundling and a much nicer experience when configuring it. Given that the code is so stable, despite its beta status, I highly recommend giving it a go on your projects when you can.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F08%2F02%2Fwebpack%2Fwebpack%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[webpack的坑 引用jQuery插件时会报”jQuery is not defined”，解决方法： (1). Prefer unminified CommonJS/AMD over dist Most modules link the dist version in the main field of their package.json. While this is useful for most developers, for webpack it is better to alias the src version because this way webpack is able to optimize dependencies better (e.g. when using the DedupePlugin). // webpack.config.js module.exports = { ... resolve: { alias: { jquery: &quot;jquery/src/jquery&quot; } } }; However, in most cases the dist version works just fine as well. (2). Use the ProvidePlugin to inject implicit globals Most legacy modules rely on the presence of specific globals, like jQuery plugins do on $ or jQuery. In this scenario you can configure webpack, to prepend var $ = require(“jquery”) everytime it encounters the global $ identifier. var webpack = require(&quot;webpack&quot;); ... plugins: [ new webpack.ProvidePlugin({ $: &quot;jquery&quot;, jQuery: &quot;jquery&quot; }) ] (3). Use the imports-loader to configure this Some legacy modules rely on this being the window object. This becomes a problem when the module is executed in a CommonJS context where this equals module.exports. In this case you can override this with the imports-loader. Run npm i imports-loader --save-dev and then module: { loaders: [ { test: /[\/\\]node_modules[\/\\]some-module[\/\\]index\.js$/, loader: &quot;imports?this=&gt;window&quot; } ] } The imports-loader can also be used to manually inject variables of all kinds. But most of the time the ProvidePlugin is more useful when it comes to implicit globals. (4). Use the imports-loader to disable AMD There are modules that support different module styles, like AMD, CommonJS and legacy. However, most of the time they first check for define and then use some quirky code to export properties. In these cases, it could help to force the CommonJS path by setting define = false. module: { loaders: [ { test: /[\/\\]node_modules[\/\\]some-module[\/\\]index\.js$/, loader: &quot;imports?define=&gt;false&quot; } ] } (5). Use the script-loader to globally import scripts If you don’t care about global variables and just want legacy scripts to work, you can also use the script-loader. It executes the module in a global context, just as if you had included them via the &lt;script&gt; tag. (6). Use noParse to include large dists When there is no AMD/CommonJS version of the module and you want to include the dist, you can flag this module as noParse. Then webpack will just include the module without parsing it, which can be used to improve the build time. This means that any feature requiring the AST, like the ProvidePlugin, will not work. module: { noParse: [ /[\/\\]node_modules[\/\\]angular[\/\\]angular\.js$/ ] } 常见的loader { test: /\.js/, loader: &quot;babel-loader&quot;, query: { &quot;presets&quot;: [&quot;es2015&quot;, &apos;stage-0&apos;], plugins: [] }, exclude: /(node_modules)/ }, { test: /\.css$/, //注意：此处不能有autoprefix-loader loader: ExtractText.extract(&apos;style-loader&apos;, &apos;css-loader&apos;) }, { test: /\.(png|gif|jpg|jpeg)$/, loader: &quot;url?name=img/[hash:8].[ext]&quot; }, { test: /\.woff(\?v=\d+\.\d+\.\d+)?$/, loader: &apos;url?name=font/[name].[ext]&amp;limit=10000&amp;minetype=application/font-woff&apos; }, { test: /\.woff2(\?v=\d+\.\d+\.\d+)?$/, loader: &apos;url?name=font/[name].[ext]&amp;limit=10&amp;minetype=application/font-woff&apos; }, { test: /\.ttf(\?v=\d+\.\d+\.\d+)?$/, loader: &apos;url?name=font/[name].[ext]&amp;limit=10&amp;minetype=application/octet-stream&apos; }, { test: /\.eot(\?v=\d+\.\d+\.\d+)?$/, loader: &apos;file&apos; }, { test: /\.svg(\?v=\d+\.\d+\.\d+)?$/, loader: &apos;url?limit=10&amp;minetype=image/svg+xml&apos; } 样式的loader (1)style-loader|css-loader is the way to do it just with css (2)style-loader|css-loader|postcss-loader is the way to post-process css (3)style-loader|css-loader|less-loader is the way to do it if you want to use less (4)style-loader|css-loader|postcss-loader|less-loader is the way to post-process the compiled less (css) ES6引用art-template,报错：Module not found: Error: Cannot resolve module &#39;fs&#39;，解决方法： //webpack.config.js module.exports={ node: { fs: &quot;empty&quot; } }; 参考链接 webpack开发时打包第三方库都比较大，可以通过配置alias指向压缩版本： resolve: { alias: { modernizr$: path.resolve(__dirname, &quot;./.modernizrrc&quot;), bootstrap: path.join(__dirname, &quot;./node_modules/bootstrap/dist/js/bootstrap.min.js&quot;), bootstrapCss: path.join(__dirname, &quot;./node_modules/bootstrap/dist/css/bootstrap.min.css&quot;), fontAwesomeCss: path.join(__dirname, &quot;./node_modules/font-awesome/css/font-awesome.min.css&quot;) } } 引用第三方插件如：ulynlist，需要配置别名： alias: { &apos;ulynlist.table&apos;: path.join(__dirname, &apos;./src/sslib/ulynlist/ulynlist.table.js&apos;), &apos;ulynlist.pager&apos;: path.join(__dirname, &apos;./src/sslib/ulynlist/ulynlist.pager.js&apos;), artTemplate: path.join(__dirname, &apos;./node_modules/art-template&apos;) } import样式文件页面会有闪烁现象，这是可以通过extract-text-webpack-plugin抽取样式文件，就不会有这个问题了 使用ES6 + webpack + angular教程参考链接 合并jquery和第三方插件时，外面是读取不到$和jQuery的，所以我们可以通过expose-loader把jQuery对象导出到全局: You can either do this when you require it: require(&quot;expose?$!jquery&quot;); or you can do this in your config: loaders: [ { test: require.resolve(&apos;jquery&apos;), loader: &apos;expose?jQuery!expose?$&apos; } ] 相同的道理，如果插件里有this，则我们可以通过imports-loader把this当成window处理： { test: require.resolve(&apos;respond.js&apos;), loader: &apos;imports?this=&gt;window&apos; } 使用第三方插件，如果其没有判断commonjs这一层，则我们可以配合exports-loader和imports-loader使用，如eos3还有eos服务，eos3需要导出eos对象，eos服务的js需要导入eos这个对象： import &apos;exports?eos!./lib/eos3/eos3&apos;; //这里define设为false，防止组件判断为AMD模块 import &apos;imports?define=&gt;false,this=&gt;window!./lib/auth/dmService&apos;; webpack-dev-server默认是localhost访问，不能通过ip访问，我们可以配置如下： webpack-dev-server –host 0.0.0.0]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F08%2F02%2Fwebpack%2Fwebpack%E5%AD%A6%E4%B9%A006%E2%80%94%E2%80%94%E6%80%8E%E4%B9%88%E5%86%99loader%2F</url>
    <content type="text"><![CDATA[webpack学习06——怎么写loader一个loader是一个node模块，导出一个函数。这个函数当资源被转换时会执行，这个loader有一个入参：待转换资源名称。可以在loader中通过this访问上下文。 一个同步的loader可以仅仅返回一个值。在其他情况下，loader可以通过this.callback(err, values)返回多个值。 一个loader被期望返回一个或两个值，第一个值返回字符串或buffer类型的javascript代码，第二个返回sourceMap。 在复杂的情况下，当多个loader链接时，仅仅只要最后一个loader返回资源文件，仅仅第一个loader期望返回一个或两个值（javascript代码或buffer）。 Example: module.exports = function(source){ return source; }; // // Identity loader with SourceMap support module.exports = function(source, map) { this.callback(null, source, map); }; 指南（按优先顺序排序，第一个应该得到最高优先级） 只做一个单一的任务loader可以被链接，他们不应该转换为javascript代码，如果他们不需要的话。例如：从模板中通过查询参数渲染html，我会编写一个从源代码中编译的loader，执行他并返回一个包含包含html的字符串，这是不好的。而是我应该编写装载程序在这个用例中的每一个任务，并将它们全部应用（流水线）： jade-loader: Convert template to a module that exports a function. apply-loader: Takes a function exporting module and returns raw result by applying query parameters. html-loader: Takes HTML and exports a string exporting module. generate modules that are modular加载程序生成模块应尊重相同的设计原则，如正常模块。例子：这是一个糟糕的设计：（不模块化，全局状态，…） require(&quot;any-template-language-loader!./xyz.atl&quot;); var html = anyTemplateLanguage.render(&quot;xyz&quot;); 标志本身缓存如果可能的话大多数装载机是可缓存的，所以他们应该标志本身作为缓存。只要在loader中调用cacheable。 //Cacheable identity loader module.exports = function(source){ this.cacheable(); return source(); }; not keep state between runs and modules一个加载程序应该独立于编译的其他模块（由装载程序发布的这些模块的期望）。一个程序应该独立于以前的编译的模块。 依赖如果loader需要依赖第三方资源（如从系统中读取文件），他们必须要写清楚，此信息用于无效的缓存装载机和编译在观看模式。 // Loader adding a header var path = require(&quot;path&quot;); module.exports = function(source) { this.cacheable(); var callback = this.async(); var headerPath = path.resolve(&quot;header.js&quot;); this.addDependency(headerPath); fs.readFile(headerPath, &quot;utf-8&quot;, function(err, header) { if(err) return callback(err); callback(null, header + &quot;\n&quot; + source); }); }; 解决依赖关系一些语言有自己的解决依赖图式，例如css的@import和url(...)。这些必须被模块系统解决。 有两个方法可以做到： 把他们转换成require； 使用this.resolve解析路径； 例子1：css-loader把依赖转换成require其他样式文件。例子2：less-loader不转换为require，因为因为所有的less文件需要编译一次跟踪变量和混合，因此，less-loader扩展less编译器一个自定义的路径解决方法，该自定义逻辑使用this.resolve解决模块的系统配置文件（走样，自定义模块目录，等）。If the language only accept relative urls (like css: url(file) always means ./file), there is the ~-convention to specify references to modules: url(file) -&gt; require(&quot;./file&quot;) url(~module) -&gt; require(&quot;module&quot;) 抽离公共代码don’t generate much code that is common in every module processed by that loader. Create a (runtime) file in the loader and generate a require to that common code. 不应嵌入绝对路径don’t put absolute paths in to the module code. They break hashing when the root for the project is moved. There is a method stringifyRequest in loader-utils which converts an absolute path to an relative one. Example: var loaderUtils = require(&quot;loader-utils&quot;); return &quot;var runtime = require(&quot; + loaderUtils.stringifyRequest(this, &quot;!&quot; + require.resolve(&quot;module/runtime&quot;)) + &quot;);&quot;; use a library as peerDependencies when they wrap itusing a peerDependency allows the application developer to specify the exact version in package.json if desired. The dependency should be relatively open to allow updating the library without needing to publish a new loader version. &quot;peerDependencies&quot;: { &quot;library&quot;: &quot;^1.3.5&quot; } programmable objects as query-optionthere are situations where your loader requires programmable objects with functions which cannot stringified as query-string. The less-loader, for example, provides the possibility to specify LESS-plugins. In these cases, a loader is allowed to extend webpack’s options-object to retrieve that specific option. In order to avoid name collisions, however, it is important that the option is namespaced under the loader’s camelCased npm-name.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F08%2F02%2Fwebpack%2Fwebpack%E5%AD%A6%E4%B9%A005%E2%80%94%E2%80%94%E9%95%BF%E6%9C%9F%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[webpack学习05——长期缓存有两种级别的添加hash方法： Compute a hash of all chunks and add it. Compute a hash per chunk and add it. 方法一：只有一个hash{ output: { path: path.join(__dirname, &quot;assets&quot;, &quot;[hash]&quot;), publicPath: &quot;assets/[hash]/&quot;, filename: &quot;output.[hash].bundle.js&quot;, chunkFilename: &quot;[id].[hash].bundle.js&quot; } } 方法二：每个块都有一个hashoutput: { chunkFilename: &quot;[chunkhash].bundle.js&quot; } Note that you need to reference the entry chunk with its hash in your HTML. You may want to extract the hash or the filename from the stats. In combination with Hot Code Replacement you must use option 1, but not on the publicPath config option. 从文件名获取状态You probably want to access the final filename of the asset to embed it into your HTML. This information is available in the webpack stats. If you are using the CLI you can run it with –json to get the stats as JSON to stdout. You can add a plugin such as assets-webpack-plugin to your configuration which allows you to access the stats object. Here is an example how to write it into a file: plugins: [ function() { this.plugin(&quot;done&quot;, function(stats) { require(&quot;fs&quot;).writeFileSync( path.join(__dirname, &quot;..&quot;, &quot;stats.json&quot;), JSON.stringify(stats.toJson())); }); } ] The stats JSON contains a useful property assetsByChunkName which is a object containing chunk name as key and filename(s) as value. Note: It’s an array if you are emitting multiple assets per chunk. I. e. a JavaScript file and a SourceMap. The first one is your JavaScript source.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F08%2F02%2Fwebpack%2Fwebpack%E5%AD%A6%E4%B9%A004%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[webpack学习04——压缩优化压缩为了压缩你的脚本（和你的样式，如果你用css-loader的话），webpack支持下面两个途径： --optimize-minimize 或者 new webpack.optimize.UglifyJsPlugin() webpack给你的模块和块赋予了id来区别他们，webpack可以为经常用到的id通过下面途径得到最小id长度： --optimize-occurrence-order resp. new webpack.optimize.OccurrenceOrderPlugin() 去重如果你使用第三方库有相同依赖时，会重复引用相同的文件，webpack可以找到并去重，默认是不开启的，可以使用一下方法开启： --optimize-dedupe resp. new webpack.optimize.DedupePlugin() 块优化限制快的最大大小 –optimize-max-chunks 15 new webpack.optimize.LimitChunkCountPlugin({maxChunks: 15})限制块的最小大小 –optimize-min-chunk-size 10000 new webpack.optimize.MinChunkSizePlugin({minChunkSize: 10000}) Webpack会照顾它通过合并块（它会合并块，有重复的模块）。不会有东西合并到入口块，所以不会影响初始页面加载时间。 单页应用A Single-Page-App is the type of web app webpack is designed and optimized for. You may have split the app into multiple chunks, which are loaded at your router. The entry chunk only contains the router and some libraries, but no content. This works great while your user is navigating through your app, but for initial page load you need 2 round trips: One for the router and one for the current content page. If you use the HTML5 History API to reflect the current content page in the URL, your server can know which content page will be requested by the client code. To save round trips to the server you can include the content chunk in the response: This is possible by just adding it as script tag. The browser will load both chunks parallel. &lt;script src=&quot;entry-chunk.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script src=&quot;3.chunk.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; You can extract the chunk filename from the stats. (stats-webpack-plugin could be used for exports the build stats) 多页应用var CommonsChunkPlugin = require(&quot;webpack/lib/optimize/CommonsChunkPlugin&quot;); module.exports = { entry: { p1: &quot;./page1&quot;, p2: &quot;./page2&quot;, p3: &quot;./page3&quot;, ap1: &quot;./admin/page1&quot;, ap2: &quot;./admin/page2&quot; }, output: { filename: &quot;[name].js&quot; }, plugins: [ new CommonsChunkPlugin(&quot;admin-commons.js&quot;, [&quot;ap1&quot;, &quot;ap2&quot;]), new CommonsChunkPlugin(&quot;commons.js&quot;, [&quot;p1&quot;, &quot;p2&quot;, &quot;admin-commons.js&quot;]) ] }; // &lt;script&gt;s required: // page1.html: commons.js, p1.js // page2.html: commons.js, p2.js // page3.html: p3.js // admin-page1.html: commons.js, admin-commons.js, ap1.js // admin-page2.html: commons.js, admin-commons.js, ap2.js Advanced hint: You can run code inside the commons chunk: var CommonsChunkPlugin = require(&quot;webpack/lib/optimize/CommonsChunkPlugin&quot;); module.exports = { entry: { p1: &quot;./page1&quot;, p2: &quot;./page2&quot;, commons: &quot;./entry-for-the-commons-chunk&quot; }, plugins: [ new CommonsChunkPlugin(&quot;commons&quot;, &quot;commons.js&quot;) ] }; See also multiple-entry-points example and advanced multiple-commons-chunks example.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F08%2F02%2Fwebpack%2Fwebpack%E5%AD%A6%E4%B9%A003%E2%80%94%E2%80%94%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[webpack学习03——样式嵌入样式{ test: /\.css$/, loader: &quot;style-loader!css-loader&quot; } 这种情况下会在页面添加style标签式的样式 抽成样式文件可以使用extract-text-webpack-plugin抽成样式文件。 var ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;); ... loaders: [ // Extract css files { test: /\.css$/, loader: ExtractTextPlugin.extract(&quot;style-loader&quot;, &quot;css-loader&quot;) }, // Optionally extract less files // or any other compile-to-css language { test: /\.less$/, loader: ExtractTextPlugin.extract(&quot;style-loader&quot;, &quot;css-loader!less-loader&quot;) } // You could also use other loaders the same way. I. e. the autoprefixer-loader ], plugins: [ new ExtractTextPlugin(&quot;[name].css&quot;) ] 所有样式文件合并成一个样式文件plugins: [ new ExtractTextPlugin(&quot;style.css&quot;, { allChunks: true }) ] 公共样式和CommonsChunkPlugin一起使用，commons块就会生成commons.css样文件。 plugins: [ new webpack.optimize.CommonsChunkPlugin(&quot;commons&quot;, &quot;commons.js&quot;), new ExtractTextPlugin(&quot;[name].css&quot;) ]]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F08%2F02%2Fwebpack%2Fwebpack%E5%AD%A6%E4%B9%A002%E2%80%94%E2%80%94%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2%2F</url>
    <content type="text"><![CDATA[webpack学习02——代码分割定义一个代码分割点commonjs: require.ensurerequire.ensure(dependencies, callback) example: //require.ensure仅仅加载而不执行模块 require.ensure([&quot;module-a&quot;, &quot;module-b&quot;], function(require) { var a = require(&quot;module-a&quot;); // ... }); AMD: requirerequire(dependencies, callback) example: //AMD的require加载并会执行模块 require([&quot;module-a&quot;, &quot;module-b&quot;], function(a, b) { // ... }); ES6模块webpack1是不支持原生es6模块的，可以通过babal转换 块的内容所有分隔的文件会成为一个块，这个块是由其依赖递归加进去的。 块压缩如果两个块包含同一个模块，他们会被合并成一个。这可能造成块有相同的父级。如果一个模块在一个块的所有父级中是可获取的，这个模块将会在这个块中删除。如果一个块包含另一个块的所有模块，则存储这个块，它实现多个块。 块加载根据配置target目标，将将块加载的运行时逻辑添加到包中。例如：web目标块通过jsonp加载。只有一个块被加载一次，并行请求被合并成一个。运行时检查加载的块是否完成多个块。 块的类型入口块一个入口块包含了请求时加载的模块。如果这个块包含模块0则加载并执行它，如果没有，它等待有请求模块0的块。 正常块一个正常的块不会在运行时加载，它仅仅包含一些模块，这个结构依赖于块加载算法，例如：如果目标是jsonp，则这些模块会包含一个jsonp回调函数，这个块当然还包含它负责的一些块id列表。 初始化块（非入口）一个初始化块是一个正常的块，不同的仅仅是压缩工具视它更重要，因为它计算向初始加载时间（像入口块），这个块类型可以结合CommonsChunkPlugin发生。 分隔app和vendor代码var webpack = require(&quot;webpack&quot;); module.exports = { entry: { app: &quot;./app.js&quot;, vendor: [&quot;jquery&quot;, &quot;underscore&quot;, ...], }, output: { filename: &quot;bundle.js&quot; }, plugins: [ new webpack.optimize.CommonsChunkPlugin(/* chunkName= */&quot;vendor&quot;, /* filename= */&quot;vendor.bundle.js&quot;) ] }; vendor块将会从移除所有在app块中的模块，使得bundle块仅仅包含你的代码而不包含其依赖。 &lt;script src=&quot;vendor.bundle.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; 多入口块加载多入口通过CommonsChukPlugin运行时被移动到公共块，入口文件变成初始化块。只有当初始块可以被加载时，其他入口块才可以被加载。 var webpack = require(&quot;webpack&quot;); module.exports = { entry: { a: &quot;./a&quot;, b: &quot;./b&quot; }, output: { filename: &quot;[name].js&quot; }, plugins: [ new webpack.optimize.CommonsChunkPlugin(&quot;init.js&quot;) ] } &lt;script src=&quot;init.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;b.js&quot;&gt;&lt;/script&gt; 公共块CommonsChunkPlugin可以移动发生在多个入口的模块到一个新的块（公共块），运行时也移动到公共块，这意味着旧的入口块已经变成初始化块。 压缩优化插件 LimitChunkCountPlugin MinChunkSizePlugin AggressiveMergingPlugin 命名块The require.ensure function accepts an additional 3rd parameter. This must be a string. If two split point pass the same string they use the same chunk. require.includerequire.include(request) require.include is a webpack specific function that adds a module to the current chunk, but doesn’t evaluate it (The statement is removed from the bundle). Example: require.ensure([&quot;./file&quot;], function(require) { require(&quot;./file2&quot;); }); // is equal to require.ensure([], function(require) { require.include(&quot;./file&quot;); require(&quot;./file2&quot;); }); require.include can be useful if a module is in multiple child chunks. A require.include in the parent would include the module and the instances of the modules in the child chunks would disappear.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F08%2F02%2Fwebpack%2Fwebpack%E5%AD%A6%E4%B9%A001%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[webpack学习01——简介 webpack是一个模块打包工具， webpack特性： 插件：webpack有大量的插件，大多数的功能是使用这个接口的内部插件，这使得webpack很很大的灵活性; 性能：webpack使用异步I/O和多级缓存机制，使得webpack有更快的速度，而且编辑速度超快； 加载器(loaders)：webpack通过定义loaders预处理文件，这允许你打包任何资源而不仅仅是javascript，你也可以自己写适合自己的加载器; 模块化：webpack支持AMD和CommonJs模块化规范，它能够聪明地分析你的代码，甚至有一个评估引擎来评估简单的表达式，这个允许你支持大多数现存模块化规范 代码分割：webpack允许你把代码分割成不同的块thunk，块是按需加载的，这个可以减少初始加载所发费的时间。 代码压缩：webpack可以压缩你的代码，它当然也支持通过哈希缓存； 开发工具：WebPACK支持调试简单sourceurls和sourcemaps。还可以通过development middleware和development server实现自动刷新功能; 多个目标：webpack的首要目标是web，但是它也支持在WebWorkers、Node.js中使用； 加载器： 转换文件； 加载器可以通过管道被链接，最后一个加载器则返回javascript，其他的加载器则可以返回任意的格式代码； 加载器可以是同步或异步的； 加载器在Node.js环境中运行，所以你可以做任何你想要的事情； 加载器支持查询参数； 加载器可以在配置中绑定到扩展名或正则表达式的监听； 加载器可以被发布到npm上或从npm中安装下来； Normal modules can export a loader in addition to the normal main via package.json loader. 加载器可以访问配置； 插件可以向加载器提供更多的特性和功能； 加载器可以调用额外的任意文件； 。。。 加载器解决方案 加载器类似模块，一个加载器导出一个兼容于Node的javascript函数，一般情况下，你通过npm管理你的加载器，当然你也可以作为文件在你的项目中使用 引用加载器：加载器一般以xxx-loader命名，xxx是其名字，例如：json-loader； 你可以通过全名xxx-loader或者短名xxx来使用加载器； 加载器的命名惯例和优先顺序是由resolveLoader.moduleTemplates配置决定的； 加载器的命名惯例一些情况下是很有用的，特别是在require()里面引用加载器的时候； 加载器的使用情况： 在require()语句内； //使用文件loader.js来转换file.txt文件 require(&apos;./loader!./dir/file.txt&apos;); //使用jade-loader，如果配置文件中已经有绑定到此文件的加载器，他们仍然会运行的 require(&apos;jade!./template.jade&apos;); //由less-loader-&gt;css-loader-&gt;style-loader转换顺序，由于有前缀`!`，所以如果在配置文件中已经 //有绑定到此文件的加载器，他们将不会运行 require(&apos;!style!css!less!bootstrap/less/bootstrap.less&apos;); 在配置文件中配置；（推荐这种方式） { module: { loaders: [ {test: /\.jade$/, loader: &apos;jade&apos;}, {test: /\.css$/, loader: &apos;style!css&apos;}, {test: /\.css$/, loaders: [&apos;style&apos;, &apos;css&apos;]} ] } } 在CLI命令行中配置； webpack --module-bind jade --module-bind &apos;css=style!css&apos; 加载器的查询参数 可以在加载器后面加上?添加多个查询参数，例如：url-loader?mimetype=image/png.大多数的加载器支持正常的格式?key=value&amp;key2=value2和JSON对象格式?{key: &quot;value&quot;, key2: &quot;value2&quot;} 在require()语句中： require(&apos;url-loader?mimetype=image/png!./file.png&apos;); 在配置中： {test: /\.png$/, loader: &apos;url-loader?mimetype=image/png&apos;} 或者 { test: /\.png$/, loader: &apos;url-loader&apos;, query: { mimetype: &apos;image/png&apos; } } 在CLI中： webpack --module-bind &quot;png=url-loader?mimetype=image/png&quot;]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML不同空格的特性和表现研究]]></title>
    <url>%2F2016%2F08%2F02%2Fcss%2FHTML%E4%B8%8D%E5%90%8C%E7%A9%BA%E6%A0%BC%E7%9A%84%E7%89%B9%E6%80%A7%E5%92%8C%E8%A1%A8%E7%8E%B0%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[Unicode编码空格 &amp;nbsp;: 不换行空格,用于不会被浏览器判断为可以在中间打断，比如：There is&amp;nbsp;Space，如果会换行，只会在There和is之间换行，而不会在is和Space之间换行。 跟随字体大小产生相应空白的空格：&amp;ensp;(1/2em)，&amp;emsp;(1em)，&amp;thinsp;(1/6em)，这类就很适合坐表单label的排版了，坑爹，终于找到好的解决方法了]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用css视口单位]]></title>
    <url>%2F2016%2F08%2F02%2Fcss%2F%E4%BD%BF%E7%94%A8css%E8%A7%86%E5%8F%A3%E5%8D%95%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[css提供了许多单位用来规定元素，最熟悉的莫属px、%、pt、em以及最近比较火的rem，还有其他两个vw、vh，它们是相对单位，但是不同于em和rem那样相对于当前元素或相对于根元素，他们是相对于视口，一个视口单位等于1%的视口的宽度（vw）或高度（vh）。 这是很有用的。vw单位可以用于一些有大小的规则（如：font-size、或者一个div的高度），下面是一些使用案例： 使标题固定如果你想让一个标题占满横向屏幕且让他固定在一行，你可以使用vw单位，这实际上是用原生的方法实现了jquery插件FitText的功能，但是相对于使用vw，FitText需要手动管理大小，使用检查工具，是一个快速的方法以确定适当的值。 //html &lt;h1&gt;Always a great fit!&lt;/h1&gt; //css h1{ font-size: 12vw; text-align: center; } Infinite LinesWhilst building the falcon633 WordPress theme (used on this site), I needed to create an angled background that would appear to continue indefinitely. This is achievable by 1) making sure that the angle in the centre stays the same regardless of window size and 2) setting the height to be relative to the viewport width. I used an SVG background for the overall cut-out then set the height based on the width using vw units. 简单的视频包装Let’s say you want to set the proportions of an element, an iframe, to stay at a fixed aspect ratio. You previously might have chosen to create a relative div filling the required space, then set carefully selected padding values with iframe inside absolutely positioned to cling to div on all sides (e.g. the approach demonstrated here). A better solution could be to use the vw and vh units. This way you can set your height and width directly on the element in question, whilst also keeping the ‘layers-for-layout’ number down. 全屏的hero Image你要做的只是在body和html上运用height: 100%，然后在元素上简单地使用width: 100vw; heihgt: 100vh就行了。 div居中一个常见的需求是要让一个div在页面中居中，这时候只要设置margin: 20vh 20vw; width: 60vw, height: 60vh; padding: 10vh 10vw即可。 浏览器支持情况IE9及以上]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular2遇到的问题.md]]></title>
    <url>%2F2016%2F08%2F02%2Fangular2%2F%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在组件时moduleId: module.id时，报Cannot find name &#39;module&#39;? 解决方法： You need to install node ambientDependencies. Typings.json &quot;ambientDependencies&quot;: { &quot;node&quot;: &quot;github:DefinitelyTyped/DefinitelyTyped/node/node.d.ts#138ad74b9e8e6c08af7633964962835add4c91e2&quot; } Another way can use typings manager to install node definition file globally: typings install dt~node --global --save Then your typings.json file will look like this: &quot;globalDependencies&quot;: { &quot;node&quot;: &quot;registry:dt/node#6.0.0+20160608110640&quot; } If you use Typescript 2^ just use the following command: npm install @types/node --global --save Or install it within the project: npm install @types/node --save and then add a reference to it from your bootstrap: ///&lt;reference path=&quot;../../node_modules/@types/node/index.d.ts&quot; /&gt; 而后出现Url.match is not a function? 解决方法： 报错：Property &#39;find&#39; does not exist on type &#39;Hero[]&#39;.? 解决方法：在typings.json中配置如下代码 { &quot;globalDependencies&quot;: { &quot;core-js&quot;: &quot;registry:dt/core-js#0.0.0+20160725163759&quot;, &quot;jasmine&quot;: &quot;registry:dt/jasmine#2.2.0+20160621224255&quot;, &quot;node&quot;: &quot;registry:dt/node#6.0.0+20160909174046&quot; } }]]></content>
      <tags>
        <tag>angular</tag>
      </tags>
  </entry>
</search>