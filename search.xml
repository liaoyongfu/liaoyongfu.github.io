<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[css-transforms-3d]]></title>
    <url>%2F2018%2F06%2F21%2Fcss%2Fcss-transforms-3d%2F</url>
    <content type="text"><![CDATA[浏览器支持情况2D TransformsChrome Safari Firefox Opera IE Android iOSAny 3.1+ 3.5+ 10.5+ 9+ 4.1+ At least 4 3D TransformsChrome Safari Firefox Opera IE Android iOS10+ 4+ 12+ none 10+ 4.1+ 5+ 2D Transforms scale(): 缩放元素，包括：font-size,padding,height,width。它还提供scaleX和scaleY速记函数。 skewX() and skewY(): 元素向左或者向右倾斜，这个没有skew函数。 translate(): 位移元素 rotate(): 顺时针翻转元素 matrix(): 矩阵，这个函数可能不是专门用手写的，但将所有转换合并为一个。 perspective(): 不会影响元素本身，但会影响后代元素3D变换的变换，从而使它们都具有一致的深度透视图。 3D TransformsPerspective要激活3D空间，元素必须要有透视。可以有两种方式使用：使用transform: perspective(600px)或者perspective: 600px。 perspective决定3D效果的强度的值。把它看作从观察者到物体的距离。值越大，距离越远，视觉效果越不强烈。perspective: 2000px;产生微妙的3D效果，就像我们通过双筒望远镜从远处观看物体一样。perspective: 100px;产生巨大的3D效果，就像一只看到巨大物体的小昆虫。 可以在子元素上使用perspective或者父级元素，但是，当用于多个元素时，转换后的元素不会按预期排列。如果跨不同位置的元素使用相同的变换，则每个元素都有自己的视点。为了解决这个问题，请使用perspective父元素的属性，以便每个孩子可以共享相同的3D空间。参考https://desandro.github.io/3dtransforms/examples/perspective-02-children.html See the Pen css-3d-transforms-perspective by liaoyf (@liaoyf) on CodePen. 默认情况下，3D空间的视点位于中心。你可以用perspective-origin属性来改变视点的位置。 1perspective-origin: 25% 75%; 3D Transform functions rotateX( angle ) rotateY( angle ) rotateZ( angle ) translateZ( tz ) scaleZ( sz ) 还有几个速记变换函数需要所有三个维度的值： translate3d( tx, ty, tz ) scale3d( sx, sy, sz ) rotate3d( rx, ry, rz, angle ) 这些foo3d()转换函数还具有在Safari中触发硬件加速的好处，如果您正在编写适用于iOS或Safari的生产准备CSS，请务必使用这些foo3d()函数以获得最佳的渲染性能。]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native版本0.55搭建]]></title>
    <url>%2F2018%2F06%2F20%2Freact-native%2Freact-native%E7%89%88%E6%9C%AC0.55%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[react-native开发流程create-react-native-app方式使用此方式无需安装编译器、xcode或者Android Studio等。 1234npm install -g create-react-nateive-appcreate-react-native-app AwesomeProjectcd AwesomeProjectnpm start 启动后，控制台会输出一个二维码，接下来，你需要使用手机安装Expo应用程序，然后使用二维码登录即可在访问，如果你修改代码，应该也会热更新。 用native code构建在IOS上，需要安装一些必须软件： 123456brew install nodebrew install watchmannpm install -g react-native-clireact-native init AwesomeProjectcd AwesomeProjectreact-native run-ios 使用Command + R刷新。 注意：Xcode版本必须要&gt;=8 react-native run-ios报错报错如下： 1234567891011An error was encountered processing the command (domain=NSPOSIXErrorDomain, code=2):Failed to install the requested applicationAn application bundle was not found at the provided path.Provide a valid path to the desired application bundle.Print: Entry, &quot;:CFBundleIdentifier&quot;, Does Not Exist/development/misc/react/AwesomeProject/node_modules/promise/lib/done.js:10 throw err; ^Error: Command failed: /usr/libexec/PlistBuddy -c Print:CFBundleIdentifier build/Build/Products/Debug-iphonesimulator/AwesomeProject.app/Info.plistPrint: Entry, &quot;:CFBundleIdentifier&quot;, Does Not Exist 泪崩。。。试用遍了网上大多数的解决方法均不行，浪费了好多宝贵时间，后来发现是xcode的版本问题，0.55版本要求xcode的版本要&gt;= 8。 所以要更新xcode版本即可解决，记得更新完后重新react-native init项目。 结合antd-mobile使用安装antd-mobile-rn: 1yarn add antd-mobile-rn 使用： 1234567891011import React, &#123; Component &#125; from &apos;react&apos;;import &#123; AppRegistry &#125; from &apos;react-native&apos;;import Button from &apos;antd-mobile-rn/lib/button&apos;;class HelloWorldApp extends Component &#123; render() &#123; return &lt;Button&gt;Start&lt;/Button&gt;; &#125;&#125;AppRegistry.registerComponent(&apos;HelloWorldApp&apos;, () =&gt; HelloWorldApp); 更多坑请点击查看 调用原生模块123import &#123; NativeModules &#125; from &apos;react-native&apos;;var CalendarManager = NativeModules.CalendarManager;CalendarManager.addEvent(&apos;Birthday Party&apos;, &apos;4 Privet Drive, Surrey&apos;); 详细介绍请点击查看 开发后安装问题在真机上测试iOS应用需要一台Mac电脑，同时还需要注册一个Apple ID。如果你需要把应用发布到App Store，那么你还需要去苹果开发者网站购买一个开发者账户（在自己手机上测试则不用） 在真机上访问开发服务器（packager）你可以在真机上访问开发服务器以快速测试和迭代。首先需要确保设备已使用usb连接至电脑，同时和电脑处在同一wifi网络内，然后在Xcode中选择你的设备作为编译目标（左上角运行按钮的右边），然后点击运行按钮即可。如果你需要在真机上启用调试功能，则需要打开RCTWebSocketExecutor.m文件，然后将其中的”localhost”改为你的电脑的IP地址，最后启用开发者菜单中的”Debug JS Remotely”选项。 开发步骤： 使用xcode打开项目 使用USB链接手机，并和电脑处于统一wifi信号下 选择右上角为你的手机，然后点击三角形运行 输入电脑登录密码，之后软件会安装在你的手机上 由于软件不被信任，所以要在通用-&gt;设备管理-&gt;点击信任 提示：摇晃设备就可以打开开发者菜单。 发布应用当你使用React Native做好一个漂亮的应用之后，一定跃跃欲试想要在App Store上发布了吧。发布的流程和其他iOS原生应用完全一样，除了以下一些注意事项。在App Store上发布应用首先需要编译一个“发布版本”(release)的应用。具体的做法是在Xcode中选择Product -&gt; Scheme -&gt; Edit Scheme (cmd + &lt;)，然后选择Run选项卡，将Build Configuration设置为release。 Release版本的应用会自动禁用开发者菜单，同时也会将js文件和静态图片打包压缩后内置到包中，这样应用可以在本地读取而无需访问开发服务器（同时这样一来你也无法再调试，需要调试请将Buiid Configuration再改为debug）。由于发布版本已经内置了js文件，因而也无法再通过开发服务器来实时更新。面向用户的热更新，请使用专门的热更新服务。编译完成后，你就可以打包提交到TestFlight进行内测，或是提交到App Store进行发布。相关流程较为复杂，不熟悉原生应用发布流程的同学请自行搜索学习。 App Transport SecurityApp Transport Security(简称ATS)是iOS 9中新增的一项安全特性。在默认设置下，只允许HTTPS的请求，而所有HTTP的请求都会被拒绝。详情可参考这篇帖子。 使用react-native开发的可行性根据Airbnb提供： 优点 跨平台 （只有 0.2% 的平台特定代码） 统一的设计语言，同时还能为不同平台提供不同设计 React 的 scale 很好，生命周期比原生简单，声明式很好 迭代速度快（主要是 hot reloading 很快） 大量基础设施的投入值得（网络、国际化、复杂动画、设备信息、用户信息等等都是通过一个桥把原生 api 暴露给 RN 的。） 同时他们在这里也指出：他们并不相信在一个已有 app 上集成 RN 是一件简单事儿，必须要大量且持续地投入基础设施才行（说好的「满意的地方」呢） 性能 （尽管大家都担心但是其实基本没有问题） 不过首次渲染比较慢，导致不适合用作启动屏、deeplink，也增加了可交互时间（TTI），另外掉帧不好 debug（说好的「满意的地方」呢） Redux（好用，虽然废话太多） 背后是原生，一些曾经不确定能不能做的功能（Shared element transitions、动画库 Lottie、网络层、核心基础设施）发现都能做 静态分析（eslint，prettier，一些性能检测） 动画 JS/React 的开源生态 Flexbox （via Yoga） 有时候可以加上 Web 跨三端 缺点 RN 太不成熟 需要 fork RN JS 不行 （JS 没有类型不 scale，flow 不好用，TS 不好集成到 babel 和 metro） 不好重构（JS 没有类型无法静态分析，重构引起的错误不能在编译时被捕捉到） 咳，用我 FB 的新编译到 JS 语言大 ReasonML 啊……静态强类型 + 类型推断 + 自带不可变数据结构 + JS 友好语法 + 官方 React 支持，绝对 scale（咳扯远了 JSCore 在 iOS / Android 上不一致 （Android 上是 RN 自己 bundle 的），很难 debug 这种坑 RN 的开源库质量不行（因为太少人能精通所有平台了） 做功能时要回去搞基础设施（因为有的基础设施可能还没暴露给 RN） 奔溃监控（业内没方案，只能自己搞） 原生桥太难写，另外 JS 的类型太难预料（和强类型语言 interop 时）-RN 运行时的初始化太慢 首次渲染时间慢（需要从 主线程 -&gt; JS -&gt; Yoga -&gt; 主线程） 应用体积 64 位 （因为 RN 不兼容的 issue 导致他们至今没法在 android 发布 64 位应用） 手势（iOS 和 Android 的手势不好统一，虽然他们搞了 react-native-gesture-handler） 长列表 升级 RN 有的时候非常麻烦 Accessibility （RN 的有 bug，又要 fork） 稀奇古怪的奔溃 安卓上的应用实例序列化问题 个人观点如果不需要开发那种非常复杂的功能，react-native社区提供的第三方库基本能满足开发需求；]]></content>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jest测试工具学习（入门篇）]]></title>
    <url>%2F2018%2F06%2F19%2Fjavascript%2Fjest%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[使用匹配器普通匹配器 toBe：测试值的方法是看是否精确匹配，相反的匹配器是.not.toBe; toEqual: 递归检查对象或数组的每个字段 Truthiness toBeNull toBeUndefined toBeDefine toBeTruthy: 匹配任何 if 语句为真 toBeFalsy: 匹配任何 if 语句为假 数字大多数的比较数字有等价的匹配器。 1234567test(&apos;two plus two&apos;, () =&gt; &#123; const value = 2 + 2; expect(value).toBeGreaterThan(3); expect(value).toBeGreaterOrEqual(3.5); expect(value).toBeLessThan(5); expect(value).toBeLessOrEqual(4.5);&#125;); 对于比较浮点数相等，使用 toBeCloseTo 而不是 toEqual，因为你不希望测试取决于一个小小的舍入误差。 12345test(&apos;两个浮点数字相加&apos;, () =&gt; &#123; const value = 0.1 + 0.2; //expect(value).toBe(0.3); 这句会报错，因为浮点数有舍入误差 expect(value).toBeCloseTo(0.3); // 这句可以运行&#125;); 字符串您可以检查对具有toMatch正则表达式的字符串︰ 1234567test(&apos;there is no I in team&apos;, () =&gt; &#123; expect(&apos;team&apos;).not.toMatch(/I/);&#125;);test(&apos;but there is a &quot;stop&quot; in Christoph&apos;, () =&gt; &#123; expect(&apos;Christoph&apos;).toMatch(/stop/);&#125;); 数组你可以检查数组是否包含特定子项使用 toContain︰ 1234567891011const shoppingList = [ &apos;diapers&apos;, &apos;kleenex&apos;, &apos;trash bags&apos;, &apos;paper towels&apos;, &apos;beer&apos;,];test(&apos;购物清单（shopping list）里面有啤酒（beer）&apos;, () =&gt; &#123; expect(shoppingList).toContain(&apos;beer&apos;);&#125;); 例外如果你想要测试的特定函数抛出一个错误，在它调用时，使用 toThrow。 123456789101112function compileAndroidCode() &#123; throw new ConfigError(&apos;you are using the wrong JDK&apos;);&#125;test(&apos;compiling android goes as expected&apos;, () =&gt; &#123; expect(compileAndroidCode).toThrow(); expect(compileAndroidCode).toThrow(ConfigError); // You can also use the exact error message or a regexp expect(compileAndroidCode).toThrow(&apos;you are using the wrong JDK&apos;); expect(compileAndroidCode).toThrow(/JDK/);&#125;); 测试异步代码回调使用单个参数调用 done，而不是将测试放在一个空参数的函数。 Jest会等done回调函数执行结束后，结束测试。 12345678test(&apos;the data is peanut butter&apos;, done =&gt; &#123; function callback(data) &#123; expect(data).toBe(&apos;peanut butter&apos;); done(); &#125; fetchData(callback);&#125;); 如果 done()永远不会调用，这个测试将失败，这也是你所希望发生的。 Promises123456test(&apos;the data is peanut butter&apos;, () =&gt; &#123; expect.assertions(1); return fetchData().then(data =&gt; &#123; expect(data).toBe(&apos;peanut butter&apos;); &#125;);&#125;); 一定要返回 Promise - 如果你省略 return 语句，您的测试将在 fetchData 完成之前完成。如果你想要 Promise 被拒绝，使用 .catch 方法。 请确保添加 expect.assertions 来验证一定数量的断言被调用。 否则一个fulfilled态的 Promise 不会让测试失败︰ 1234test(&apos;the fetch fails with an error&apos;, () =&gt; &#123; expect.assertions(1); return fetchData().catch(e =&gt; expect(e).toMatch(&apos;error&apos;));&#125;); .resolves / .rejects您还可以使用 .resolves 匹配器在您期望的声明，Jest 会等待这一 Promise 来解决。如果 Promise 被拒绝，则测试将自动失败。 1234test(&apos;the data is peanut butter&apos;, () =&gt; &#123; expect.assertions(1); return expect(fetchData()).resolves.toBe(&apos;peanut butter&apos;);&#125;); 如果你想要 Promise 被拒绝，使用 .catch 方法。 它参照工程 .resolves 匹配器。 如果 Promise 被拒绝，则测试将自动失败。 1234test(&apos;the fetch fails with an error&apos;, () =&gt; &#123; expect.assertions(1); return expect(fetchData()).rejects.toMatch(&apos;error&apos;);&#125;); Async/Await123456789test(&apos;the data is peanut butter&apos;, async () =&gt; &#123; expect.assertions(1); await expect(fetchData()).resolves.toBe(&apos;peanut butter&apos;);&#125;);test(&apos;the fetch fails with an error&apos;, async () =&gt; &#123; expect.assertions(1); await expect(fetchData()).rejects.toMatch(&apos;error&apos;);&#125;); 钩子函数为多次测试重复设置123456789101112131415beforeEach(() =&gt; &#123; return initializeCityDatabase();&#125;);afterEach(() =&gt; &#123; return clearCityDatabase();&#125;);test(&apos;city database has Vienna&apos;, () =&gt; &#123; expect(isCity(&apos;Vienna&apos;)).toBeTruthy();&#125;);test(&apos;city database has San Juan&apos;, () =&gt; &#123; expect(isCity(&apos;San Juan&apos;)).toBeTruthy();&#125;); 一次性设置在某些情况下，你只需要在文件的开头做一次设置。 当这种设置是异步行为时，可能非常恼人，你不太可能一行就解决它。 Jest 提供 beforeAll 和 afterAll 处理这种情况。 123456789101112131415beforeAll(() =&gt; &#123; return initializeCityDatabase();&#125;);afterAll(() =&gt; &#123; return clearCityDatabase();&#125;);test(&apos;city database has Vienna&apos;, () =&gt; &#123; expect(isCity(&apos;Vienna&apos;)).toBeTruthy();&#125;);test(&apos;city database has San Juan&apos;, () =&gt; &#123; expect(isCity(&apos;San Juan&apos;)).toBeTruthy();&#125;); 作用域默认情况下，before 和 after 的块可以应用到文件中的每个测试。 此外可以通过 describe 块来将测试分组。 当 before 和 after 的块在 describe 块内部时，则其只适用于该 describe 块内的测试。 比如说，我们不仅有一个城市的数据库，还有一个食品数据库。我们可以为不同的测试做不同的设置 123456789101112131415161718192021222324252627// Applies to all tests in this filebeforeEach(() =&gt; &#123; return initializeCityDatabase();&#125;);test(&apos;city database has Vienna&apos;, () =&gt; &#123; expect(isCity(&apos;Vienna&apos;)).toBeTruthy();&#125;);test(&apos;city database has San Juan&apos;, () =&gt; &#123; expect(isCity(&apos;San Juan&apos;)).toBeTruthy();&#125;);describe(&apos;matching cities to foods&apos;, () =&gt; &#123; // Applies only to tests in this describe block beforeEach(() =&gt; &#123; return initializeFoodDatabase(); &#125;); test(&apos;Vienna &lt;3 sausage&apos;, () =&gt; &#123; expect(isValidCityFoodPair(&apos;Vienna&apos;, &apos;Wiener Schnitzel&apos;)).toBe(true); &#125;); test(&apos;San Juan &lt;3 plantains&apos;, () =&gt; &#123; expect(isValidCityFoodPair(&apos;San Juan&apos;, &apos;Mofongo&apos;)).toBe(true); &#125;);&#125;); 12345678910111213141516171819202122232425beforeAll(() =&gt; console.log(&apos;1 - beforeAll&apos;));afterAll(() =&gt; console.log(&apos;1 - afterAll&apos;));beforeEach(() =&gt; console.log(&apos;1 - beforeEach&apos;));afterEach(() =&gt; console.log(&apos;1 - afterEach&apos;));test(&apos;&apos;, () =&gt; console.log(&apos;1 - test&apos;));describe(&apos;Scoped / Nested block&apos;, () =&gt; &#123; beforeAll(() =&gt; console.log(&apos;2 - beforeAll&apos;)); afterAll(() =&gt; console.log(&apos;2 - afterAll&apos;)); beforeEach(() =&gt; console.log(&apos;2 - beforeEach&apos;)); afterEach(() =&gt; console.log(&apos;2 - afterEach&apos;)); test(&apos;&apos;, () =&gt; console.log(&apos;2 - test&apos;));&#125;);// 1 - beforeAll// 1 - beforeEach// 1 - test// 1 - afterEach// 2 - beforeAll// 1 - beforeEach// 2 - beforeEach// 2 - test// 2 - afterEach// 1 - afterEach// 2 - afterAll// 1 - afterAll desribe和test块的执行顺序Jest在执行任何实际测试之前执行所有描述处理程序的测试文件。这是在before*和after*的处理程序中进行设置和拆卸的另一个原因，而不是在描述块中,一旦描述块完成，默认情况下，Jest将按照它们在收集阶段遇到的顺序依次运行所有测试，等待每个测试完成并在继续之前进行整理。 12345678910111213141516171819202122232425262728293031323334353637describe(&apos;outer&apos;, () =&gt; &#123; console.log(&apos;describe outer-a&apos;); describe(&apos;describe inner 1&apos;, () =&gt; &#123; console.log(&apos;describe inner 1&apos;); test(&apos;test 1&apos;, () =&gt; &#123; console.log(&apos;test for describe inner 1&apos;); expect(true).toEqual(true); &#125;); &#125;); console.log(&apos;describe outer-b&apos;); test(&apos;test 1&apos;, () =&gt; &#123; console.log(&apos;test for describe outer&apos;); expect(true).toEqual(true); &#125;); describe(&apos;describe inner 2&apos;, () =&gt; &#123; console.log(&apos;describe inner 2&apos;); test(&apos;test for describe inner 2&apos;, () =&gt; &#123; console.log(&apos;test for describe inner 2&apos;); expect(false).toEqual(false); &#125;); &#125;); console.log(&apos;describe outer-c&apos;);&#125;);// describe outer-a// describe inner 1// describe outer-b// describe inner 2// describe outer-c// test for describe inner 1// test for describe outer// test for describe inner 2 通用建议如果测试失败，第一件要检查的事就是，当仅运行这条测试时，它是否仍然失败。 在 Jest 中很容易地只运行一个测试 — — 只需暂时将 test 命令更改为 test.only: 1234567test.only(&apos;this will be the only test that runs&apos;, () =&gt; &#123; expect(true).toBe(false);&#125;);test(&apos;this test will not run&apos;, () =&gt; &#123; expect(&apos;A&apos;).toBe(&apos;A&apos;);&#125;); 如果你有一个测试，当它作为一个更大的用例中的一部分时，经常运行失败，但是当你单独运行它时，并不会失败，所以最好考虑其他测试对这个测试的影响。 通常可以通过修改 beforeEach 来清除一些共享的状态来修复这种问题。 如果不确定某些共享状态是否被修改，还可以尝试在 beforeEach 中 log 数据来 debug。 Mock函数1234567891011121314const mockCallback = jest.fn();forEach([0, 1], mockCallback);// The mock function is called twiceexpect(mockCallback.mock.calls.length).toBe(2);// The first argument of the first call to the function was 0expect(mockCallback.mock.calls[0][0]).toBe(0);// The first argument of the second call to the function was 1expect(mockCallback.mock.calls[1][0]).toBe(1);// The return value of the first call to the function was 42expect(mockCallback.mock.results[0].value).toBe(42); .mock 属性123456789const myMock = jest.fn();const a = new myMock();const b = &#123;&#125;;const bound = myMock.bind(b);bound();console.log(myMock.mock.instances);// &gt; [ &lt;a&gt;, &lt;b&gt; ] 123456789101112131415161718// The function was called exactly onceexpect(someMockFunction.mock.calls.length).toBe(1);// The first arg of the first call to the function was &apos;first arg&apos;expect(someMockFunction.mock.calls[0][0]).toBe(&apos;first arg&apos;);// The second arg of the first call to the function was &apos;second arg&apos;expect(someMockFunction.mock.calls[0][1]).toBe(&apos;second arg&apos;);// The return value of the first call to the function was &apos;return value&apos;expect(someMockFunction.mock.results[0].value).toBe(&apos;return value&apos;);// This function was instantiated exactly twiceexpect(someMockFunction.mock.instances.length).toBe(2);// The object returned by the first instantiation of this function// had a `name` property whose value was set to &apos;test&apos;expect(someMockFunction.mock.instances[0].name).toEqual(&apos;test&apos;); Mock 的返回值1234567891011const myMock = jest.fn();console.log(myMock());// &gt; undefinedmyMock .mockReturnValueOnce(10) .mockReturnValueOnce(&apos;x&apos;) .mockReturnValue(true);console.log(myMock(), myMock(), myMock(), myMock());// &gt; 10, &apos;x&apos;, true, true 123456789101112const filterTestFn = jest.fn();// Make the mock return `true` for the first call,// and `false` for the second callfilterTestFn.mockReturnValueOnce(true).mockReturnValueOnce(false);const result = [11, 12].filter(filterTestFn);console.log(result);// &gt; [11]console.log(filterTestFn.mock.calls);// &gt; [ [11], [12] ] Mocking Modules123456789101112131415// users.test.jsimport axios from &apos;axios&apos;;import Users from &apos;./users&apos;;jest.mock(&apos;axios&apos;);test(&apos;should fetch users&apos;, () =&gt; &#123; const resp = &#123;data: [&#123;name: &apos;Bob&apos;&#125;]&#125;; axios.get.mockResolvedValue(resp); // or you could use the following depending on your use case: // axios.get.mockImplementation(() =&gt; Promise.resolve(resp)) return Users.all().then(users =&gt; expect(users).toEqual(resp.data));&#125;); Mock 实现1234567const myMockFn = jest.fn(cb =&gt; cb(null, true));myMockFn((err, val) =&gt; console.log(val));// &gt; truemyMockFn((err, val) =&gt; console.log(val));// &gt; true 12345678910111213// foo.jsmodule.exports = function() &#123; // some implementation;&#125;;// test.jsjest.mock(&apos;../foo&apos;); // this happens automatically with automockingconst foo = require(&apos;../foo&apos;);// foo is a mock functionfoo.mockImplementation(() =&gt; 42);foo();// &gt; 42 12345678910const myMockFn = jest .fn() .mockImplementationOnce(cb =&gt; cb(null, true)) .mockImplementationOnce(cb =&gt; cb(null, false));myMockFn((err, val) =&gt; console.log(val));// &gt; truemyMockFn((err, val) =&gt; console.log(val));// &gt; false 1234567onst myMockFn = jest .fn(() =&gt; &apos;default&apos;) .mockImplementationOnce(() =&gt; &apos;first call&apos;) .mockImplementationOnce(() =&gt; &apos;second call&apos;);console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());// &gt; &apos;first call&apos;, &apos;second call&apos;, &apos;default&apos;, &apos;default&apos; 1234567891011const myObj = &#123; myMethod: jest.fn().mockReturnThis(),&#125;;// is the same asconst otherObj = &#123; myMethod: jest.fn(function() &#123; return this; &#125;),&#125;; Mock 名称12345const myMockFn = jest .fn() .mockReturnValue(&apos;default&apos;) .mockImplementation(scalar =&gt; 42 + scalar) .mockName(&apos;add42&apos;); 自定义匹配器1234567891011// 这个 mock 函数至少被调用一次expect(mockFunc).toBeCalled();// 这个 mock 函数至少被调用一次，而且传入了特定参数expect(mockFunc).toBeCalledWith(arg1, arg2);// 这个 mock 函数的最后一次调用传入了特定参数expect(mockFunc).lastCalledWith(arg1, arg2);// 所有的 mock 的调用和名称都被写入了快照expect(mockFunc).toMatchSnapshot(); 1234567891011121314151617181920// 这个 mock 函数至少被调用一次expect(mockFunc.mock.calls.length).toBeGreaterThan(0);// 这个 mock 函数至少被调用一次，而且传入了特定参数expect(mockFunc.mock.calls).toContain([arg1, arg2]);// 这个 mock 函数的最后一次调用传入了特定参数expect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1]).toEqual([ arg1, arg2,]);// 这个 mock 函数的最后一次调用的第一个参数是`42`// （注意这个断言的规范是没有语法糖的）expect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1][0]).toBe(42);// 快照会检查 mock 函数被调用了同样的次数，// 同样的顺序，和同样的参数 它还会在名称上断言。expect(mockFunc.mock.calls).toEqual([[arg1, arg2]]);expect(mockFunc.mock.getMockName()).toBe(&apos;a mock name&apos;); Jest平台工具您可以挑选Jest的特定功能，并将它们作为独立软件包使用。以下是可用软件包的列表： jest-changed-files用于识别git / hg存储库中已修改文件的工具。出口两个功能： getChangedFilesForRoots 返回一个承诺，解析为更改后的文件和回购对象。findRepos 返回一个承诺，解析为包含在指定路径中的一组存储库。 123456const &#123;getChangedFilesForRoots&#125; = require(&apos;jest-changed-files&apos;);// 打印出当前目录最后修改过的一组文件getChangedFilesForRoots([&apos;./&apos;], &#123; lastCommit: true,&#125;).then(result =&gt; console.log(result.changedFiles)); jest-diff用于可视化数据更改的工具 123456789const diff = require(&apos;jest-diff&apos;);const a = &#123;a: &#123;b: &#123;c: 5&#125;&#125;&#125;;const b = &#123;a: &#123;b: &#123;c: 6&#125;&#125;&#125;;const result = diff(a, b);// print diffconsole.log(result); jest-docblock12345678910111213141516const &#123;parseWithComments&#125; = require(&apos;jest-docblock&apos;);const code = `/** * This is a sample * * @flow */ console.log(&apos;Hello World!&apos;);`;const parsed = parseWithComments(code);// prints an object with two attributes: comments and pragmas.console.log(parsed); jest-get-type123456789101112const getType = require(&apos;jest-get-type&apos;);const array = [1, 2, 3];const nullValue = null;const undefinedValue = undefined;// prints &apos;array&apos;console.log(getType(array));// prints &apos;null&apos;console.log(getType(nullValue));// prints &apos;undefined&apos;console.log(getType(undefinedValue)); jest-validate用于验证用户提交的配置的工具 123456789101112const &#123;validate&#125; = require(&apos;jest-validate&apos;);const configByUser = &#123; transform: &apos;&lt;rootDir&gt;/node_modules/my-custom-transform&apos;,&#125;;const result = validate(configByUser, &#123; comment: &apos; Documentation: http://custom-docs.com&apos;, exampleConfig: &#123;transform: &apos;&lt;rootDir&gt;/node_modules/babel-jest&apos;&#125;,&#125;);console.log(result); jest-worker用于任务并行化的模块 1234567// heavy-task.jsmodule.exports = &#123; myHeavyTask: args =&gt; &#123; // long running CPU intensive task. &#125;,&#125;; 123456789101112131415// main.jsasync function main() &#123; const worker = new Worker(require.resolve(&apos;./heavy-task.js&apos;)); // run 2 tasks in parallel with different arguments const results = await Promise.all([ worker.myHeavyTask(&#123;foo: &apos;bar&apos;&#125;), worker.myHeavyTask(&#123;bar: &apos;foo&apos;&#125;), ]); console.log(results);&#125;main(); pretty-format导出一个将任何JavaScript值转换为可读的字符串的函数。支持所有内置的JavaScript类型，并允许通过用户定义的插件扩展特定于应用程序的类型。 123456789const prettyFormat = require(&apos;pretty-format&apos;);const val = &#123;object: &#123;&#125;&#125;;val.circularReference = val;val[Symbol(&apos;foo&apos;)] = &apos;foo&apos;;val.map = new Map([[&apos;prop&apos;, &apos;value&apos;]]);val.array = [-0, Infinity, NaN];console.log(prettyFormat(val));]]></content>
      <tags>
        <tag>jest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端下开发问题总结]]></title>
    <url>%2F2018%2F06%2F14%2Fjavascript%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%8B%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[ios端微信浏览器会给input框加上自带的样式，例如圆角和内阴影。是因为-webkit-appearance这个属性的影响解决：给input添加以下样式 12345input &#123; appearance: none; -webkit-appearance: none; /* safari */ -moz-appearance: none;&#125;]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack学习——loose模式]]></title>
    <url>%2F2018%2F05%2F29%2Fwebpack%2Fwebpack%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94loose%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简要介绍Babel6的loose mode。 简介babel的松散模式将ES6代码转换为不遵循ES6语义的ES5代码。 两种模式babel中的许多插件有两种模式： 正常模式尽可能地遵循ECMAScript 6的语义。 松散模式产生更简单的ES5代码。 通常，建议不要使用松散模式。优点和缺点是： 优点：生成的代码可能更快，并且与旧引擎兼容。它也趋于更清洁，更“ES5式”。 缺点：当你从ES6转换到ES6时，你可能会遇到问题。这很少是值得冒险的。 打开松散模式es2015-loose预设是标准ES6预设的松散版本。它提供了一个概观如何打开某个插件的松散模式： 12345678module.exports = &#123; plugins: [ ··· [require(&quot;babel-plugin-transform-es2015-classes&quot;), &#123;loose: true&#125;], require(&quot;babel-plugin-transform-es2015-object-super&quot;), ··· ]&#125;; 示例：松散模式和正常模式输出区别让我们看看模式的区别如何影响到以下代码的输出： 123456789class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return `($&#123;this.x&#125;, $&#123;this.y&#125;)`; &#125;&#125; 正常模式正常模式下，类的属性通过Object.defineProperty： 123456789101112131415161718192021222324252627282930313233343536373839404142&quot;use strict&quot;;var _createClass = (function () &#123; function defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (&quot;value&quot; in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); // (A) &#125; &#125; return function (Constructor, protoProps, staticProps) &#123; if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; &#125;;&#125;)();function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(&quot;Cannot call a class as a function&quot;); &#125;&#125;var Point = (function () &#123; function Point(x, y) &#123; _classCallCheck(this, Point); this.x = x; this.y = y; &#125; _createClass(Point, [&#123; key: &quot;toString&quot;, value: function toString() &#123; return &quot;(&quot; + this.x + &quot;, &quot; + this.y + &quot;)&quot;; &#125; &#125;]); return Point;&#125;)(); 松散模式松散模式下，通过正常添加方法方式，更像es5写法： 123456789101112131415161718&quot;use strict&quot;;function _classCallCheck(instance, Constructor) &#123; ··· &#125;var Point = (function () &#123; function Point(x, y) &#123; _classCallCheck(this, Point); this.x = x; this.y = y; &#125; Point.prototype.toString = function toString() &#123; // (A) return &quot;(&quot; + this.x + &quot;, &quot; + this.y + &quot;)&quot;; &#125;; return Point;&#125;)();]]></content>
      <tags>
        <tag>webpack</tag>
        <tag>babel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识学习概要]]></title>
    <url>%2F2018%2F05%2F02%2Fjavascript%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%A6%81%2F</url>
    <content type="text"><![CDATA[了解web浏览器 浏览器如何渲染页面 浏览器的工作原理 What is a browser engine? What forces layout / reflow What Every Frontend Developer Should Know About Webpage Rendering]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逃离async、await地狱]]></title>
    <url>%2F2018%2F04%2F16%2Fjavascript%2F%E9%80%83%E7%A6%BBasync%E3%80%81await%E5%9C%B0%E7%8B%B1%2F</url>
    <content type="text"><![CDATA[async/await已经帮助我们逃离了回调函数的地狱，但是我们又陷入了async/await地狱。 什么是async/await地狱当我们处理异步函数调用时，我们习惯在调用前添加一个await,然后一行接着一行，以同步的形式书写，但是这样就造成了我们的语句并不依赖前一个，你必须等待前一个语句的完成。 一个async/await地狱的示例考虑你要订购pizza和drink，代码如下： 123456789(async () =&gt; &#123; const pizzaData = await getPizzaData() // async call const drinkData = await getDrinkData() // async call const chosenPizza = choosePizza() // sync call const chosenDrink = chooseDrink() // sync call await addPizzaToCart(chosenPizza) // async call await addDrinkToCart(chosenDrink) // async call orderItems() // async call&#125;)() 表面上看代码没有问题，但是这却不是有好的实践，因为它没有实现并发。 解释我们已经使用IIFE包装我们的代码，订购流程如下： 获取pizza列表. 获取drink列表. 从pizza列表中选择商品. 从drink中选择商品. 添加pizza到购物车. 添加drink到购物车. 下单. 那么，这样有什么问题吗？就像之前说的，每句都是依赖上一句，这里并没有并发：pizza和drink应该可以并发运行的，pizza相关的工作和drink相关的工作可以并行进行，但涉及相关工作的各个步骤需要按顺序（逐个）进行。 另一个糟糕的示例此JavaScript代码段将获取购物车中的商品并发出订购请求。 1234567async function orderItems() &#123; const items = await getCartItems() // async call const noOfItems = items.length for(var i = 0; i &lt; noOfItems; i++) &#123; await sendRequest(items[i]) // async call &#125;&#125; 每次循环我们都必须等待sendRequest的完成，但是，我们并不需要等待。我们希望尽快发送所有请求，然后我们可以等待所有请求完成。 怎么逃离async/await地狱第一步：查找依赖于其他语句执行的语句在我们的第一个例子中，我们选择了一个披萨和一杯饮料。我们的结论是，在选择比萨饼之前，我们需要有比萨饼的名单。在将比萨加入购物车之前，我们需要选择比萨饼。所以我们可以说这三个步骤取决于对方。在完成前一件事之前我们不能做一件事。但如果我们更广泛地来看，我们发现选择比萨不依赖于选择饮料，所以我们可以并行选择它们。这是机器可以做得比我们更好的一件事。因此我们发现了一些依赖于其他语句执行的语句，有些则没有。 第二步：把相关的操作独立进行封装我们可以封装selectPizza()和selectDrink()。 第三步：并发运行相关操作函数然后我们利用事件循环同时运行这些异步非阻塞函数。这样做的两种常见模式是return Promise和Promise.all方法。 让我们来解决示例中的问题12345678910111213141516171819202122232425async function selectPizza() &#123; const pizzaData = await getPizzaData() // async call const chosenPizza = choosePizza() // sync call await addPizzaToCart(chosenPizza) // async call&#125;async function selectDrink() &#123; const drinkData = await getDrinkData() // async call const chosenDrink = chooseDrink() // sync call await addDrinkToCart(chosenDrink) // async call&#125;(async () =&gt; &#123; const pizzaPromise = selectPizza() const drinkPromise = selectDrink() await pizzaPromise await drinkPromise orderItems() // async call&#125;)()// Although I prefer it this way (async () =&gt; &#123; Promise.all([selectPizza(), selectDrink()]).then(orderItems) // async call&#125;)() 针对循环中sendRequest的等待问题，我们使用Promise.all来并发请求： 12345678910async function orderItems() &#123; const items = await getCartItems() // async call const noOfItems = items.length const promises = [] for(var i = 0; i &lt; noOfItems; i++) &#123; const orderPromise = sendRequest(items[i]) // async call promises.push(orderPromise) // sync call &#125; await Promise.all(promises) // async call&#125;]]></content>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript设计模式-面向对象]]></title>
    <url>%2F2018%2F04%2F06%2Fjavascript%2Fjavascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[灵活的javascript假如有如下的校验表单方法： 1234567891011function checkName()&#123;&#125;function checkEmail()&#123;&#125;function checkPassword()&#123;&#125; 这样的声明可能会和别人写的冲突，我们可以把他们放在一个变量中，这样可以减少覆盖或者被覆盖的风险： 12345var CheckObject = &#123; checkName: function()&#123;...&#125;, checkEmail: function()&#123;...&#125;, checkPassword: function()&#123;...&#125;&#125;; 使用对象实现： 1234var CheckObject = function()&#123;&#125;;CheckObject.prototype.checkName = function()&#123;&#125;;CheckObject.prototype.checkEmail = function()&#123;&#125;;CheckObject.prototype.checkPassword = function()&#123;&#125;; 这样别人就可以基于你的对象进行扩展。这样创建实例对象时，创建出来的对象所拥有的方法就只有一个。 1234var a = new CheckObject();a.checkName();a.checkEmail();a.checkPassword(); 这样有个问题，每次都要书写a对象，我们可以通过每个方法后面返回对象来支持链式调用： 12345678var CheckObject = function()&#123;&#125;;CheckObject.prototype = &#123; checkName: function()&#123; ... return this; &#125;, ...&#125;; 这样就可以通过a.checkName().checkEmail().checkPassword()来链式调用。 写的都是看到的创建一个类12345678var Book = function(id, bookname, price)&#123; this.id = id; this.bookname = bookname; this.price = price;&#125;;Book.protype.display = function()&#123;&#125;; 使用类： 12var book = new Book(10, &apos;javascript begin&apos;, 120);book.display(); constructorconstructor是一个属性，当创建一个函数或者对象时都会为其创建一个原型对象prototype，在prototype对象中又会创建一个constructor属性，那么constructor属性指向的就是拥有整个原型对象的函数或对象。 私有属性、私有方法、特权方法等12345678910111213141516171819202122232425262728var Book = function(id, name, price)&#123; // 私有属性 var num = 1; // 私有方法 function checkId()&#123; &#125; // 特权方法 this.getName = function()&#123;&#125;; this.setName = function()&#123;&#125;; // 对象公有属性 this.id = id; this.name = name; this.price = price; // 对象公有方法 this.copy = function()&#123;&#125;; // 构造器 this.sertName(name); this.setPrice(price);&#125;;// 静态公有属性Book.isChinese = true;Book.prototype = &#123; // 公有属性 isJSBook: true&#125;; 有时候我们经常将类的静态变量通过闭包来实现： 1234567891011121314151617var Book = (function()&#123; var bookNum = 0; function checkBook(name)&#123; &#125; return function(newId, newName, newPrice)&#123; var name, price; function checkID(id)&#123;&#125; bookNum++; if(bookNum &gt; 100)&#123; throw new Error(&apos;Error&apos;); &#125; &#125;&#125;)(); 闭包是有权访问另一个函数作用域中变量的函数，即在一个函数内部创建另一个函数。 继承12345678910111213141516function SuperClass()&#123; this.superValue = true;&#125;SuperClass.prototype.getSuperValue = function()&#123; return this.superValue;&#125;;function SubClass()&#123; this.subValue = false;&#125;// 继承父类SubClass.prototype = new SuperClass();SubClass.prototype.getSubValue = function()&#123; return this.subValue;&#125;; 另一种方式： 123456789101112function SuperClass()&#123; this.superValue = true;&#125;SuperClass.prototype.getSuperValue = function()&#123; return this.superValue;&#125;;function SubClass()&#123; // 继承父类 SuperClass.call(this); this.subValue = false;&#125; 组合继承: 123456789101112131415function SuperClass()&#123; this.superValue = true;&#125;SuperClass.prototype.getSuperValue = function()&#123; return this.superValue;&#125;;function SubClass()&#123; // 继承父类 SuperClass.call(this); this.subValue = false;&#125;SubClass.prototype = new SuperClass(); 洁净的继承者-原型式继承： 123456function inheritObject(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react学习总结]]></title>
    <url>%2F2018%2F04%2F02%2Freact%2Freact%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[协调（Reconciliation）当你使用React，在单一时间点你可以考虑render()函数作为创建React元素的树。在下一次状态或属性更新，render()函数将返回一个不同的React元素的树。React需要算出如何高效更新UI以匹配最新的树。 有一些解决将一棵树转换为另一棵树的最小操作数算法问题的通用方案。然而，树中元素个数为n，最先进的算法的时间复杂度为O(n 3 ) 。 若我们在React中使用，展示1000个元素则需要进行10亿次的比较。这操作太过昂贵，相反，React基于两点假设，实现了一个启发的O(n)算法： 两个不同类型的元素将产生不同的树。 通过渲染器附带key属性，开发者可以示意哪些子元素可能是稳定的。 实践中，上述假设适用于大部分应用场景。 对比算法当对比两棵树时，React首先比较两个根节点。根节点的type不同，其行为也不同。 不同类型的元素每当根元素有不同类型，React将卸载旧树并重新构建新树。 当树被卸载，旧的DOM节点将被销毁。组件实例会调用componentWillUnmount()。当构建一棵新树，新的DOM节点被插入到DOM中。组件实例将依次调用componentWillMount()和componentDidMount()。任何与旧树有关的状态都将丢弃。 这个根节点下所有的组件都将会被卸载，同时他们的状态将被销毁。例如，以下节点对比之后： 1234567&lt;div&gt; &lt;Counter /&gt;&lt;/div&gt;&lt;span&gt; &lt;Counter /&gt;&lt;/span&gt; 这将会销毁旧的Counter并重装新的Counter。 相同类型的DOM元素当比较两个相同类型的React DOM元素时，React则会观察二者的属性，保持相同的底层DOM节点，并仅更新变化的属性。例如： 123&lt;div className=&quot;before&quot; title=&quot;stuff&quot; /&gt;&lt;div className=&quot;after&quot; title=&quot;stuff&quot; /&gt; 通过比较两个元素，React知道仅更改底层DOM元素的className。 当更新style时，React同样知道仅更新变更的属性。例如： 123&lt;div style=&#123;&#123;color: &apos;red&apos;, fontWeight: &apos;bold&apos;&#125;&#125; /&gt;&lt;div style=&#123;&#123;color: &apos;green&apos;, fontWeight: &apos;bold&apos;&#125;&#125; /&gt; 当在调整两个元素时，React知道仅改变color样式而不是fontWeight。 在处理完DOM元素后，React递归其子元素。 相同类型的组件元素当组件更新时，实例仍保持一致，以让状态能够在渲染之间保留。React通过更新底层组件实例的props来产生新元素，并在底层实例上依次调用componentWillReceiveProps()和componentWillUpdate()方法。 接下来，render()方法被调用，同时对比算法会递归处理之前的结果和新的结果。 权衡牢记协调算法的实现细节非常重要。React可能会在每次操作时渲染整个应用；而结果仍是相同的。为保证大多数场景效率能更快，我们通常提炼启发式的算法。 在目前实现中，可以表明一个事实，即子树在其兄弟节点中移动，但你无法告知其移动到哪。该算法会重渲整个子树。 由于React依赖于该启发式算法，若其背后的假设没得到满足，则其性能将会受到影响： 算法无法尝试匹配不同组件类型的子元素。若你发现两个输出非常相似的组件类型交替出现，你可能希望使其成为相同类型。实践中，我们并非发现这是一个问题。 Keys应该是稳定的，可预测的，且唯一的。不稳定的key（类似由Math.random()生成的）将使得大量组件实例和DOM节点进行不必要的重建，使得性能下降并丢失子组件的状态。 Context（React v16.3.0）创建生产者1React.createContext(/* some value */) 消费者123&lt;Consumer&gt; &#123;value =&gt; /* render something based on the context value */&#125;&lt;/Consumer&gt; 示例123456789101112131415161718192021222324252627282930// Create a theme context, defaulting to light themeconst ThemeContext = React.createContext(&apos;light&apos;);function ThemedButton(props) &#123; // The ThemedButton receives the theme from context return ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; &lt;Button &#123;...props&#125; theme=&#123;theme&#125; /&gt;&#125; &lt;/ThemeContext.Consumer&gt; );&#125;// An intermediate componentfunction Toolbar(props) &#123; return ( &lt;div&gt; &lt;ThemedButton /&gt; &lt;/div&gt; );&#125;class App extends React.Component &#123; render() &#123; return ( &lt;ThemeContext.Provider value=&quot;dark&quot;&gt; &lt;Toolbar /&gt; &lt;/ThemeContext.Provider&gt; ); &#125;&#125; 在生命周期中，可以通过this.props访问： 12345678910111213141516171819202122232425class Button extends React.Component &#123; componentDidMount() &#123; // ThemeContext value is this.props.theme &#125; componentDidUpdate(prevProps, prevState) &#123; // Previous ThemeContext value is prevProps.theme // New ThemeContext value is this.props.theme &#125; render() &#123; const &#123;theme, children&#125; = this.props; return ( &lt;button className=&#123;theme ? &apos;dark&apos; : &apos;light&apos;&#125;&gt; &#123;children&#125; &lt;/button&gt; ); &#125;&#125;export default props =&gt; ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; &lt;Button &#123;...props&#125; theme=&#123;theme&#125; /&gt;&#125; &lt;/ThemeContext.Consumer&gt;); 创建消费HOC组件123456789101112131415const ThemeContext = React.createContext(&apos;light&apos;);// This function takes a component...export function withTheme(Component) &#123; // ...and returns another component... return function ThemedComponent(props) &#123; // ... and renders the wrapped component with the context theme! // Notice that we pass through any additional props as well return ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; &lt;Component &#123;...props&#125; theme=&#123;theme&#125; /&gt;&#125; &lt;/ThemeContext.Consumer&gt; ); &#125;;&#125; 现在就可以简单用了： 12345function Button(&#123;theme, ...rest&#125;) &#123; return &lt;button className=&#123;theme&#125; &#123;...rest&#125; /&gt;;&#125;const ThemedButton = withTheme(Button); ref引用到被包装组件（React v16.3.0）v16.3.0引入React.createRef和React.forwardRef新语法： 123456789101112131415161718// fancy-button.jsclass FancyButton extends React.Component &#123; focus() &#123; // ... &#125; // ...&#125;// Use context to pass the current &quot;theme&quot; to FancyButton.// Use forwardRef to pass refs to FancyButton as well.export default React.forwardRef((props, ref) =&gt; ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; ( &lt;FancyButton &#123;...props&#125; theme=&#123;theme&#125; ref=&#123;ref&#125; /&gt; )&#125; &lt;/ThemeContext.Consumer&gt;)); 1234567891011// app.jsimport FancyButton from &apos;./fancy-button&apos;;const ref = React.createRef();// Our ref will point to the FancyButton component,// And not the ThemeContext.Consumer that wraps it.// This means we can call FancyButton methods like ref.current.focus()&lt;FancyButton ref=&#123;ref&#125; onClick=&#123;handleClick&#125;&gt; Click me!&lt;/FancyButton&gt;; FragmentsFragments 看起来像空的JSX 标签： 123456789render() &#123; return ( &lt;&gt; &lt;ChildA /&gt; &lt;ChildB /&gt; &lt;ChildC /&gt; &lt;/&gt; );&#125; 另一种使用片段的方式是使用React.Fragment组件，React.Fragment组件可以在React对象上使用。这可能是必要的，如果你的工具还不支持JSX片段。注意在React中，&lt;&gt;&lt;/&gt;是&lt;React.Fragment/&gt;的语法糖。 12345678910class Columns extends React.Component &#123; render() &#123; return ( &lt;React.Fragment&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/React.Fragment&gt; ); &#125;&#125; &lt;&gt;&lt;/&gt; 语法不能接受键值或属性。 如果你需要一个带key的片段，你可以直接使用&lt;React.Fragment /&gt;。一个使用场景是映射一个集合为一个片段数组—例如：创建一个描述列表： 12345678910111213function Glossary(props) &#123; return ( &lt;dl&gt; &#123;props.items.map(item =&gt; ( // 没有`key`，将会触发一个key警告 &lt;React.Fragment key=&#123;item.id&#125;&gt; &lt;dt&gt;&#123;item.term&#125;&lt;/dt&gt; &lt;dd&gt;&#123;item.description&#125;&lt;/dd&gt; &lt;/React.Fragment&gt; ))&#125; &lt;/dl&gt; );&#125; PortalsPortals 提供了一种很好的将子节点渲染到父组件以外的DOM 节点的方式： 1ReactDOM.createPortal(child, container) 第一个参数（child）是任何可渲染的React子元素，例如一个元素，字符串或碎片。第二个参数（container）则是一个DOM元素。 对于portal的一个典型用例是当父组件有overflow: hidden或z-index样式，但你需要子组件能够在视觉上“跳出（break out）”其容器。例如，对话框、hovercards以及提示框。 尽管portal可以被放置在DOM树的任何地方，但在其他方面其行为和普通的React子节点行为一致。如上下文特性依然能够如之前一样正确地工作，无论其子节点是否是portal，由于portal仍存在于React树中，而不用考虑其在DOM树中的位置。 这包含事件冒泡。一个从portal内部会触发的事件会一直冒泡至包含React树的祖先。假设如下HTML结构： 123456&lt;html&gt; &lt;body&gt; &lt;div id=&quot;app-root&quot;&gt;&lt;/div&gt; &lt;div id=&quot;modal-root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 在#app-root里的Parent组件能够捕获到未被捕获的从兄弟节点#modal-root冒泡上来的事件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// These two containers are siblings in the DOMconst appRoot = document.getElementById(&apos;app-root&apos;);const modalRoot = document.getElementById(&apos;modal-root&apos;);class Modal extends React.Component &#123; constructor(props) &#123; super(props); this.el = document.createElement(&apos;div&apos;); &#125; componentDidMount() &#123; modalRoot.appendChild(this.el); &#125; componentWillUnmount() &#123; modalRoot.removeChild(this.el); &#125; render() &#123; return ReactDOM.createPortal( this.props.children, this.el, ); &#125;&#125;class Parent extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;clicks: 0&#125;; this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; // This will fire when the button in Child is clicked, // updating Parent&apos;s state, even though button // is not direct descendant in the DOM. this.setState(prevState =&gt; (&#123; clicks: prevState.clicks + 1 &#125;)); &#125; render() &#123; return ( &lt;div onClick=&#123;this.handleClick&#125;&gt; &lt;p&gt;Number of clicks: &#123;this.state.clicks&#125;&lt;/p&gt; &lt;p&gt; Open up the browser DevTools to observe that the button is not a child of the div with the onClick handler. &lt;/p&gt; &lt;Modal&gt; &lt;Child /&gt; &lt;/Modal&gt; &lt;/div&gt; ); &#125;&#125;function Child() &#123; // The click event on this button will bubble up to parent, // because there is no &apos;onClick&apos; attribute defined return ( &lt;div className=&quot;modal&quot;&gt; &lt;button&gt;Click&lt;/button&gt; &lt;/div&gt; );&#125;ReactDOM.render(&lt;Parent /&gt;, appRoot); 在父组件里捕获一个来自portal的事件冒泡能够在开发时具有不完全依赖于portal的更为灵活的抽象。例如，若你在渲染一个组件，父组件能够捕获其事件而无论其是否采用portal实现。 Error Boundaries错误边界是用于捕获其子组件树JavaScript异常，记录错误并展示一个回退的UI的React组件，而不是整个组件树的异常。错误组件在渲染期间，生命周期方法内，以及整个组件树构造函数内捕获错误。 如果一个类组件定义了一个名为componentDidCatch(error, info):的新方法，则其成为一个错误边界： 123456789101112131415161718192021class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; hasError: false &#125;; &#125; componentDidCatch(error, info) &#123; // Display fallback UI this.setState(&#123; hasError: true &#125;); // You can also log the error to an error reporting service logErrorToMyService(error, info); &#125; render() &#123; if (this.state.hasError) &#123; // You can render any custom fallback UI return &lt;h1&gt;Something went wrong.&lt;/h1&gt;; &#125; return this.props.children; &#125;&#125; 而后你可以像一个普通的组件一样使用： 123&lt;ErrorBoundary&gt; &lt;MyWidget /&gt;&lt;/ErrorBoundary&gt; componentDidCatch()方法机制类似于JavaScript catch {}，但是针对组件。仅有类组件可以成为错误边界。实际上，大多数时间你仅想要定义一个错误边界组件并在你的整个应用中使用。 注意错误边界仅可以捕获其子组件的错误。错误边界无法捕获其自身的错误。如果一个错误边界无法渲染错误信息，则错误会向上冒泡至最接近的错误边界。这也类似于JavaScript中catch {}的工作机制。 componentDidCatch 参数error 是被抛出的错误。 info是一个含有componentStack属性的对象。这一属性包含了错误期间关于组件的堆栈信息。 12345678910111213//...componentDidCatch(error, info) &#123; /* Example stack information: in ComponentThatThrows (created by App) in ErrorBoundary (created by App) in div (created by App) in App */ logComponentStackToMyService(info.componentStack);&#125;//... Test Utilities未来计划 16.3：介绍别名为不安全的生命周期，UNSAFE_componentWillMount，UNSAFE_componentWillReceiveProps，和UNSAFE_componentWillUpdate。（旧的生命周期名称和新的别名都可以在此版本中使用。） 未来的16.x版本：启用弃用警告componentWillMount，componentWillReceiveProps和componentWillUpdate。（旧的生命周期名称和新的别名都可以在此版本中使用，但旧名称会记录DEV模式警告。） 17.0：删除componentWillMount，componentWillReceiveProps和componentWillUpdate。（从现在开始，只有新的“UNSAFE_”生命周期名称将起作用。）]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[create-react-app读后感]]></title>
    <url>%2F2018%2F03%2F30%2Freact%2Fcreate-react-app%E8%AF%BB%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[项目github地址https://github.com/facebook/create-react-app 一些概念npx npm 5.2+多出一个工具，npx 会帮你执行依赖包里的二进制文件。 旨在提高从npm注册表使用软件包的体验 ，npm使得它非常容易地安装和管理托管在注册表上的依赖项，npx使得使用CLI工具和其他托管在注册表。 举例来说，之前我们可能会写这样的命令： 12npm i -D webpack./node_modules/.bin/webpack -v 有了 npx，你只需要这样： 12npm i -D webpacknpx webpack -v 也就是说 npx 会自动查找当前依赖包中的可执行文件，如果找不到，就会去 PATH 里找。如果依然找不到，就会帮你安装！ npx 甚至支持运行远程仓库的可执行文件，如: 12345678910$ npx github:piuccio/cowsay hellonpx: 1 安装成功，用时 1.663 秒 _______&lt; hello &gt; ------- \ ^__^ \ (oo)\_______ (__)\ )\/\ ||----w | || || 再比如 npx http-server 可以一句话帮你开启一个静态服务器！（第一次运行会稍微慢一些）： 1234567$ npx http-servernpx: 23 安装成功，用时 48.633 秒Starting up http-server, serving ./Available on: http://127.0.0.1:8080 http://192.168.5.14:8080Hit CTRL-C to stop the server react-scripts bin目录下主要文件： 123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env node&quot;use strict&quot;;const crypto = require(&apos;crypto&apos;);const path = require(&apos;path&apos;);// 跨平台调用系统命令const spawn = require(&apos;cross-spawn&apos;);const script = process.argv[2];const args = process.argv.slice(3);switch (script) &#123; case &apos;build&apos;: case &apos;start&apos;: case &apos;upload&apos;: case &apos;test&apos;: &#123; const result = spawn.sync( &apos;node&apos;, [require.resolve(path.join(&apos;../scripts&apos;, script))].concat(args), &#123; stdio: &apos;inherit&apos; &#125; ); process.exit(result.status); break; &#125; case &apos;pwhash&apos;: &#123; let stdin = process.openStdin(); let data = &quot;&quot;; stdin.on(&apos;data&apos;, function(chunk) &#123; data += chunk; &#125;); stdin.on(&apos;end&apos;, function() &#123; let hash = crypto.createHash(&apos;md5&apos;).update(data).digest(&apos;hex&apos;); console.log(hash); &#125;); break; &#125; default: console.log(`Unknown script &quot;$&#123;script&#125;&quot;.`); break;&#125; !/usr/bin/node是告诉操作系统执行这个脚本的时候，调用/usr/bin下的node解释器； !/usr/bin/env node这种用法是为了防止操作系统用户没有将node装在默认的/usr/bin路径里。当系统看到这一行的时候，首先会到env设置里查找node的安装路径，再调用对应路径下的解释器程序完成操作。 创建项目 node版本必须&gt;=6 运行创建命令： 1npx create-react-app my-app 目录结构大致如下： 1234567891011121314151617my-app├── README.md├── node_modules├── package.json├── .gitignore├── public│ └── favicon.ico│ └── index.html│ └── manifest.json└── src └── App.css └── App.js └── App.test.js └── index.css └── index.js └── logo.svg └── registerServiceWorker.js 运行npm start或yarn start开启项目运行npm test或yarn test测试运行npm run build或者yarn run build打包项目 未完待续…]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React遇到的坑.md]]></title>
    <url>%2F2018%2F03%2F27%2Freact%2FReact%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[webpack编译后，代码中判断子组件名称功能失效。因为压缩后函数名称混淆，所以不能通过typeof child.type === &#39;function&#39; &amp;&amp; child.type.name === &#39;FormControl&#39;，而是应该通过child.type === FormControl 当input框输入值时输入框自动被失去了焦点，原因是在render函数里又用了render。 参考网址：https://stackoverflow.com/questions/25385578/nested-react-input-element-loses-focus-on-typing input值不会随着属性改变而改变123&lt;Parent&gt; &lt;Child inputVal=&#123;this.state.inputVal&#125;/&gt;&lt;/Parent&gt; 当Child组件的value为null后input的值不会更改。所以一般要判断是否存在null值： 1&lt;FormControl value=&#123;this.props.inputVal || &apos;&apos;&#125;/&gt; UglifyJs编辑后有些arguments无效升级uglifyjs-webpack-plugin和uglify-js： 12&quot;uglify-js&quot;: &quot;^3.1.6&quot;,&quot;uglifyjs-webpack-plugin&quot;: &quot;^1.0.1&quot;, 上传文件不能上传同一张图片在上传完成后，设置$(&#39;input&#39;).val(&#39;&#39;)即可。 react中ref传递给页面组件时失效比如如下代码： 12let Component = require(`./$&#123;item.componentName&#125;/index.js`).default;return &lt;Component ref=&#123;c =&gt; this.a = c&#125; key=&#123;i&#125; &#123;...props&#125; updateCzsj=&#123;updateCzsj&#125;/&gt;; 这时，使用ref是无效的，这时因为包装了withRouter导致ref失效，应该使用wrappedComponentRef，获取时使用如下语句获取： 1this.a 在react组件中引入样式文件导致echarts宽度计算失败的bug比如下面： 12345678&lt;div className=&quot;box&quot;&gt; &lt;div className=&quot;left&quot;&gt; &lt;Echart ...&gt; &lt;/div&gt; &lt;div className=&quot;right&quot;&gt; &lt;Echart ...&gt; &lt;/div&gt;&lt;/div&gt; box中的left、right各占50%（样式写在样式文件内），这时候渲染echarts的时候，因为样式文件还未生效，所以Echarts读取的left和right宽度是100%的。 这个是为什么呢？ 修改react子组件123456789101112131415161718192021222324return React.Children.map(this.props.children, child =&gt; &#123; if (!child) return child; if (typeof child.type === &apos;function&apos; &amp;&amp; child.type.name === &apos;Tr&apos;) &#123; // 这边要修改children属性而不是直接返回它的children return React.cloneElement(child, &#123; children: ( React.Children.map(child.props.children, subChild =&gt; &#123; if (typeof subChild.type === &apos;function&apos; &amp;&amp; subChild.type.name === &apos;Label&apos;) &#123; return React.cloneElement(subChild, &#123; required: true &#125;) &#125; else if (typeof subChild.type === &apos;function&apos; &amp;&amp; subChild.type.name === &apos;Content&apos;) &#123; return React.cloneElement(subChild, &#123; children: [...subChild.props.children, textTip], validationState: validationState &#125;) &#125; &#125;) ) &#125;) &#125; else &#123; return child; &#125;&#125;);]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git笔记]]></title>
    <url>%2F2018%2F02%2F08%2Fgit%2Fgit%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[版本回退1git log [--pretty=oneline] 先查看下日志，查看各个版本的mode id 1git reset --hard (HEAD^ | modeid) HEAD表示当前版本，HEAD^表示上一个版本，HEAD~100表示之前的100个版本，也可以通过modeid来回退版本 1git reflog 记录你的每一次命令，在我们回退后又后悔的时候可以查看各个版本的mode id 工作区和暂存区 工作区：文件目录 暂存区：.git文件里的，git还为我们创建了第一个分支master，以及一个指向master的指针叫HEAD 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 管理修改git add . ：他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。 git add -u ：他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区。add -u 不会提交新文件（untracked file）。（git add –update的缩写） git add -A ：是上面两个功能的合集（git add –all的缩写） 撤销修改1git checkout -- file 丢弃工作区的修改，让这个文件回到最近一次git commit或git add时的状态；命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令 1git reset HEAD file 丢弃暂存区的修改（unstage）重新放回工作区 当然如果已经提交到版本库或远程仓库，你就要回退版本了。 删除文件1git rm file 从版本库中删除文件，然后git commit就好了 1git checkout -- file 从版本库中获取误删的文件 远程仓库创建github远程仓库 创建SSH Key： 在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 生成两个文件：id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人 登陆GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容使用命令git push -u origin master第一次推送master分支的所有内容；此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 分支 创建一个名为dev的分支： 1234git checkout -b dev//相当于以下两句git branch devgit checkout dev git checkout命令加上-b参数表示创建并切换，然后用git branch查看当前分支： 1234$ git branch* dev master *号表示当前分支。 合并dev分支到master： 12345$ git merge devUpdating d17efd8..fec145aFast-forward readme.txt | 1 + 1 file changed, 1 insertion(+) git merge命令用于合并指定分支到当前分支，注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。 当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。 合并完成后，就可以放心地删除dev分支了： 12$ git branch -d devDeleted branch dev (was fec145a). 如果有冲突，需要手动解决。可以用git log命令查看分支的合并情况： 12345678$ git log --graph --pretty=oneline --abbrev-commit* 59bc1cb conflict fixed|\| * 75a857c AND simple* | 400b400 &amp; simple|/* fec145a branch test... 分支管理策略使用Fast Forward模式下，删除分支后，分支信息也会没掉： 1$ git merge --no-ff -m &quot;merge with no-ff&quot; dev 禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息，–no-ff参数，表示禁用Fast forward 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 Bug分支 stash功能： 可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作： 123$ git stashSaved working directory and index state WIP on dev: 6224937 add mergeHEAD is now at 6224937 add merge 现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。 首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支： 12345$ git checkout masterSwitched to branch &apos;master&apos;Your branch is ahead of &apos;origin/master&apos; by 6 commits.$ git checkout -b issue-101Switched to a new branch &apos;issue-101&apos; 修复完成后，切换到master分支，并完成合并，最后删除issue-101分支： 123456789$ git checkout masterSwitched to branch &apos;master&apos;Your branch is ahead of &apos;origin/master&apos; by 2 commits.$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101Merge made by the &apos;recursive&apos; strategy. readme.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)$ git branch -d issue-101Deleted branch issue-101 (was cc17032). 现在，是时候接着回到dev分支干活了！ 12345$ git checkout devSwitched to branch &apos;dev&apos;$ git status# On branch devnothing to commit (working directory clean) 工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看： 12$ git stash liststash@&#123;0&#125;: WIP on dev: 6224937 add merge 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了： 1$ git stash pop 再用git stash list查看，就看不到任何stash内容了，可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令： 1$ git stash apply stash@&#123;0&#125; Feature分支删除分支： 1git branch -d feature-vulcan 强制删除分支： 1git branch -D feature-vulcan 多人协作远程仓库的默认名称为origin； 抓取远程分支： 1git checkout -b dev origin/dev 设置本地dev分支和远程origin/dev分支的链接： 1git branch --set-upstream dev origin/dev 提交到远程分支： 1git push origin dev 如果远程分支和你冲突了，要先git pull把最新的提交从origin/dev中拿下来，本地解决冲突后，再推送 因此，多人协作的工作模式通常是这样： 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 标签管理标签是版本库的一个快照。 创建标签打标签：git tag &lt;name&gt;； 查看所有标签：git tag； 在某个提交版本打标签：git tag &lt;name&gt; &lt;commitId&gt;； 查看标签：git show v0.9； 创建带有说明的标签，用-a指定标签名，-m指定说明文字：git tag -a v0.1 -m &quot;version 0.1 released&quot; 3432525； 通过-s用私钥签名一个标签：git tag -s v0.2 -m &quot;signed version 0.2 released&quot; fec145a； 操作标签命令git push origin &lt;tagname&gt;可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d &lt;tagname&gt;可以删除一个本地标签； 命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。 移除文件的版本控制如果你想把一个文件从版本控制中移除，并且保留本地的文件，首先需要把这个文件加入到gitignore文件中。然后执行以下命令就可以了。 1git rm file_path --cached 以上命令将file_path所代表的文件从版本控制中删除，并保留本地文件，此外还要进行commit操作才能将服务器端的文件删掉。如果想把一个文件夹从版本控制中删除并保留本地的文件，只需在上述命令的基础上加上-r参数，即 1git rm -r folder_path --cached 如果想把所有gitignore中的文件从版本控制中删除的话，需要执行以下两个命令，即先移除所有文件，再执行添加所有文件（这次会忽略gitignore中的文件）。 12git rm -r . --cachedgit add .]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-bootstrap读后感]]></title>
    <url>%2F2018%2F02%2F02%2Freact%2Freact-bootstrap%E8%AF%BB%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[基于react-bootstrap的0.32.1版本。 eslintextendseslint-config-airbnb使用了基于airbnb的js代码风格，详细了解： https://github.com/airbnb/javascript 中文版：https://github.com/yuche/javascript prettier格式化代码，使代码风格统一，详细了解： https://prettier.io/ plugins eslint-plugin-import：帮助校验是否正确导入模块 eslint-plugin-jsx-a11y：帮助校验React属性是否支持 eslint-plugin-prettier：prettier的eslint插件 eslint-plugin-react：React校验规则插件 babel插件 babel-plugin-transform-class-properties：转换class属性，如实例属性、类静态属性 babel-plugin-add-module-exports：省去require(&#39;module&#39;).default中的default babel-plugin-transform-export-extensions：支持export * as ns from &#39;mod&#39;和export v from &#39;mod&#39;;语法 babel-plugin-transform-object-rest-spread：支持...运算符 babel-plugin-transform-runtime：使用babel-runtime替换，免去引用babel-polyfill造成的全局变量污染 参考文章： https://zhuanlan.zhihu.com/p/27777995 https://segmentfault.com/a/1190000009065987 preset babel-preset-env babel-preset-react 感觉挺有用的第三方模块 chai：Node.js的断言库 codecov：集成测试覆盖率工具 参考网址： https://www.jianshu.com/p/146c4769d4b1 colors：很容易设置颜色 cross-env：解决跨平台命令问题 enzyme：测试React fs-extra：为原生的fs模块添加promise支持 husky：Git hooks made easy sinon：Standalone test spies, stubs and mocks for JavaScript. Works with any unit testing framework. invariant：在开发环境下提示错误的快速写法 warning：facebook的warning，快速写警告 keycode：在键盘键码和键名之间进行转换，反之亦然 用到的测试框架 mocha：Node.js的测试框架 karama：JS测试框架 React好像推荐的是Jest框架，这个有待了解 编译提供的选择 dist：使用webpack提供的webpack方法进行编译； lib：使用babel的transform方法编译； es：使用babel的transform方法编译，和lib方法不同的是少了一个babel-plugin-add-module-exports插件；（这个文件应该没什么用吧，现在浏览器支持率这么低） bower：复制dist文件夹 用到的一些JS语法 柯里化函数： http://www.zhangxinxu.com/wordpress/2013/02/js-currying/ https://www.jianshu.com/p/f5033cec605e async/await： http://es6.ruanyifeng.com/#docs/generator React获取子组件或父组件属性： https://liaoyongfu.github.io/2017/08/02/react/react%E8%8E%B7%E5%8F%96%E7%88%B6%E7%BB%84%E4%BB%B6%E6%88%96%E5%AD%90%E7%BB%84%E4%BB%B6%E5%B1%9E%E6%80%A7/ 使用yarn替换npm运行yarn命令 忽略一些文件当别人安装时通过制定package.json的files字段，或者也可以制定.npmignore。以下文件一定会包含： package.json README CHANGES / CHANGELOG / HISTORY LICENSE / LICENCE NOTICE main字段指定的文件 相反，以下文件总会被忽略： .git CVS .svn .hg .lock-wscript .wafpickle-N .*.swp .DS_Store ._* npm-debug.log .npmrc node_modules config.gypi *.orig package-lock.json (use shrinkwrap instead) 在webstrom中使用eslint校验先安装eslint插件，配置Eslint Plugin： 然后打开file/settings/Keymap，搜索ESlint找到Fix ESLint Problems，右击选择Add Keyboard Shortcut， 键入ctrl + e（这里看个人习惯） 详细：https://github.com/idok/eslint-plugin gatsby报错：RootQueryType.allSitePage field type must be Output Type but got: SitePageConnection.运行yarn list gatsby发现会有多个依赖： 12npm remove graphqlnpm install gatsby 要统一一个版本的gatsby 报错&quot;jsonName&quot; of undefined目录中不能包含中文目录 Error: Schema must contain unique named types but contains multiple types named “JSON”暂时不知道为什么 有时候要删除.cache文件并重启才能生效，不知道为什么？？？hexo d -g报错[Windows] bash: /dev/tty: No such a device or addressTry adding this into your git config12[credential] helper = wincred or via console 1git config --global credential.helper wincred shareui文档构建首先在根目录下运行脚手架： 12gatsby new doc cd doc 然后修改gatsby的配置： 12345678910111213141516171819202122232425const path = require(&quot;path&quot;);module.exports = &#123; siteMetadata: &#123; title: &quot;Shareui文档&quot; &#125;, plugins: [ &quot;gatsby-plugin-react-helmet&quot;, &#123; resolve: &quot;gatsby-source-filesystem&quot;, options: &#123; path: path.resolve(__dirname, &quot;../src&quot;), name: &quot;source&quot; &#125; &#125;, &quot;gatsby-transformer-react-docgen&quot;, &#123; resolve: &quot;gatsby-transformer-remark&quot;, options: &#123; plugins: [&quot;gatsby-remark-prismjs&quot;] &#125; &#125;, &quot;gatsby-plugin-catch-links&quot; ]&#125;; 使用gatsby-source-filesystem可以方便查询本地文件的相关信息；使用gatsby-transformer-react-docgen方便查询组件信息。 在src/pages目录下新建alert.js（会自动生成alert页面）: 123456789101112131415161718192021import React from &quot;react&quot;;import Link from &quot;gatsby-link&quot;;import PropTable from &quot;../components/PropTable&quot;;const Page = (&#123;data&#125;) =&gt; ( &lt;div&gt; &lt;h1&gt;&#123;data.componentMetadata &amp;&amp; data.componentMetadata.description&#125;&lt;/h1&gt; &lt;Link to=&quot;/&quot;&gt;返回首页&lt;/Link&gt; &lt;PropTable metadata=&#123;data&#125; /&gt; &lt;/div&gt;);export const query = graphql` query AlertQuery &#123; componentMetadata(displayName: &#123;eq: &quot;Alert&quot;&#125;) &#123; ...PropTable_metadata &#125; &#125;`;export default Page; 其中的片段PropTable_metadata如下： 12345678910111213141516171819export const metadataFragment = graphql` fragment PropTable_metadata on ComponentMetadata &#123; displayName description props &#123; name type &#123; name value raw &#125; defaultValue &#123; value computed &#125; required &#125; &#125;`; 为了列出所有的组件，我们使用gatsby-source-filesystem查询出在src目录下的所有组件，并添加到首页（doc/src/index.js）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React from &quot;react&quot;;import Link from &quot;gatsby-link&quot;;const IndexPage = (&#123;data&#125;) =&gt; ( &lt;div&gt; &lt;h3&gt;基础组件&lt;/h3&gt; &lt;ol&gt; &#123;data.allFile.edges //先排序 .sort((a, b) =&gt; &#123; if (a.node.name &gt; b.node.name) &#123; return 1; &#125; else if (a.node.name &lt; b.node.name) &#123; return -1; &#125; return 0; &#125;) //排除index.js和utils下的文件 .map( (edge, index) =&gt; edge.node.relativeDirectory !== &quot;utils&quot; &amp;&amp; edge.node.name !== &quot;index&quot; &amp;&amp; ( &lt;li key=&#123;index&#125;&gt; &lt;Link to=&#123;`/$&#123;edge.node.name&#125;/`&#125;&gt; &#123;edge.node.name&#125; &lt;/Link&gt; &lt;/li&gt; ) )&#125; &lt;/ol&gt; &lt;/div&gt;);export const query = graphql` query allComponent &#123; allFile &#123; edges &#123; node &#123; name relativeDirectory &#125; &#125; &#125; &#125;`;export default IndexPage; 读取组件的注释： 12345/** * 提示框（Alert） */class Alert extends React.Component &#123;&#125; 之后通过data.componentMetadata.description字段即可获取。 属性注释会报错Error: Schema must contain unique named types but contains multiple types named “JSON”，暂时不知道为什么]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native中遇到的坑]]></title>
    <url>%2F2017%2F12%2F21%2Freact-native%2Freact-native%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[Android中TextInput有下边框添加transparent即可解决 1&lt;TextInput underlineColorAndroid=&quot;transparent&quot;/&gt; Android中borderRadius和borderWidth一起使用时效果会出错看issue好像还没有解决： https://github.com/facebook/react-native/issues/11042]]></content>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用node.js发送邮件]]></title>
    <url>%2F2017%2F12%2F13%2Fnodejs%2F%E4%BD%BF%E7%94%A8node.js%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[使用nodemailler发送邮件这里我们以使用qq邮箱发送邮件为例。 安装nodemailer 1npm install --save nodemailer 使用 12345678910111213141516171819var nodemailer = require(&apos;nodemailer&apos;);var mailTransport = nodemailer.createTransport(&#123; host: &apos;smtp.qq.com&apos;, //服务器地址 port: 465, //端口 auth: &#123; user: &apos;xxx@qq.com&apos;, pass: &apos;授权码&apos; //注：这里需要是授权码（在设置-&gt;账户-&gt;POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务下“生成授权码”），而不是登录密码 &#125; &#125;); mailTransport.sendMail(&#123; from: &apos;&quot;your name&quot; &lt;xxx@qq.com&gt;&apos;, to: &apos;xxx@gmail.com&apos;, //收件人地址 subject: &apos;测试邮件111&apos;, text: &apos;测试内容哦11111！！！！！！！&apos; &#125;, function(err)&#123; if(err) console.error(&apos;发送失败:&apos;, err); console.info(&apos;发送成功！&apos;); &#125;)]]></content>
      <tags>
        <tag>express</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React项目问题总结]]></title>
    <url>%2F2017%2F11%2F01%2Freact%2FReact%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[目前出现的问题 需要定义很多初始化state变量？ 表单编辑后点取消，重新从后台拿数据如果是null的时候它不会自动更新state？ 组件复用：未编写PropTypes，如果写了有时候返回的字段是null的，怎么写PropTypes？ 组件复用：如果组件自己处理内部逻辑，那外面的组件如何拿到组件里面的数据？ 页面需要记住类似查询状态，如何简单有效的实现？使用高阶组件实现？如何做到不冲突？ 提示框太难用了？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * * Created by liaoyf on 2017/11/1 0001. */import React from &apos;react&apos;;import &apos;bootstrap&apos;;import &#123; render &#125; from &apos;react-dom&apos;;import v4 from &apos;uuid&apos;;class ModalTool&#123; constructor(options)&#123; this.options = &#123; okText: &apos;确定&apos;, cancelText: &apos;取消&apos;, title: &apos;提示框&apos;, okAutoClose: true, cancelAutoClose: true, bsStyle: null, bsSize: &apos;&apos;, subContent: &apos;&apos;, customContent: &apos;&apos;, closeBtn: true, backdrop: true, ...options &#125;; this.init(); &#125; bindEvent()&#123; let &#123; onOk, onCancel &#125; = this.options; $(&apos;#&apos; + this.modalId + &apos; .btn-ok&apos;).unbind(&apos;click&apos;).on(&apos;click&apos;, function()&#123; onOk &amp;&amp; onOk(); &#125;); $(&apos;#&apos; + this.modalId + &apos; .btn-cancel&apos;).unbind(&apos;click&apos;).on(&apos;click&apos;, function()&#123; onCancel &amp;&amp; onCancel(); &#125;); &#125; closeModal()&#123; $(&apos;#&apos; + this.modalId ).modal(&apos;hide&apos;); &#125; init()&#123; // $(&apos;.modalBox&apos;).remove(); $(&apos;.modal-backdrop&apos;).remove(); let &#123; title, content, okText, closeBtn, cancelText, okAutoClose, cancelAutoClose, bsStyle, bsSize, subContent, customContent, backdrop &#125; = this.options; if(bsStyle)&#123; content = ( &lt;dl className=&#123;`modal-state-show $&#123;bsStyle === &apos;warning&apos; ? &apos;state-error&apos; : bsStyle === &apos;success&apos; ? &apos;state-success&apos; : &apos;&apos;&#125;`&#125;&gt; &lt;dt className=&quot;state-ico&quot;&gt;&lt;i className=&quot;fa&quot;&gt;&lt;/i&gt;&lt;/dt&gt; &lt;dd className=&quot;state-text&quot;&gt;&#123;content&#125;&lt;/dd&gt; &#123;subContent &amp;&amp; &lt;dd className=&quot;state-info&quot;&gt;&#123;subContent&#125;&lt;/dd&gt;&#125; &#123;customContent &amp;&amp; &lt;dd&gt;&lt;p&gt;&#123;customContent&#125;&lt;/p&gt;&lt;/dd&gt;&#125; &lt;/dl&gt; ); &#125;else if(!React.isValidElement(content))&#123; content = ( &lt;div className=&quot;text-vertical-wrap&quot;&gt; &lt;p className=&quot;text-center text-vertical&quot;&gt;&#123;content&#125;&lt;/p&gt; &lt;/div&gt; ); &#125; let modalId = `modal_$&#123;v4.v4()&#125;`; let html = `&lt;div class=&quot;modal fade modalBox&quot; id=&quot;$&#123;modalId&#125;&quot; tabIndex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot;&gt; &lt;div class=&quot;$&#123;&apos;modal-dialog &apos; + (bsSize ? &apos;modal-&apos; + bsSize : (bsStyle ? &apos;modal-sm&apos; : &apos;&apos;))&#125;&quot; role=&quot;document&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; $&#123;closeBtn ? `&lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;` : &apos;&apos;&#125; &lt;h4 class=&quot;modal-title&quot; id=&quot;myModalLabel&quot;&gt;$&#123;title&#125;&lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;body-inset modal-body&quot; id=&quot;modalBoxBody&quot;&gt; &lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; $&#123;okText ? `&lt;button type=&quot;button&quot; class=&quot;btn btn-primary btn-ok&quot; $&#123;okAutoClose &amp;&amp; `data-dismiss=&quot;modal&quot;`&#125;&gt;$&#123;okText&#125;&lt;/button&gt;` : &apos;&apos;&#125; $&#123;cancelText ? `&lt;button type=&quot;button&quot; class=&quot;btn btn-default btn-cancel&quot; $&#123;cancelAutoClose &amp;&amp; `data-dismiss=&quot;modal&quot;`&#125;&gt;$&#123;cancelText&#125;&lt;/button&gt;` : &apos;&apos;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; `; $(&apos;body&apos;).append(html); this.modalId = modalId; render( content, $(`#$&#123;modalId&#125; #modalBoxBody`)[0], () =&gt; &#123; $(`#$&#123;modalId&#125;`).modal(&#123; backdrop: backdrop &#125;); this.bindEvent(); &#125; ); return $(`#$&#123;modalId&#125;`); &#125;&#125;export default ModalTool; 需要封装常用的对象或数组操作工具方法 表单使用体验太差：需要编写一大推标签；需要手动编写value和onChange；表单校验需要改善 npm 包依赖如何做到同步更新？npm安装依赖包经常报错？npm打包太慢，启动太慢？打包后的文件不会自动加入svn版本控制？ npm安装依赖包报： npm ERR! unlink的错误，解决方法： 12345rm (-rf) node_modulesrm package-lock.json yarn.locknpm cache clear --forcenpm i -g npm # 5.4.1, as for nownpm install --no-optional 最好打包时自动运行npm update操作： 12345//package.json&quot;script&quot;: &#123; &quot;updater&quot;: &quot;npm update&quot;, &quot;build&quot;: &quot;npm run updater&amp;&amp;webpack --env=prod --progress --profile --colors&quot;&#125; 如何做到公共thunk的合并？ front编译如何做到自动化？ process.env.NODE_ENV在编译后变成I.env.NODE_ENV？ 如何require或import远程地址的文件？ 脚手架运行时最好能判断当前的版本是不是最新的，如果不是就报错，这样能确保安装最新的脚手架？ 热加载更新？ 1234567891011121314151617import Container from &apos;./router&apos;;const render = (Component) =&gt; &#123; ReactDOM.render( &lt;Component/&gt;, document.getElementById(&apos;root&apos;) ) &#125;;render(Container);if (module.hot) &#123; module.hot.accept(&apos;./router.js&apos;, () =&gt; &#123; const NextRootContainer = require(&apos;./router&apos;).default; render(NextRootContainer); &#125;);&#125; js生成sourcemap方便调试？ 组件间的样式在打包后会被相互影响？ 使用css module 如何解决ulynlist问题：basePath问题（貌似可以自己引）？ 打包时如果output.publicPath为空字符串时会找不到字体图标的bug？ 配置： 12345678910111213141516171819&#123; test: /\.scss$/, use: ExtractTextPlugin.extract(&#123; //主要是加这一句 publicPath: &apos;../&apos;, fallback: &apos;style-loader&apos;, use: [ &#123; loader: &apos;css-loader?sourceMap&apos; &#125;, &#123; loader: &apos;resolve-url-loader&apos; &#125;, &#123; loader: &apos;sass-loader?sourceMap&apos; &#125; ] &#125;)&#125; 样式想要抽成公用的，有两种方法： 如果只想在入口引用一个，则必须写到entry中；如果在多个文件中引用？]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React入门——简介]]></title>
    <url>%2F2017%2F10%2F31%2Freact%2FReact%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[一、什么是React？ React是Facebook开源的一个用于构建用户界面的Javascript库，他不是一个框架，而是专注于MVC架构中的V，即视图。这使得React很容易和开发者已有的开发栈进行融合。React顺应了Web开发组件化的趋势。应用React时，你总是应该从UI出发抽象出不同的组件，然后像搭积木一样把它们拼装起来。 二、React能做什么？ 补充：桌面应用程序（NW.js和Electron.js） 二、React全家桶 自身库： react.js、react-dom.js、add-ons 语法：ES5/ES6、JSX 构建工具：Fis3、webpack、babel 状态管理：Redux、Flux、react-redux、Immutable 路由：react-router、react-redux-router 日志：redux-logger 中间件：redux-thunk 主题：react-bootstrap 表单：redux-form]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建一个React项目]]></title>
    <url>%2F2017%2F10%2F31%2Freact%2F%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAReact%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[React由Facebook所写，由虚拟Dom、组件化获得广大前端开发者的青睐，下面我们通过一个示例来演示创建React项目的步骤： 为什么用ReactReact解决了创建大型项目性能以及复用性问题，React可以有两种写法： 使用React.createClass语法 var HelloComponent = React.createClass({ render: function() { return ( &lt;div className=&quot;hello&quot;&gt; Hello, world! &lt;/div&gt; ); } }); 使用ES6语法 class HelloComponent extends React.Component { render() { return ( &lt;div className=&quot;hello&quot;&gt; Hello, world! &lt;/div&gt; ); } } 创建React项目 安装Node.js和NPM，然后运行npm init创建一个package.json文件. 在控制台中运行：npm install react react-dom babel-core babel-loader babel-preset-es2015 babel-preset-react webpack webpack-dev-server --save 创建webpack.config.js配置文件，这个的作用是帮我们打包资源，转换JSX为JS文件、合并、压缩、编译等等等。。。 一个简单的webpack.config.js大致如下： var debug = process.env.NODE_ENV !== &quot;production&quot;; var webpack = require(&apos;webpack&apos;); var path = require(&apos;path&apos;); module.exports = { context: path.join(__dirname, &quot;src&quot;), devtool: debug ? &quot;inline-sourcemap&quot; : null, entry: &quot;./js/App.js&quot;, devServer: { inline: true, port: 3333 }, module: { loaders: [ { test: /\.jsx?$/, exclude: /(node_modules|bower_components)/, loader: &apos;babel-loader&apos;, query: { presets: [&apos;react&apos;, &apos;es2015&apos;], plugins: [&apos;react-html-attrs&apos;, &apos;transform-class-properties&apos;, &apos;transform-decorators-legacy&apos;], } } ] }, output: { path: __dirname + &quot;/src/&quot;, filename: &quot;bundle.min.js&quot; }, plugins: debug ? [] : [ new webpack.optimize.DedupePlugin(), new webpack.optimize.OccurenceOrderPlugin(), new webpack.optimize.UglifyJsPlugin({ mangle: false, sourcemap: false }), ], }; 程序的入口通过entry设置，即页面第一次加载运行的文件，Webpack将把所有的JS和JSX文件到文件的输出对象，通过devServer设置webpack开发服务器为内联，并设置端口为3333，在module配置中，我们配置babel转换规则：使用react和es2015,plugins增加了类的属性和装饰器的功能。 热加载首先安装热加载模块： npm install --save-dev babel-preset-react-hmre 然后加到配置中： .... query: { presets: [&apos;react&apos;, &apos;es2015&apos;, &apos;react-hmre&apos;], plugins: [&apos;react-html-attrs&apos;, &apos;transform-class-properties&apos;, &apos;transform-decorators-legacy&apos;], } 另一个选择是安装react-hot-loader然后添加react-hot到webpack.config.js配置中： ... loader: [&apos;babel-loader&apos;, &apos;react-hot&apos;] ... 为了运行项目更简单，我们一般会使用package.json的命令： { &quot;scripts&quot;: { &quot;start&quot;: &quot;node_modules/.bin/webpack-dev-server --progress --inline --hot&quot;, } } 注意：我们命令中添加了--hot，这个启动了热加载模式. 路由路由是一个应用非常重要的一部分，在React中比较受欢迎的莫属React Router了，事实上，很多开发者认为它就是React官方版的路由，当然，你得先安装它： npm install --save react-router 一个简单的示例看起来是这样子的： import React from &apos;react&apos;; import { render } from &apos;react-dom&apos;; import { browserHistory, Router, Route, IndexRoute } from &apos;react-router&apos; import App from &apos;../components/App&apos; import Home from &apos;../components/Home&apos; import About from &apos;../components/About&apos; import Features from &apos;../components/Features&apos; render( &lt;Router history={browserHistory}&gt; &lt;Route path=&apos;/&apos; component={App}&gt; &lt;IndexRoute component={Home} /&gt; &lt;Route path=&apos;about&apos; component={About} /&gt; &lt;Route path=&apos;features&apos; component={Features} /&gt; &lt;/Route&gt; &lt;/Router&gt;, document.getElementById(&apos;app&apos;) ) 国际化(I18N)通过react-intl你可以很轻松地实现国际化，它支持超过150中不同语言，默认是英文，呃~ 权限认证Authentication is an important part of any application. The best way to do user authentication for single page apps is via JSON Web Tokens (JWT). A typical authentication flow is this: A user signs up/logs in, generate JWT token and return it to the client Store the JWT token on the client and send it via headers/query parameters for future requests A comprehensive example of adding authentication to a ReactJS app is here. Using Redux? Here is a good example of setting up authentication in your ReactJS application. 数据持久化Without a backend, you can persist data in your Single Page App by using Firebase. In a Reactjs app, all you simply need is ReactFire. It is a ReactJS mixin for easy Firebase integration. With ReactFire, it only takes a few lines of JavaScript to integrate Firebase data into React apps via the ReactFireMixin npm install --save reactfire react firebase TodoList Example import React from &apos;react&apos;; class TodoList extends React.Component { render() { var _this = this; var createItem = (item, index) =&gt; { return ( &lt;li key={ index }&gt; { item.text } &lt;span onClick={ _this.props.removeItem.bind(null, item[&apos;.key&apos;]) } style=&gt; X &lt;/span&gt; &lt;/li&gt; ); }; return &lt;ul&gt;{ this.props.items.map(createItem) }&lt;/ul&gt;; } } class TodoApp extends React.Component { getInitialState() { return { items: [], text: &apos;&apos; }; } componentWillMount() { this.firebaseRef = firebase.database().ref(&apos;todoApp/items&apos;); this.firebaseRef.limitToLast(25).on(&apos;value&apos;, function(dataSnapshot) { var items = []; dataSnapshot.forEach(childSnapshot =&gt; { const item = childSnapshot.val(); item[&apos;.key&apos;] = childSnapshot.key; items.push(item); }); this.setState({ items: items }); }.bind(this)); } componentWillUnmount() { this.firebaseRef.off(); } onChange(e) { this.setState({text: e.target.value}); } removeItem(key) { var firebaseRef = firebase.database().ref(&apos;todoApp/items&apos;);; firebaseRef.child(key).remove(); } handleSubmit(e) { e.preventDefault(); if (this.state.text &amp;&amp; this.state.text.trim().length !== 0) { this.firebaseRef.push({ text: this.state.text }); this.setState({ text: &apos;&apos; }); } } render() { return ( &lt;div&gt; &lt;TodoList items={ this.state.items } removeItem={ this.removeItem } /&gt; &lt;form onSubmit={ this.handleSubmit }&gt; &lt;input onChange={ this.onChange } value={ this.state.text } /&gt; &lt;button&gt;{ &apos;Add #&apos; + (this.state.items.length + 1) }&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; ); } } ReactDOM.render(&lt;TodoApp /&gt;, document.getElementById(&apos;todoApp&apos;)); More information about persisting your data using ReactFire here. 测试Most projects become a mountain of spaghetti code at some point during development due to lack of solid tests or no tests at all. ReactJS apps are no different, but this can be avoided if you know some core principles. When writing tests for ReactJS code, it is helpful to pull out any functionality that doesn’t have to do with any UI components into separate modules, so that they can be tested separately. Tools for unit testing those functionalities are mocha, expect, chai, jasmine. Testing becomes tricky in a ReactJS application when you have to deal with components. How do you test stateless components? How do you test components with state? Now, ReactJS provides a nice set of test utilities that allow us to inspect and examine the components we build. A particular concept worthy of mention is Shallow Rendering. Instead of rendering into a DOM the idea of shallow rendering is to instantiate a component and get the result of its render method. You can also check its props and children and verify they work as expected. More information here. Facebook uses Jest to test React applications. AirBnB uses Enzyme. When bootstrapping your ReactJS application, you can set up any of these awesome tools to implement testing. 脚手架和模板A lot of tools have been mentioned in this post in relation to setting up different parts of a ReactJS app. If you don’t intend writing your app from scratch, there are lots of generators and boilerplates that tie all these tools together to give you a great starting point for your app. One fantastic example is React Starter Kit. It has a Yeoman generator. It’s an isomorphic web app boilerplate that contains almost everything you need to build a ReactJS app. Another boilerplate is React Static boilerplate, it helps you build a web app that can be hosted directly from CDNs like Firebase and Github Pages. Other alternatives are React redux starter kit and React webpack generator. Recently, a nice and effective tool called create-react-app was released by the guys at Facebook. It’s a CLI tool that helps create React apps with no build configuration! 结语There are several tools that will help bootstrap your React app, we looked at a couple that we consider quite good and will have your application up and running in no time. But feel free to search for your own tools, and if you think that we are missing something, let us know in the comments. Setting up a React project should be painless! “Setting up a React project should be painless!”]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css样式遇到的坑]]></title>
    <url>%2F2017%2F10%2F31%2Fcss%2Fcss%E6%A0%B7%E5%BC%8F%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[bootstrap-datetime-picker在模态框中会随着页面滚动而错位解决方法：在options中增加container: &#39;#modalId .modal-dialog&#39;，默认的container是body，所以要改成.modal-dialog。]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express入门]]></title>
    <url>%2F2017%2F10%2F12%2Fnodejs%2Fexpress%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[配置handlebars12345678910111213//须安装express-handlebarsvar exhbs = require(&apos;express-handlebars&apos;);var index = require(&apos;./routes/index&apos;);var users = require(&apos;./routes/users&apos;);var app = express();// view engine setup，这边名称如果为.hbs，则文件命名结尾也是.hbs（extname无效？）app.engine(&apos;.hbs&apos;, exhbs(&#123; extname: &apos;.hbs&apos;&#125;));app.set(&apos;views&apos;, path.join(__dirname, &apos;views&apos;));app.set(&apos;view engine&apos;, &apos;.hbs&apos;); 使用supervisor进行热部署安装： 1npm install -g supervisor 如果你使用的是 Linux 或 Mac，直接键入上面的命令很可能会有权限错误。原因是 npm需要把 supervisor 安装到系统目录，需要管理员授权，可以使用 sudo npm install -g supervisor 命令来安装。 接下来，更改pcakge.json中的start字段： 1&quot;start&quot;: &quot;supervisor bin/www&quot; 之后运行npm start既可，命令行窗口会显示启动成功信息，即开启了代码监听。 开放API123456789101112131415161718192021222324252627282930313233343536var express = require(&apos;express&apos;);var router = express.Router();var mysql = require(&apos;mysql&apos;);var conncection = mysql.createConnection(&#123; host: &apos;localhost&apos;, user: &apos;root&apos;, password: &apos;*****&apos;, database: &apos;test&apos;, port: 3306&#125;);conncection.connect();router.get(&apos;/getFamilyList&apos;, function(req, res, next)&#123; conncection.query(&apos;select * from family&apos;, function(err, results, fields)&#123; if(err) throw err; res.json(results); &#125;);&#125;);router.get(&apos;/getFamilyById&apos;, function (req, res, next) &#123; conncection.query(&apos;select * from family where id=?&apos;, [req.query.id], function(err, results, fields)&#123; if(err) throw err; res.json(results[0]); &#125;);&#125;);router.post(&apos;/updateFamilyById&apos;, function (req, res, next) &#123; conncection.query(&apos;update family set name=?,age=? where id=?&apos;, [req.body.name, req.body.age, req.body.id], function(err, results, fields)&#123; if(err) throw err; res.json(&#123; status: true &#125;); &#125;);&#125;);module.exports = router;]]></content>
      <tags>
        <tag>express</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 16新增功能]]></title>
    <url>%2F2017%2F09%2F29%2Freact%2FReact%2016%E6%96%B0%E5%A2%9E%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[官网介绍https://facebook.github.io/react/blog/2017/09/26/react-v16.0.html render函数不必在包一层元素123456789render() &#123; // No need to wrap list items in an extra element! return [ // Don&apos;t forget the keys :) &lt;li key=&quot;A&quot;&gt;First item&lt;/li&gt;, &lt;li key=&quot;B&quot;&gt;Second item&lt;/li&gt;, &lt;li key=&quot;C&quot;&gt;Third item&lt;/li&gt;, ];&#125; 更好的错误处理以前的版本，如果子组件有报错整个组件本身直接不渲染，而现在可以通过componentDidCatch捕获错误信息： 123456789101112131415161718192021222324252627282930313233class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; error: null, errorInfo: null &#125;; &#125; componentDidCatch(error, errorInfo) &#123; // Catch errors in any components below and re-render with error message this.setState(&#123; error: error, errorInfo: errorInfo &#125;) // You can also log error messages to an error reporting service here &#125; render() &#123; if (this.state.errorInfo) &#123; // Error path return ( &lt;div&gt; &lt;h2&gt;Something went wrong.&lt;/h2&gt; &lt;details style=&#123;&#123; whiteSpace: &apos;pre-wrap&apos; &#125;&#125;&gt; &#123;this.state.error &amp;&amp; this.state.error.toString()&#125; &lt;br /&gt; &#123;this.state.errorInfo.componentStack&#125; &lt;/details&gt; &lt;/div&gt; ); &#125; // Normally, just render children return this.props.children; &#125;&#125; Portals现在可以通过React.createPortal(&lt;SomeComponent/&gt;, document.getElementById(&#39;root&#39;))的形式在react应用容器之外修改或增加DOM： 12345678render() &#123; // React does *not* create a new div. It renders the children into `domNode`. // `domNode` is any valid DOM node, regardless of its location in the DOM. return ReactDOM.createPortal( this.props.children, domNode, );&#125; 这样对于像要创建模态框就很容易了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Overlay extends React.Component&#123; constructor()&#123; super(); this.overlayContainer = document.createElement(&apos;div&apos;); document.body.appendChild(this.overlayContainer); &#125; componentWillUnmount()&#123; document.body.removeChild(this.overlayContainer); &#125; render()&#123; return ReactDOM.createPortal( &lt;div className=&quot;overlay&quot; style=&#123;&#123;position: &apos;absolute&apos;, top: 0, right: 0, bottom: 0, left: 0, background: &apos;rgba(0,0,0, 0.5)&apos;, color: &apos;#fff&apos;&#125;&#125;&gt; &#123;this.props.children&#125; &lt;/div&gt;, this.overlayContainer ) &#125;&#125;class Demo extends React.Component&#123; constructor()&#123; super(); this.state = &#123; overlayActive: true &#125;; &#125; render()&#123; return ( &lt;div&gt; &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; this.setState(&#123; user: null &#125;)&#125;&gt;Update&lt;/button&gt; &#123;this.state.overlayActive &amp;&amp; ( &lt;Overlay onClose=&#123;() =&gt; this.setState(&#123;overlayActive: false&#125;)&#125;&gt; hello modal!!! &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; this.setState(&#123;overlayActive: false&#125;)&#125;&gt;Close&lt;/button&gt; &lt;/Overlay&gt; )&#125; &lt;/div&gt; ); &#125;&#125; 更好的服务端渲染省略。。。 支持自定义DOM属性以前是直接忽视无法识别的属性，而现在是直接渲染给DOM，这也直接节省了很多代码。 具体参考：https://facebook.github.io/react/blog/2017/09/08/dom-attributes-in-react-16.html 文件减少 react is 5.3 kb (2.2 kb gzipped), down from 20.7 kb (6.9 kb gzipped). react-dom is 103.7 kb (32.6 kb gzipped), down from 141 kb (42.9 kb gzipped). react + react-dom is 109 kb (34.8 kb gzipped), down from 161.7 kb (49.8 kb gzipped). MIT协议妥协了… 新的核心架构Fiber]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native中FlatList的使用]]></title>
    <url>%2F2017%2F09%2F29%2Freact-native%2Freact-native%E4%B8%ADFlatList%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[原文地址：https://medium.com/react-native-development/how-to-use-the-flatlist-component-react-native-basics-92c482816fe6 简介自从0.43版本以来，react-native新增了两个新的列表视图组件：FlatList以及SectionList，现在我们来看看FlatList组件的使用。 简单示例在FlatList中有个比较重要的属性：data和renderItem属性，data为object数组，renderItem可以控制每个item的渲染规则。 这边的示例我们将会从Random User Generator API中拿，UI渲染将会使用react-native-elements的组件。 点击查看完整源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//FlatListDemo.jsimport React, &#123; Component &#125; from &quot;react&quot;;import &#123; View, Text, FlatList &#125; from &quot;react-native&quot;;class FlatListDemo extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; loading: false, data: [], page: 1, seed: 1, error: null, refreshing: false, &#125;; &#125; componentDidMount() &#123; this.makeRemoteRequest(); &#125; makeRemoteRequest = () =&gt; &#123; const &#123; page, seed &#125; = this.state; const url = `https://randomuser.me/api/?seed=$&#123;seed&#125;&amp;page=$&#123;page&#125;&amp;results=20`; this.setState(&#123; loading: true &#125;); fetch(url) .then(res =&gt; res.json()) .then(res =&gt; &#123; this.setState(&#123; data: page === 1 ? res.results : [...this.state.data, ...res.results], error: res.error || null, loading: false, refreshing: false &#125;); &#125;) .catch(error =&gt; &#123; this.setState(&#123; error, loading: false &#125;); &#125;); &#125;; render() &#123; return ( &lt;View style=&#123;&#123; flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; &#125;&#125;&gt; &lt;Text&gt;Coming soon...&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;export default FlatListDemo; 然后外边就可以使用： 12345678910111213141516171819202122import FlatList from &apos;./FlatListDemo.js&apos;;import React from &apos;react&apos;;import &#123; List, ListItem &#125; from &apos;react-native-elements&apos;;class AwesomeProject extends React.Component&#123; render()&#123; &lt;List&gt; &lt;FlatList data=&#123;this.state.data&#125; renderItem=&#123;(&#123; item &#125;) =&gt; ( &lt;ListItem roundAvatar title=&#123;`$&#123;item.name.first&#125; $&#123;item.name.last&#125;`&#125; subtitle=&#123;item.email&#125; avatar=&#123;&#123; uri: item.picture.thumbnail &#125;&#125; keyExtractor=&#123;item =&gt; item.email&#125; /&gt; )&#125; /&gt; &lt;/List&gt; &#125;&#125; 效果图如下：]]></content>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js浅拷贝和深拷贝]]></title>
    <url>%2F2017%2F08%2F02%2Fjavascript%2Fjs%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[javaScript的变量类型（1）基本类型： 5种基本数据类型Undefined、Null、Boolean、Number 和 String，变量是直接按值存放的，存放在栈内存中的简单数据段，可以直接访问。 （2）引用类型： 存放在堆内存中的对象，变量保存的是一个指针，这个指针指向另一个位置。当需要访问引用类型（如对象，数组等）的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据。 JavaScript存储对象都是存地址的，所以浅拷贝会导致 obj1 和obj2 指向同一块内存地址。改变了其中一方的内容，都是在原来的内存上做修改会导致拷贝对象和源对象都发生改变，而深拷贝是开辟一块新的内存地址，将原对象的各个属性逐个复制进去。对拷贝对象和源对象各自的操作互不影响。 例如：数组拷贝 123456//浅拷贝，双向改变,指向同一片内存空间var arr1 = [1, 2, 3];var arr2 = arr1;arr1[0] = &apos;change&apos;;console.log(&apos;shallow copy: &apos; + arr1 + &quot; ); //shallow copy: change,2,3console.log(&apos;shallow copy: &apos; + arr2 + &quot; ); //shallow copy: change,2,3 浅拷贝的实现 简单的引用复制1234567891011121314function shallowClone(copyObj) &#123; var obj = &#123;&#125;; for ( var i in copyObj) &#123; obj[i] = copyObj[i]; &#125; return obj;&#125;var x = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [ 1, 2, 3 ]&#125;;var y = shallowClone(x);console.log(y.b.f === x.b.f); // true Object.assign()Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。 1234567var x = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [ 1, 2, 3 ]&#125;;var y = Object.assign(&#123;&#125;, x);console.log(y.b.f === x.b.f); // true 深拷贝的实现Array的slice和concat方法Array的slice和concat方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。之所以把它放在深拷贝里，是因为它看起来像是深拷贝。而实际上它是浅拷贝。原数组的元素会按照下述规则拷贝： 如果该元素是个对象引用 （不是实际的对象），slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。 对于字符串、数字及布尔值来说（不是 String、Number 或者 Boolean 对象），slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。 如果向两个数组任一中添加了新元素，则另一个不会受到影响。例子如下： 1234567var array = [1,2,3]; var array_shallow = array; var array_concat = array.concat(); var array_slice = array.slice(0); console.log(array === array_shallow); //true console.log(array === array_slice); //false，“看起来”像深拷贝console.log(array === array_concat); //false，“看起来”像深拷贝 可以看出，concat和slice返回的不同的数组实例，这与直接的引用复制是不同的。而从另一个例子可以看出Array的concat和slice并不是真正的深复制，数组中的对象元素(Object,Array等)只是复制了引用。如下： 123456789var array = [1, [1,2,3], &#123;name:&quot;array&quot;&#125;]; var array_concat = array.concat();var array_slice = array.slice(0);array_concat[1][0] = 5; //改变array_concat中数组元素的值 console.log(array[1]); //[5,2,3] console.log(array_slice[1]); //[5,2,3] array_slice[2].name = &quot;array_slice&quot;; //改变array_slice中对象元素的值 console.log(array[2].name); //array_sliceconsole.log(array_concat[2].name); //array_slice JSON对象的parse和stringifyJSON对象是ES5中引入的新的类型（支持的浏览器为IE8+），JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串，借助这两个方法，也可以实现对象的深拷贝。 123456789101112131415161718//例1var source = &#123; name:&quot;source&quot;, child:&#123; name:&quot;child&quot; &#125; &#125; var target = JSON.parse(JSON.stringify(source));target.name = &quot;target&quot;; //改变target的name属性console.log(source.name); //source console.log(target.name); //targettarget.child.name = &quot;target child&quot;; //改变target的child console.log(source.child.name); //child console.log(target.child.name); //target child//例2var source = &#123; name:function()&#123;console.log(1);&#125;, child:&#123; name:&quot;child&quot; &#125; &#125; var target = JSON.parse(JSON.stringify(source));console.log(target.name); //undefined//例3var source = &#123; name:function()&#123;console.log(1);&#125;, child:new RegExp(&quot;e&quot;) &#125;var target = JSON.parse(JSON.stringify(source));console.log(target.name); //undefinedconsole.log(target.child); //Object &#123;&#125; 这种方法使用较为简单，可以满足基本的深拷贝需求，而且能够处理JSON格式能表示的所有数据类型，但是对于正则表达式类型、函数类型等无法进行深拷贝(而且会直接丢失相应的值)。还有一点不好的地方是它会抛弃对象的constructor。也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object。同时如果对象中存在循环引用的情况也无法正确处理。 jQuery.extend()方法源码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354jQuery.extend = jQuery.fn.extend = function() &#123; //给jQuery对象和jQuery原型对象都添加了extend扩展方法 var options, name, src, copy, copyIsArray, clone, target = arguments[0] || &#123;&#125;, i = 1, length = arguments.length, deep = false; //以上其中的变量：options是一个缓存变量，用来缓存arguments[i]，name是用来接收将要被扩展对象的key，src改变之前target对象上每个key对应的value。 //copy传入对象上每个key对应的value，copyIsArray判定copy是否为一个数组，clone深拷贝中用来临时存对象或数组的src。 // 处理深拷贝的情况 if (typeof target === &quot;boolean&quot;) &#123; deep = target; target = arguments[1] || &#123;&#125;; //跳过布尔值和目标 i++; &#125; // 控制当target不是object或者function的情况 if (typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction(target)) &#123; target = &#123;&#125;; &#125; // 当参数列表长度等于i的时候，扩展jQuery对象自身。 if (length === i) &#123; target = this; --i; &#125; for (; i &lt; length; i++) &#123; if ((options = arguments[i]) != null) &#123; // 扩展基础对象 for (name in options) &#123; src = target[name]; copy = options[name]; // 防止永无止境的循环，这里举个例子，如var i = &#123;&#125;;i.a = i;$.extend(true,&#123;&#125;,i);如果没有这个判断变成死循环了 if (target === copy) &#123; continue; &#125; if (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) &#123; if (copyIsArray) &#123; copyIsArray = false; clone = src &amp;&amp; jQuery.isArray(src) ? src: []; // 如果src存在且是数组的话就让clone副本等于src否则等于空数组。 &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject(src) ? src: &#123;&#125;; // 如果src存在且是对象的话就让clone副本等于src否则等于空数组。 &#125; // 递归拷贝 target[name] = jQuery.extend(deep, clone, copy); &#125; else if (copy !== undefined) &#123; target[name] = copy; // 若原对象存在name属性，则直接覆盖掉；若不存在，则创建新的属性。 &#125; &#125; &#125; &#125; // 返回修改的对象 return target;&#125;; jQuery的extend方法使用基本的递归思路实现了浅拷贝和深拷贝，但是这个方法也无法处理源对象内部循环引用，例如： 12345var a = &#123;&quot;name&quot;:&quot;aaa&quot;&#125;;var b = &#123;&quot;name&quot;:&quot;bbb&quot;&#125;;a.child = b;b.parent = a;$.extend(true,&#123;&#125;,a);//直接报了栈溢出。Uncaught RangeError: Maximum call stack size exceeded 自己动手实现一个拷贝方法12345678910111213141516171819202122232425262728293031323334353637var $ = (function()&#123; var types = &apos;Array Object String Date RegExp Function Boolean Number Null Undefined&apos;.split(&apos; &apos;); function type() &#123; return Object.prototype.toString.call(this).slice(8, -1); &#125; for (var i = types.length; i--;) &#123; $[&apos;is&apos; + types[i]] = (function (self) &#123; return function (elem) &#123; return type.call(elem) === self; &#125;; &#125;)(types[i]); &#125; return $;&#125;)();//类型判断 function copy(obj,deep)&#123; if(obj === null || (!$.isObject(obj) &amp;&amp; !$.isFunction(obj)))&#123; return obj; &#125; if($.isFunction(obj))&#123; return new Function(&quot;return &quot; + obj.toString())(); &#125;else&#123; var name, target = $.isArray(obj) ? [] : &#123;&#125;, value; for(name in obj)&#123; value = obj[name]; if(value === obj) &#123; continue; &#125; if(deep &amp;&amp; ($.isArray(value) || $.isObject(value)))&#123; target[name] = copy(value,deep); &#125;else&#123; target[name] = value; &#125; &#125; return target; &#125; &#125;]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React高阶组件]]></title>
    <url>%2F2017%2F08%2F02%2Freact%2FReact%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[链接：https://zhuanlan.zhihu.com/p/24776678?group_id=802649040843051008 摘要这篇文章主要面向想要使用 HOC（Higher Order Component，高阶组件） 模式的进阶开发者。如果你是 React 新手，建议你从阅读 React 的文档开始。 高阶组件是一种很好的模式，很多 React 库已经证明了其价值。这篇文章中我们将会详细的讲解什么是 HOC，你能用它做什么，它有哪些局限，如何实现它。 在附录中有一些相关的话题，可能不是 HOC 的核心，但是我认为应该提到。 这篇文章尽量做到详尽无遗，如果你发现任何遗漏的，请提出来，我会做出必要的改动。 这篇文章假设你已经了解 ES6。 让我们开始吧！ 什么是高阶组件？ 高阶组件就是一个 React 组件包裹着另外一个 React 组件 这种模式通常使用函数来实现，基本上是一个类工厂（是的，一个类工厂！），它的函数签名可以用类似 haskell 的伪代码表示 1hocFactory:: W: React.Component =&gt; E: React.Component 其中 W (WrappedComponent) 指被包裹的 React.Component，E (EnhancedComponent) 指返回类型为 React.Component 的新的 HOC。 我们有意模糊了定义中“包裹”的概念，因为它可能会有以下两种不同的含义之一： Props Proxy： HOC 对传给 WrappedComponent W 的 porps 进行操作; Inheritance Inversion： HOC 继承 WrappedComponent W。 （译注：原作者在评论中提到希望对 Props Proxy 和 Inheritance Inversion 不做翻译，故保留原文） 我们会深入地探究这两种模式。 HOC 工厂的实现方法这一节我们将会研究 React 中两种 HOC 的实现方法：Props Proxy (PP) and Inheritance Inversion (II)。两种方法都可以操作 WrappedComponent。 Props ProxyProps Proxy (PP) 的最简实现： 1234567function ppHOC(WrappedComponent) &#123; return class PP extends React.Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125;/&gt; &#125; &#125; &#125; 这里主要是 HOC 在 render 方法中 返回 了一个 WrappedComponent 类型的 React Element。我们还传入了 HOC 接收到的 props，这就是名字 Props Proxy 的由来。 123&lt;WrappedComponent &#123;...this.props&#125;/&gt;// 等价于React.createElement(WrappedComponent, this.props, null) 在 React 内部的一致化处理（reconciliation process）中，两者都创建了一个 React Element 用于渲染。如果你想了解关于 React Elements vs Components ，请看 Dan Abramov 的这篇文章，想了解一致化处理请参考文档。 （译注：一致化处理（reconciliation process）可理解为 React 内部将虚拟 DOM 同步更新到真实 DOM 的过程，包括新旧虚拟 DOM 的比较及计算最小 DOM 操作） 使用 Props Proxy 可以做什么？ 操作 props 通过 Refs 访问到组件实例 提取 state 用其他元素包裹 WrappedComponent 操作 props你可以读取、添加、编辑、删除传给 WrappedComponent 的 props。 当删除或者编辑重要的 props 时要小心，你可能应该通过命名空间（命名空间是什么鬼？）确保高阶组件的 props 不会破坏 WrappedComponent。 例子：添加新的 props。在这个应用中，当前登录的用户可以在 WrappedComponent 中通过 this.props.user 访问到。 12345678910function ppHOC(WrappedComponent) &#123; return class PP extends React.Component &#123; render() &#123; const newProps = &#123; user: currentLoggedInUser &#125; return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125;/&gt; &#125; &#125;&#125; 通过 Refs 访问到组件实例你可以通过引用（ref）访问到 this （WrappedComponent 的实例），但为了得到引用，WrappedComponent 还需要一个初始渲染，意味着你需要在 HOC 的 render 方法中返回 WrappedComponent 元素，让 React 开始它的一致化处理，你就可以得到 WrappedComponent 的实例的引用。 例子：如何通过 refs 访问到实例的方法和实例本身： 123456789101112function refsHOC(WrappedComponent) &#123; return class RefsHOC extends React.Component &#123; proc(wrappedComponentInstance) &#123; wrappedComponentInstance.method() &#125; render() &#123; const props = Object.assign(&#123;&#125;, this.props, &#123;ref: this.proc.bind(this)&#125;) return &lt;WrappedComponent &#123;...props&#125;/&gt; &#125; &#125;&#125; Ref 的回调函数会在 WrappedComponent 渲染时执行，你就可以得到 WrappedComponent 的引用。这可以用来读取/添加实例的 props ，调用实例的方法。 提取 state你可以通过传入 props 和回调函数把 state 提取出来，类似于 smart component 与 dumb component。更多关于 dumb and smart component。 提取 state 的例子：提取了 input 的 value 和 onChange 方法。这个简单的例子不是很常规，但足够说明问题。 1234567891011121314151617181920212223242526function ppHOC(WrappedComponent) &#123; return class PP extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; name: &apos;&apos; &#125; this.onNameChange = this.onNameChange.bind(this) &#125; onNameChange(event) &#123; this.setState(&#123; name: event.target.value &#125;) &#125; render() &#123; const newProps = &#123; name: &#123; value: this.state.name, onChange: this.onNameChange &#125; &#125; return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125;/&gt; &#125; &#125;&#125; 你可以这样用： 123456@ppHOCclass Example extends React.Component &#123; render() &#123; return &lt;input name=&quot;name&quot; &#123;...this.props.name&#125;/&gt; &#125;&#125; 这个 input 会自动成为受控input。 更多关于常规的双向绑定 HOC 请点击 链接 用其他元素包裹 WrappedComponent为了封装样式、布局或别的目的，你可以用其它组件和元素包裹 WrappedComponent。基本方法是使用父组件（附录 B）实现，但通过 HOC 你可以得到更多灵活性。 例子：包裹样式 1234567891011function ppHOC(WrappedComponent) &#123; return class PP extends React.Component &#123; render() &#123; return ( &lt;div style=&#123;&#123;display: &apos;block&apos;&#125;&#125;&gt; &lt;WrappedComponent &#123;...this.props&#125;/&gt; &lt;/div&gt; ) &#125; &#125;&#125; Inheritance InversionInheritance Inversion (II) 的最简实现： 1234567function iiHOC(WrappedComponent) &#123; return class Enhancer extends WrappedComponent &#123; render() &#123; return super.render() &#125; &#125;&#125; 你可以看到，返回的 HOC 类（Enhancer）继承了 WrappedComponent。之所以被称为 Inheritance Inversion 是因为 WrappedComponent 被 Enhancer 继承了，而不是 WrappedComponent 继承了 Enhancer。在这种方式中，它们的关系看上去被反转（inverse）了。 Inheritance Inversion 允许 HOC 通过 this 访问到 WrappedComponent，意味着它可以访问到 state、props、组件生命周期方法和 render 方法。 关于生命周期方法可以用来做什么，我不想细说，因为它是 React 的特性而不是 HOC 的特性。但请注意通过 II 你可以创建新的生命周期方法。为了不破坏 WrappedComponent，记得调用 super.[lifecycleHook]。 一致化处理（Reconciliation process）开始之前我们先理清一些概念。 React 元素决定描述了在 React 执行一致化处理时它要渲染什么。 React 元素有两种类型：字符串和函数。字符串类型的 React 元素代表 DOM 节点，函数类型的 React 元素代表继承 React.Component 的组件。更多关于元素（Element）和组件（Component）请看这篇文章。 函数类型的 React 元素会在一致化处理中被解析成一个完全由字符串类型 React 组件组成的树（而最后的结果永远是 DOM 元素）。 这很重要，意味着 Inheritance Inversion 的高阶组件不一定会解析完整子树 Inheritance Inversion 的高阶组件不一定会解析完整子树 这在学习渲染劫持（Render Highjacking）时非常重要。 你可以用 Inheritance Inversion 做什么？ 渲染劫持（Render Highjacking） 操作 state 渲染劫持之所以被称为渲染劫持是因为 HOC 控制着 WrappedComponent 的渲染输出，可以用它做各种各样的事。 通过渲染劫持你可以： 在由 render输出的任何 React 元素中读取、添加、编辑、删除 props 读取和修改由 render 输出的 React 元素树 有条件地渲染元素树 把样式包裹进元素树（就像在 Props Proxy 中的那样） *render 指 WrappedComponent.render 方法 你不能编辑或添加 WrappedComponent 实例的 props，因为 React 组件不能编辑它接收到的 props，但你可以修改由 render 方法返回的组件的 props。 就像我们刚才学到的，II 类型的 HOC 不一定会解析完整子树，意味着渲染劫持有一些限制。根据经验，使用渲染劫持你可以完全操作 WrappedComponent 的 render 方法返回的元素树。但是如果元素树包括一个函数类型的 React 组件，你就不能操作它的子组件了。（被 React 的一致化处理推迟到了真正渲染到屏幕时） 例1：条件渲染。当 this.props.loggedIn 为 true 时，这个 HOC 会完全渲染 WrappedComponent 的渲染结果。（假设 HOC 接收到了 loggedIn 这个 prop） 1234567891011function iiHOC(WrappedComponent) &#123; return class Enhancer extends WrappedComponent &#123; render() &#123; if (this.props.loggedIn) &#123; return super.render() &#125; else &#123; return null &#125; &#125; &#125;&#125; 例2：修改由 render 方法输出的 React 组件树。 1234567891011121314function iiHOC(WrappedComponent) &#123; return class Enhancer extends WrappedComponent &#123; render() &#123; const elementsTree = super.render() let newProps = &#123;&#125;; if (elementsTree &amp;&amp; elementsTree.type === &apos;input&apos;) &#123; newProps = &#123;value: &apos;may the force be with you&apos;&#125; &#125; const props = Object.assign(&#123;&#125;, elementsTree.props, newProps) const newElementsTree = React.cloneElement(elementsTree, props, elementsTree.props.children) return newElementsTree &#125; &#125;&#125; 在这个例子中，如果 WrappedComponent 的输出在最顶层有一个 input，那么就把它的 value 设为 “may the force be with you”。 你可以在这里做各种各样的事，你可以遍历整个元素树，然后修改元素树中任何元素的 props。这也正是样式处理库 Radium 所用的方法（案例分析一节中有更多关于 Radium 的信息）。 注：在 Props Proxy 中不能做到渲染劫持。 虽然通过 WrappedComponent.prototype.render 你可以访问到 render 方法，不过还需要模拟 WrappedComponent 的实例和它的 props，还可能亲自处理组件的生命周期，而不是交给 React。根据我的实验，这么做不值，你要是想做到渲染劫持你应该用 Inheritance Inversion 而不是 Props Proxy。记住，React 在内部处理了组件实例，你处理实例的唯一方法是通过 this 或者 refs。 操作 stateHOC 可以读取、编辑和删除 WrappedComponent 实例的 state，如果你需要，你也可以给它添加更多的 state。记住，这会搞乱 WrappedComponent 的 state，导致你可能会破坏某些东西。要限制 HOC 读取或添加 state，添加 state 时应该放在单独的命名空间里，而不是和 WrappedComponent 的 state 混在一起。 例子：通过访问 WrappedComponent 的 props 和 state 来做调试。 1234567891011121314export function IIHOCDEBUGGER(WrappedComponent) &#123; return class II extends WrappedComponent &#123; render() &#123; return ( &lt;div&gt; &lt;h2&gt;HOC Debugger Component&lt;/h2&gt; &lt;p&gt;Props&lt;/p&gt; &lt;pre&gt;&#123;JSON.stringify(this.props, null, 2)&#125;&lt;/pre&gt; &lt;p&gt;State&lt;/p&gt;&lt;pre&gt;&#123;JSON.stringify(this.state, null, 2)&#125;&lt;/pre&gt; &#123;super.render()&#125; &lt;/div&gt; ) &#125; &#125;&#125; 这里 HOC 用其他元素包裹着 WrappedComponent，还输出了 WrappedComponent 实例的 props 和 state。JSON.stringify 的小技巧是由 Ryan Florence 和 Michael Jackson 教我的。这个调试器完整的实现在这里。 命名用 HOC 包裹了一个组件会使它失去原本 WrappedComponent 的名字，可能会影响开发和调试。 通常会用 WrappedComponent 的名字加上一些 前缀作为 HOC 的名字。下面的代码来自 React-Redux： 12345678HOC.displayName = `HOC($&#123;getDisplayName(WrappedComponent)&#125;)`//或class HOC extends ... &#123; static displayName = `HOC($&#123;getDisplayName(WrappedComponent)&#125;)` ...&#125; getDisplayName 函数： 12345function getDisplayName(WrappedComponent) &#123; return WrappedComponent.displayName || WrappedComponent.name || ‘Component’&#125; 实际上你不用自己写，recompose 提供了这个函数。]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react文档-css动画]]></title>
    <url>%2F2017%2F08%2F02%2Freact%2Freact%E6%96%87%E6%A1%A3-css%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[TransitionGroup和CSSTransitionGroup已移动到react-transition-group有社区维护。它的1.x分支与现有插件的API是完全兼容的。 TransitionGroup是一个具有低级API的动画组件，而CSSTransitionGroup是一个基于css的animation和transition更容易被使用的组件。 高级API：CSSTransitionGroup123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import &#123; CSSTransitionGroup &#125; from &apos;react-transition-group&apos; // ES6var CSSTransitionGroup = require(&apos;react-transition-group/CSSTransitionGroup&apos;) // ES5 with npmclass TodoList extends React.Component&#123; constructor()&#123; super(); this.state = &#123; items: [ &apos;hello&apos;, &apos;world&apos;, &apos;click&apos;, &apos;me&apos; ] &#125;; this.handleAdd = this.handleAdd.bind(this); &#125; handleAdd() &#123; const newItems = this.state.items.concat([ prompt(&apos;Enter some text&apos;) ]); this.setState(&#123;items: newItems&#125;); &#125; handleRemove(i) &#123; let newItems = this.state.items.slice(); newItems.splice(i, 1); this.setState(&#123;items: newItems&#125;); &#125; render()&#123; const items = this.state.items.map((item, i) =&gt; ( &lt;div key=&#123;i&#125; onClick=&#123;() =&gt; this.handleRemove(i)&#125;&gt; &#123;item&#125; &lt;/div&gt; )); return ( &lt;div&gt; &lt;button type=&quot;button&quot; onClick=&#123;this.handleAdd&#125;&gt;Add Item&lt;/button&gt; &lt;CSSTransitionGroup transitionName=&quot;example&quot; transitionEnterTimeout=&#123;500&#125; transitionLeaveTimeout=&#123;300&#125; &gt; &#123;items&#125; &lt;/CSSTransitionGroup&gt; &lt;/div&gt; ); &#125;&#125; 在这个组件中，当一个新的Item被添加时，ReactCSSTransitionGroup将获得一个example-enter的类和example-enter-active的类，这些类名是基于trnasitionName的值。 您可以使用这些类来触发css动画或转换。例如：尝试添加如下样式： 1234567891011121314.example-enter&#123; opacity: 0.01;&#125;.example-enter.example-enter-active&#123; opacity: 1; transition: opacity 500ms ease-in;&#125;.example-leave&#123; opacity: 1;&#125;.example-leavel.example-leavel-active&#123; opacity: 0.01; transition: opacity 300ms ease-in;&#125; 初始化加载动画ReactCSSTransitionGroup提供一个可选的属性transitionAppear，以在组件的初始渲染时添加额外的过渡阶段。默认为false： 123456789101112render() &#123; return ( &lt;CSSTransitionGroup transitionName=&quot;example&quot; transitionAppear=&#123;true&#125; transitionAppearTimeout=&#123;500&#125; transitionEnter=&#123;false&#125; transitionLeave=&#123;false&#125;&gt; &lt;h1&gt;Fading at Initial Mount&lt;/h1&gt; &lt;/CSSTransitionGroup&gt; );&#125; 在初始化渲染ReactCSSTransitionGroup过程中，example-appear类和example-appear-active类将被添加。 1234567.example-appear &#123; opacity: 0.01;&#125;.example-appear.example-appear-active &#123; opacity: 1; transition: opacity .5s ease-in;&#125; 在初始化渲染阶段，所有ReactCSSTransitionGroup的孩子节点将会appear而不是enter，然而，所有孩子稍后被渲染后将会触发enter而不是appear。 注意： 属性transitionAppear在0.13版本中才被添加进入ReactCSSTransitionGroup中，为了向后兼容，默认值为false。 然而，transitionEnter和transtionLeave默认为true，所以你默认只要指定transitionEnterTimeout和transitionLeaveTimeout。 自定义类名当然，我们也可以使用自定义类名代替每一步默认的类名。你可以通过传递一个包含enter或leave或appear等等的对象给transitionName而不是字符串。 如果未提供active时，默认会为添加-active后的类名： 12345678910111213141516171819202122&lt;CSSTransitionGroup transitionName=&#123; &#123; enter: &apos;enter&apos;, enterActive: &apos;enterActive&apos;, leave: &apos;leave&apos;, leaveActive: &apos;leaveActive&apos;, appear: &apos;appear&apos;, appearActive: &apos;appearActive&apos; &#125; &#125;&gt;&#123;item&#125;&lt;/CSSTransitionGroup&gt;&lt;CSSTransitionGroup transitionName=&#123; &#123; enter: &apos;enter&apos;, leave: &apos;leave&apos;, appear: &apos;appear&apos; &#125; &#125;&gt; &#123;item2&#125;&lt;/CSSTransitionGroup&gt; 动画组必须已经被渲染到DOM为了时其子节点的动画能够生效，ReactCSSTransitionGroup必须已经被加载进DOM中，或者transitionAppear必须为true。 下面的例子将不会正常运行，因为ReactCSSTransitionGroup被和新的item一起渲染，而不是新的item渲染进其子节点： 123456789101112131415render() &#123; const items = this.state.items.map((item, i) =&gt; ( &lt;div key=&#123;item&#125; onClick=&#123;() =&gt; this.handleRemove(i)&#125;&gt; &lt;CSSTransitionGroup transitionName=&quot;example&quot;&gt; &#123;item&#125; &lt;/CSSTransitionGroup&gt; &lt;/div&gt; )); return ( &lt;div&gt; &lt;button onClick=&#123;this.handleAdd&#125;&gt;Add Item&lt;/button&gt; &#123;items&#125; &lt;/div&gt; );&#125; 渲染一个或零个子节点在上面的例子中，我们渲染了一个列表节点，当然，ReactCSSTransitionGroup也可以渲染一个或零个节点： 12345678910111213import ReactCSSTransitionGroup from &apos;react-addons-css-transition-group&apos;;function ImageCarousel(props) &#123; return ( &lt;div&gt; &lt;CSSTransitionGroup transitionName=&quot;carousel&quot; transitionEnterTimeout=&#123;300&#125; transitionLeaveTimeout=&#123;300&#125;&gt; &lt;img src=&#123;props.imageSrc&#125; key=&#123;props.imageSrc&#125; /&gt; &lt;/CSSTransitionGroup&gt; &lt;/div&gt; );&#125; 禁用动画可以通过设置false来禁用指定阶段，如：transitionEnter为false禁用进入后的动画效果。 注意：使用ReactCSSTransitionGroup你没办法知道一个transition已经结束或其他更详细的细节，如果你需要，则得使用低级APIReactTransitionGroup，它提供更多的钩子让你能够监听。 低级API：TransitionGroup12import TransitionGroup from &apos;react-transition-group/TransitionGroup&apos; // ES6var TransitionGroup = require(&apos;react-transition-group/TransitionGroup&apos;) // ES5 with npm ReactTransitionGroup是动画的基础。当子节点添加或删除，下面这些钩子函数将会被调用： componentWillAppear(callback) 这个方法将在渲染到节点时调用，它将阻塞其他当前正在发生的动画，知道callback被调用。这个方法仅仅在初始化渲染TransitionGroup时被调用。 componentDidAppear() 这个方法将在componentWillAppear的callback被调用后被调用。 componentWillEnter(callback) 当有新元素被添加到TransitionGroup时调用，它将会阻塞其他动画知道callback调用。 componentDidEnter() 在componentWillEnter的callback调用后触发。 componentWillLeave(callback) 当有元素被移除时触发，尽管元素已经被删除，但它还是还将保留在DOM中，直到callback被调用。 componentDidLeave() 在componentWillLeave的callback被调用时触发（和componentWillUnmount()同时触发）。 渲染其他组件TransitionGroup默认渲染为一个span，你通过增加一个compoennt属性改变默认行为： 123&lt;TransitionGroup component=&quot;ul&quot;&gt; &#123;/*...*/&#125;&lt;/TranstionGroup&gt; 另外，用户自定义的属性也会对应增加到组件的属性，如下例子，ul也将会得到className属性： 123&lt;TransitionGroup component=&quot;ul&quot; className=&quot;animated-list&quot;&gt; &#123;/* ... */&#125;&lt;/TransitionGroup&gt; 所有react可以渲染的组件都可以成为component，它不是必须为一个DOM节点，如：component={CustomList}，那么，TransitionGroup的子节点传递给CustomList组件的属性this.props.children。 渲染单独的子节点我们经常会用TransitionGroup来作为单独子节点的渲染和移除时的效果，诸如手风琴效果的面板。 正常情况下，TransitionGroup把其子节点包裹在一个span（或者自定义的component中），这是因为react的render函数必须返回单独子节点，但是TransitionGroup并不需要这样的规则。 然而，如果你需要只渲染一个单独子节点，你可以通过定义一个只渲染第一个子节点的组件： 1234function FirstChild(props) &#123; const childrenArray = React.Children.toArray(props.children); return childrenArray[0] || null;&#125; 现在你可以指定TransitionGroup的component属性为FirstChild来避免包裹外层组件： 123&lt;TransitionGroup component=&#123;FirstChild&#125;&gt; &#123;someCondition ? &lt;MyComponent /&gt; : null&#125;&lt;/TransitionGroup&gt; 这仅仅在你只想要渲染一个子节点时有用，在需要渲染多个节点时没有效果。]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flexbox布局兼容性总结]]></title>
    <url>%2F2017%2F08%2F02%2Fcss%2FFlexbox%E5%B8%83%E5%B1%80%E5%85%BC%E5%AE%B9%E6%80%A7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[写在前面IE9不支持…试了一下flexibility库，发现支持还好，就是嵌套的时候会有问题，因为它是通过定位的方式，暂时无解…… 入门教程传送门 W3C各个版本的flex 2009 version标志：display: box; or a property that is box-{*} (eg. box-pack) 2011 version标志：display: flexbox; or the flex() function or flex-pack property 2012 version标志：display: flex/inline-flex; and flex-{*} properties 2014 version新增了对flex项z-index的规定 2015 W3C Editor’s Draft没有大的改动 P.S.注意2015的是W3C Editor’s Draft，只是个草案，还处于修修改改的阶段，还没有征集浏览器供应商的意见。 浏览器兼容性关于flex的W3C规范： http://dev.w3.org/csswg/css-flexbox-1/ 浏览器兼容性可以参考CanIUse： http://caniuse.com/#feat=flexbox 根据CanIUse的数据可以总结如下： IE10部分支持2012，需要-ms-前缀 Android4.1/4.2-4.3部分支持2009 ，需要-webkit-前缀 Safari7/7.1/8部分支持2012， 需要-webkit-前缀 IOS Safari7.0-7.1/8.1-8.3部分支持2012，需要-webkit-前缀 所以需要考虑新版本2012： http://www.w3.org/TR/2012/CR-css3-flexbox-20120918/ 而Android需要考虑旧版本2009： http://www.w3.org/TR/2009/WD-css3-flexbox-20090723/ 浏览器兼容的flex语法上面分析得很清楚，针对需要兼容的目标使用对应版本的语法就好了，下面给出常用的布局代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/* 子元素-平均分栏 */.flex1 &#123; -webkit-box-flex: 1; /* OLD - iOS 6-, Safari 3.1-6 */ -moz-box-flex: 1; /* OLD - Firefox 19- */ width: 20%; /* For old syntax, otherwise collapses. */ -webkit-flex: 1; /* Chrome */ -ms-flex: 1; /* IE 10 */ flex: 1; /* NEW, Spec - Opera 12.1, Firefox 20+ */&#125;/* 父元素-横向排列（主轴） */.flex-h &#123; display: box; /* OLD - Android 4.4- */ display: -webkit-box; /* OLD - iOS 6-, Safari 3.1-6 */ display: -moz-box; /* OLD - Firefox 19- (buggy but mostly works) */ display: -ms-flexbox; /* TWEENER - IE 10 */ display: -webkit-flex; /* NEW - Chrome */ display: flex; /* NEW, Spec - Opera 12.1, Firefox 20+ */ /* 09版 */ -webkit-box-orient: horizontal; /* 12版 */ -webkit-flex-direction: row; -moz-flex-direction: row; -ms-flex-direction: row; -o-flex-direction: row; flex-direction: row;&#125;/* 父元素-横向换行 */.flex-hw &#123; /* 09版 */ /*-webkit-box-lines: multiple;*/ /* 12版 */ -webkit-flex-wrap: wrap; -moz-flex-wrap: wrap; -ms-flex-wrap: wrap; -o-flex-wrap: wrap; flex-wrap: wrap;&#125;/* 父元素-水平居中（主轴是横向才生效） */.flex-hc &#123; /* 09版 */ -webkit-box-pack: center; /* 12版 */ -webkit-justify-content: center; -moz-justify-content: center; -ms-justify-content: center; -o-justify-content: center; justify-content: center; /* 其它取值如下： align-items 主轴原点方向对齐 flex-end 主轴延伸方向对齐 space-between 等间距排列，首尾不留白 space-around 等间距排列，首尾留白 */&#125;/* 父元素-纵向排列（主轴） */.flex-v &#123; display: box; /* OLD - Android 4.4- */ display: -webkit-box; /* OLD - iOS 6-, Safari 3.1-6 */ display: -moz-box; /* OLD - Firefox 19- (buggy but mostly works) */ display: -ms-flexbox; /* TWEENER - IE 10 */ display: -webkit-flex; /* NEW - Chrome */ display: flex; /* NEW, Spec - Opera 12.1, Firefox 20+ */ /* 09版 */ -webkit-box-orient: vertical; /* 12版 */ -webkit-flex-direction: column; -moz-flex-direction: column; -ms-flex-direction: column; -o-flex-direction: column; flex-direction: column;&#125;/* 父元素-纵向换行 */.flex-vw &#123; /* 09版 */ /*-webkit-box-lines: multiple;*/ /* 12版 */ -webkit-flex-wrap: wrap; -moz-flex-wrap: wrap; -ms-flex-wrap: wrap; -o-flex-wrap: wrap; flex-wrap: wrap;&#125;/* 父元素-竖直居中（主轴是横向才生效） */.flex-vc &#123; /* 09版 */ -webkit-box-align: center; /* 12版 */ -webkit-align-items: center; -moz-align-items: center; -ms-align-items: center; -o-align-items: center; align-items: center;&#125;/* 子元素-显示在从左向右（从上向下）第1个位置，用于改变源文档顺序显示 */.flex-1 &#123; -webkit-box-ordinal-group: 1; /* OLD - iOS 6-, Safari 3.1-6 */ -moz-box-ordinal-group: 1; /* OLD - Firefox 19- */ -ms-flex-order: 1; /* TWEENER - IE 10 */ -webkit-order: 1; /* NEW - Chrome */ order: 1; /* NEW, Spec - Opera 12.1, Firefox 20+ */&#125;/* 子元素-显示在从左向右（从上向下）第2个位置，用于改变源文档顺序显示 */.flex-2 &#123; -webkit-box-ordinal-group: 2; /* OLD - iOS 6-, Safari 3.1-6 */ -moz-box-ordinal-group: 2; /* OLD - Firefox 19- */ -ms-flex-order: 2; /* TWEENER - IE 10 */ -webkit-order: 2; /* NEW - Chrome */ order: 2; /* NEW, Spec - Opera 12.1, Firefox 20+ */&#125;为了更好的兼容性，我们需要给容器声明flex-h/flex-v，而不是一般的flex：/* 父元素-flex容器 */.flex &#123; display: box; /* OLD - Android 4.4- */ display: -webkit-box; /* OLD - iOS 6-, Safari 3.1-6 */ display: -moz-box; /* OLD - Firefox 19- (buggy but mostly works) */ display: -ms-flexbox; /* TWEENER - IE 10 */ display: -webkit-flex; /* NEW - Chrome */ display: flex; /* NEW, Spec - Opera 12.1, Firefox 20+ */&#125; 所以，建议在需要兼容Android时（2009版语法）采用flex-h/flex-v声明容器使用flex模式，在不需要兼容Android时（2012版语法）使用flex设置容器 注意：上面给的代码并不是完全兼容各个高端浏览器的，但要比任何其它现有代码兼容性好，具体兼容性测试结果请看Demo sass定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107@mixin flex&#123; display: box; /* old - Android 4.4- */ display: -webkit-box; /* old - IOS 6-, Safari 3.1-6 */ display: -moz-box; /* old - Firefox 19 - (buggy but most works) */ display: -ms-flexbox; /* IE 10 */ display: -webkit-flex; /* New - Chrome */ display: flex; -js-display: flex;&#125;@mixin flexDirection($type: row)&#123; /* 09版 */ @if $type == &apos;row&apos;&#123; -webkit-box-orient: horizontal; &#125;@else if $type == &apos;row-reverse&apos;&#123; -webkit-box-orient: horizontal; &#125;@else if $type == &apos;column&apos;&#123; -webkit-box-orient: vertical; &#125;@else if $type == &apos;column-reverse&apos;&#123; -webkit-box-orient: vertical; &#125; /* 12版 */ -webkit-flex-direction: $type; -moz-flex-direction: $type; -ms-flex-direction: $type; -o-flex-direction: $type; flex-direction: $type; -js-flex-direction: $type;&#125;@mixin flexWrap($type: nowrap)&#123; /* 09版 */ /*-webkit-box-lines: multiple;*/ /* 12版 */ -webkit-flex-wrap: $type; -moz-flex-wrap: $type; -ms-flex-wrap: $type; -o-flex-wrap: $type; flex-wrap: $type; -js-flex-wrap: $type;&#125;@mixin justifyContent($type: flex-start)&#123; /* 09版 */ //-webkit-box-pack: justify; /* 12版 */ -webkit-justify-content: $type; -moz-justify-content: $type; -ms-justify-content: $type; -o-justify-content: $type; justify-content: $type; /* 其它取值如下： align-items 主轴原点方向对齐 flex-end 主轴延伸方向对齐 space-between 等间距排列，首尾不留白 space-around 等间距排列，首尾留白 */ -js-justify-content: $type;&#125;@mixin alignItems($type: stretch)&#123; /* 09版 */ //-webkit-box-align: center; /* 12版 */ -webkit-align-items: $type; -moz-align-items: $type; -ms-align-items: $type; -o-align-items: $type; align-items: $type; -js-align-items: $type;&#125;@mixin alignContent($type: stretch)&#123; /* 09版 */ //-webkit-box-align: center; /* 12版 */ -webkit-align-content: $type; -moz-align-content: $type; -ms-align-content: $type; -o-align-content: $type; align-content: $type; -js-align-content: $type;&#125;@mixin flexOrder($val: 0)&#123; -webkit-box-ordinal-group: $val; /* OLD - iOS 6-, Safari 3.1-6 */ -moz-box-ordinal-group: $val; /* OLD - Firefox 19- */ -ms-flex-order: $val; /* TWEENER - IE 10 */ -webkit-order: $val; /* NEW - Chrome */ order: $val; /* NEW, Spec - Opera 12.1, Firefox 20+ */ -js-order: $val;&#125;@mixin flexGrow($val: 0)&#123; -webkit-box-flex-grow: $val; /* OLD - iOS 6-, Safari 3.1-6 */ -moz-box-flex-grow: $val; /* OLD - Firefox 19- */ -webkit-flex-grow: $val; /* Chrome */ -ms-flex-grow: $val; /* IE 10 */ flex-grow: $val; /* NEW, Spec - Opera 12.1, Firefox 20+ */ -js-flex-grow: $val;&#125;@mixin flexShrink($val: 1)&#123; -webkit-box-flex-shrink: $val; /* OLD - iOS 6-, Safari 3.1-6 */ -moz-box-flex-shrink: $val; /* OLD - Firefox 19- */ -webkit-flex-shrink: $val; /* Chrome */ -ms-flex-shrink: $val; /* IE 10 */ flex-shrink: $val; /* NEW, Spec - Opera 12.1, Firefox 20+ */ -js-flex-shrink: $val;&#125;//横向.#&#123;$namespace&#125;flex-h&#123; @include flex(); @include flexDirection();&#125;]]></content>
      <tags>
        <tag>css</tag>
        <tag>flexbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于同一元素下dbClick触发两次click的问题]]></title>
    <url>%2F2017%2F08%2F02%2Fjavascript%2F%E5%85%B3%E4%BA%8E%E5%90%8C%E4%B8%80%E5%85%83%E7%B4%A0%E4%B8%8BdbClick%E8%A7%A6%E5%8F%91%E4%B8%A4%E6%AC%A1click%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题将处理程序绑定到相同元素的click和dblclick事件是不合适的。 触发的事件顺序因浏览器而异，有些在dblclick之前接收到两个点击事件，而其他事件只有一个。 双击灵敏度（双击检测到的点击之间的最大时间）可能因操作系统和浏览器而异，并且通常是用户可配置的。 所以最好不要在同一个元素下绑定click和dbclick事件。 解决方法方法一： 12345678910111213141516var v_Result; function OneClick(event) &#123; console.log(&quot;detail&quot;,event.detail); //if (event.detail == 2) // return ; v_Result = false; window.setTimeout(check, 300); function check() &#123; if (v_Result != false) return; console.log(&quot;单击&quot;); &#125; &#125; function TwoClick() &#123; v_Result = true; console.log(&quot;双击&quot;); &#125; 方法二： 123456789101112131415161718192021222324252627var clickTimer = null; function _click() &#123; if (clickTimer) &#123; console.log(&quot;clearTimeout&quot;, clickTimer); window.clearTimeout(clickTimer); clickTimer = null; &#125; clickTimer = window.setTimeout(function() &#123; // your click process code here console.log(&quot;你单击了我&quot;); &#125;, 300); console.log(&quot;setTimeout&quot;, clickTimer); &#125; function _dblclick() &#123; console.log(&quot;dblclick&quot;); if (clickTimer) &#123; console.log(&quot;=clearTimeout&quot;, clickTimer); window.clearTimeout(clickTimer); clickTimer = null; &#125; // your click process code here console.log(&quot;你双击了我&quot;); &#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6的坑]]></title>
    <url>%2F2017%2F08%2F02%2Fjavascript%2FES6%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[IE8下用babel转换会报错： function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; } 解决方法： $ npm install --save-dev babel-plugin-transform-es2015-modules-simple-commonjs 配置： //webpack.config.js &quot;plugins&quot;: [&quot;transform-es2015-modules-simple-commonjs&quot;] ES6 + angular1 + webpack，遇到controller文件里的constructor运行2次？ 那是因为声明了2次controller，在配置中配了app.controller(&#39;MyController&#39;)，然后又在页面中使用了ng-controller，导致运行了2次，坑爹~ Babel转ES5后IE8下的兼容性解决方法。 1)webpack配置文件，增加插件transform-es3-property-literals和transform-es3-member-expression-literals const webpackdevConfig = { entry: entry, output: { path: path.join(__dirname, &apos;dist/js&apos;), filename: &apos;[name].js&apos;, publicPath: &apos;/static/&apos; }, plugins: [ new webpack.NoErrorsPlugin(), ], module: { loaders: [ { test: /\.js$/, loader: [&apos;babel&apos;], include: [path.join(new_dir, &apos;src&apos;)], query:{ &quot;presets&quot;: [&quot;es2015&quot;, &quot;stage-0&quot;], &quot;plugins&quot; : [ &quot;transform-es3-property-literals&quot;, &quot;transform-es3-member-expression-literals&quot;, ] } }, {test: /\.scss$/, loaders: [&apos;style&apos;, &apos;css&apos;, &apos;sass&apos;], include: path.join(new_dir, &apos;src/style&apos;)}, {test: /\.(jpg|png)$/, loader: &apos;url-loader?limit=8192&apos;, include: path.join(new_dir, &apos;src/img&apos;)} ] } } 2)模块导出不能使用 export default ，改为export { xxx } 3)模块引入使用 import { } from ‘xxx’ 4)引入es5-shim.min.js和es5-sham.min.js]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React要手动绑定方法的原因]]></title>
    <url>%2F2017%2F08%2F02%2Freact%2FReact%E8%A6%81%E6%89%8B%E5%8A%A8%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%E7%9A%84%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[我们从javascript开始吧在js中，函数的上下文是指函数调用的时候，而不是定义的时候。 有以下四中调用函数的模式： 函数调用模式 方法调用模式 构造函数调用模式 应用调用模式 所有这些使用的模式都不同地定义函数上下文。接下来我们看看各种模式的区别。 函数调用模式定义：如果在调用时没有.操作，那么上下文可能为window。 调用函数最直接的方法就是直接调用它： 1234var func = function()&#123; //...&#125;;func(); 这时的上下文（this）将会设置成javascript操作环境的全局变量，在浏览器中，它是window变量。 我们再来看另一个例子： 12345var unicorns = &#123; func: function() &#123; // ... &#125;&#125;;var fun = unicorns.func;fun(); 你认为在func中的上下文为uniconrns对象？那是错误的，由于上下文时通过调用此函数时确定的，所以这里的上下文还是window。 方法调用模式定义：如果函数调用中有点操作，则上下文将会是一序列点中最右边的那个变量。 如上面的例子中，如果我们直接调用unicorns.func()，上下文会是unicorns对象。 123456789var frog = &#123; RUN_SOUND: &quot;POP!!&quot;, run: function() &#123; return this.RUN_SOUND; &#125;&#125;;frog.run(); // returns &quot;POP!!&quot; since this points to the `frog` object.var runningFun = frog.run;runningFun(); // returns &quot;undefined&quot; since this points to the window 构造函数模式定义：每次看到一个new函数名后，你this将指向一个新创建的新对象。 123function Wizard() &#123; this.castSpell = function() &#123; return &quot;KABOOM&quot;; &#125;&#125; 直接调用它将会是window（因为它是一个函数调用），但是如果通过new来调用： 12345function Wizard() &#123; this.castSpell = function() &#123; return &quot;KABOOM&quot;; &#125;;&#125;var merlin = new Wizard(); // this is set to an empty object &#123;&#125;. Returns `this` implicitly.merlin.castSpell() // returns &quot;KABOOM&quot;; 这将会发生两件事： 函数将会有一个指向当前对象的上下文this。 如果没有指定return或者这个函数返回一个非对象值，this将从这个函数返回。 应用调用模式当你对函数有引用的时候，你可以通过两种方法来手动提供上下文： call apply 1234567function addAndSetX(a, b) &#123; this.x += a + b;&#125;var obj1 = &#123; x: 1, y: 2 &#125;;addAndSetX.call(obj1, 1, 1); // this = obj1, obj1 after call = &#123; x: 3, y : 2 &#125;// It is the same as:// addAndSetX.apply(obj1, [1, 1]); 如果您需要调用从某个其他地方传递的函数（例如，作为参数到函数中）与某个上下文对象，这是非常方便的。它不是非常可用于异步回调，因为绑定与一个函数调用相结合。 要使用回调设置正确的上下文，您可能需要另一种方便的技术 - 您可以从中创建有界函数。 绑定功能有界函数是一个限定给定上下文的函数，这意味着无论你怎么调用它，它的上下文都是不变的。唯一例外是总是返回一个新上下文的new运算符。 要是普通函数变成有界函数，应该使用bind方法，bind方法将您要将函数绑定到的上下文作为第一个参数。其余的参数是将始终传递给这样的函数的参数。 结果返回有界函数。我们来看一个例子： 12345678910function add(x, y) &#123; this.result += x + y;&#125;var computation1 = &#123; result: 0 &#125;;var boundedAdd = add.bind(computation1);boundedAdd(1, 2); // `this` is set to `computation1`. // computation1 after call: &#123; result: 3 &#125;var boundedAddPlusTwo = add.bind(computation1, 2);boundedAddPlusTwo(4); // `this` is set to `computation1`. // computation1 after call: &#123; result: 9 &#125; 被绑定了的函数甚至不能在通过call或apply改变上下文： 123456789var obj = &#123; boundedPlusTwo: boundedAddPlusTwo &#125;;obj.boundedPlusTwo(4); // `this` is set to `computation1`. // even though method is called on `obj`. // computation1 after call: &#123; result: 15 &#125;var computation2 = &#123; result: 0 &#125;;boundedAdd.call(computation2, 1, 2); // `this` is set to `computation1`. // even though context passed to call is // `computation2` // computation1 after call: &#123; result: 18 &#125; 您现在已经掌握了关于JavaScript的知识，现在让我们来看react中的情况。 怎么绑定以及绑定什么ECMAScript 2015（ECMAScript 6）引入了一种新的类语法，可用于创建React组件类。实际上，这个类语法是面向对象JavaScript 的旧的原型系统的语法糖。 这意味着ES2015类中的函数上下文调用遵循与其余JavaScript相同的原则。 123456789101112class Foo &#123; constructor() &#123; this.x = 2; this.y = 4; &#125; bar() &#123; // ... &#125; baz() &#123; // ... &#125;&#125; 与以下大致相同： 123456function Foo() &#123; this.x = 2; this.y = 4; this.bar = function() &#123; // ... &#125;; this.baz = function() &#123; // ... &#125;;&#125; 记住这只是一个简化。在确定函数上下文调用的情况下，这个更复杂的逻辑遵循与上面的代码片段相同的原理。 React.createClass在这个语法下，绑定问题是不存在的，在传递给对象的对象中定义的所有方法React.createClass将自动绑定到组件实例。这意味着你可以随时使用setState，访问props和state等等这些方法。 尽管在99％的情况下可能完全可以接受，但它限制了您对任意设置上下文的能力 - 这可能是更复杂的代码库中的一个大问题。 ECMAScript 2015 classes在ECMAScript 2015 classes写法中，你需要手动绑定方法。 以下是React库中是可以识别为方法调用模式执行调用： 组件生命周期方法。它仅仅通过component.componentDidUpdate(…)方式调用（因此，this已经正确绑定到组件实例本身）。 render方法。它也是被识别为方法调用模式执行调用。大多数的非事件处理函数在render方法中调用，它已经被自动绑定到组件实例，所以你可以放心使用。 但是，传递给事件处理属性的函数可能有许多来源，甚至可能通过顶级组件的属性从非React级别传递给他们。 在React.createClassReact假定它们来自您的组件并自动绑定它们。但是在ES2015 classes中你有自由。在引擎中，它们被以函数调用模式调用。 这意味这，在默认情况下，你无法在事件处理程序中读取组件属性、状态和组件的方法，为此，你需要明确地绑定他们。 绑定事件处理程序的最佳位置是构造函数： 1234567891011121314class InputExample extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; text: &apos;&apos; &#125;; this.change = this.change.bind(this); &#125; change(ev) &#123; this.setState(&#123; text: ev.target.value &#125;); &#125; render() &#123; let &#123; text &#125; = this.state; return (&lt;input type=&quot;text&quot; value=&#123;text&#125; onChange=&#123;this.change&#125; /&gt;); &#125;&#125; 这样你的事件处理程序的上下文将会绑定到组件实例中。 类属性有一个实验功能，称为类属性，可以帮助您明确避免绑定方法。它是用于在构造函数中定义字段和函数的语法糖。看起来像这样： 1234class InputExample extends React.Component &#123; state = &#123; text: &apos;&apos; &#125;; // ...&#125; 并编译成以下： 1234567class InputExample extends React.Component &#123; constructor(...arguments) &#123; super(...arguments); this.state = &#123; text: &apos;&apos; &#125;; &#125; // ...&#125; 那么怎么定义一个方法呢？ 1234567class InputExample extends React.Component &#123; state = &#123; text: &apos;&apos; &#125;; change = function(ev) &#123; this.setState(&#123; text: ev.target.value &#125;); &#125;; // ...&#125; 所以现在，你得到一个等同于以下类： 12345678910class InputExample extends React.Component &#123; constructor(...arguments) &#123; super(...arguments); this.state = &#123; text: &apos;&apos; &#125;; this.change = function(ev) &#123; this.setState(&#123; text: ev.target.value &#125;); &#125;; &#125; // ...&#125; 但是这样有一个问题，this.change函数上下文还是错误的，所以我们要结合箭头函数： 12345678class InputExample extends React.Component &#123; state = &#123; text: &apos;&apos; &#125;; change = ev =&gt; this.setState(&#123;text: ev.target.value&#125;); render() &#123; let &#123;text&#125; = this.state; return (&lt;input type=&quot;text&quot; value=&#123;text&#125; onChange=&#123;this.change&#125; /&gt;); &#125;&#125; 该解决方案的缺点是类属性仍处于实验阶段。这意味着此功能可以在ECMAScript 2016（也称为ECMAScript 7或ES7）的后续迭代中被删除，而不会发出警告。 createClass以及class语法编译完的不同我们先来看类写法： 12345678910111213141516class Todo extends Component&#123; handleClick()&#123; console.info(this); &#125; method()&#123; console.info(this); &#125; render()&#123; this.method(); return ( &lt;div&gt; &lt;p onClick=&#123;this.handleClick&#125;&gt;Hello&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; 编译完： 1234567891011121314151617181920212223242526var Todo = function (_Component) &#123; _inherits(Todo, _Component); function Todo() &#123; _classCallCheck(this, Todo); return _possibleConstructorReturn(this, _Component.apply(this, arguments)); &#125; Todo.prototype.handleClick = function handleClick() &#123; console.info(this); &#125;; Todo.prototype.method = function method() &#123; console.info(this); &#125;; Todo.prototype.render = function render() &#123; this.method(); return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement( &apos;div&apos;, null, __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement( &apos;p&apos;, &#123; onClick: this.handleClick &#125;, &apos;Hello&apos; ) ); &#125;; return Todo;&#125;(__WEBPACK_IMPORTED_MODULE_0_react__[&quot;Component&quot;]); this.handleClick被放在{onClick: this.handleClick}中，所以当被调用的时候会被识别为函数调用模式，所以这时的上下文是null（为什么不是window或其他的？？？）]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React获取父组件或子组件属性]]></title>
    <url>%2F2017%2F08%2F02%2Freact%2Freact%E8%8E%B7%E5%8F%96%E7%88%B6%E7%BB%84%E4%BB%B6%E6%88%96%E5%AD%90%E7%BB%84%E4%BB%B6%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[获取子组件的方法可以通过递归this.props.children中得到 获取父组件的方法方法一：可以通过react内部私有函数this._reactInternalInstance._currentElement._owner._instance获取 12345678910111213141516171819var Parent = React.createClass(&#123; render() &#123; return &lt;Child v=&quot;test&quot; /&gt;; &#125;, doAThing() &#123; console.log(&quot;I&apos;m the parent, doing a thing.&quot;, this.props.testing); &#125;&#125;);var Child = React.createClass(&#123; render() &#123; return &lt;button onClick=&#123;this.onClick&#125;&gt;&#123;this.props.v&#125;&lt;/button&gt; &#125;, onClick() &#123; var parent = this._reactInternalInstance._currentElement._owner._instance; console.log(&quot;parent:&quot;, parent); parent.doAThing(); &#125;&#125;);ReactDOM.render(&lt;Parent testing=&#123;true&#125; /&gt;, container); 但是这种方法是不推荐的。 方法二：通过属性传递给子组件 12345678910111213class Parent extends React.Component &#123; constructor(props) &#123; super(props) this.fn = this.fn.bind(this) &#125; fn() &#123; console.log(&apos;parent&apos;) &#125; render() &#123; return &lt;Child fn=&#123;this.fn&#125; /&gt; &#125;&#125;const Child = (&#123; fn &#125;) =&gt; &lt;button onClick=&#123;fn&#125;&gt;Click me!&lt;/button&gt; 但是这种只在Child组件在Parent组件中时才可以用。 方法三：使用上下文（没有直接的父/子关系） 123456789101112131415161718192021222324class Parent extends React.Component &#123; constructor(props) &#123; super(props) this.fn = this.fn.bind(this) &#125; getChildContext() &#123; return &#123; fn: this.fn, &#125; &#125; fn() &#123; console.log(&apos;parent&apos;) &#125; render() &#123; return &lt;Child fn=&#123;this.fn&#125; /&gt; &#125;&#125;Parent.childContextTypes = &#123; fn: React.PropTypes.func,&#125;const Child = (props, &#123; fn &#125;) =&gt; &lt;button onClick=&#123;fn&#125;&gt;Click me!&lt;/button&gt;Child.contextTypes = &#123; fn: React.PropTypes.func,&#125; 给子组件（没有直接父/子关系）添加属性1return React.cloneElement(this.props.children, &#123;/*要添加的属性*/&#125;) React关于子组件的APIReact.chlidren.map1React.Children.map(children, function[(thisArg)]) 对包含在 children 中的每个直接子元素调用一个函数，使用 this 设置 thisArg 。 如果 children 是一个键片段（keyed fragment）或数组，它将被遍历：该函数永远不会传递容器对象（container objects）。 如果 children 为 null 或 undefined ，返回 null 或 undefined，而不是一个数组。 12345678910111213141516171819202122232425262728import React from &apos;react&apos;;const Salmonize = (&#123; children &#125;) =&gt; ( &lt;div&gt; &#123;React.Children.map(children, child =&gt; ( React.cloneElement(child, &#123; style: &#123; backgroundColor: &apos;salmon&apos;, color: &apos;seagreen&apos;, &#125; &#125;) ))&#125; &lt;/div&gt;);const SalmonBlog = (&#123; title, posts &#125;) =&gt; ( &lt;div&gt; &lt;Salmonize&gt; &lt;NavBar title=&#123;title&#125; /&gt; &lt;/Salmonize&gt; &#123;posts.map(post =&gt; ( &lt;Post key=&#123;post.id&#125;&gt; &lt;Salmonize&gt; &lt;PostHeader title=&#123;post.title&#125; /&gt; &lt;/Salmonize&gt; &lt;PostBody text=&#123;post.text&#125; /&gt; &lt;/Post&gt; ))&#125; &lt;/div&gt;); 在上面这个例子中，Salmonize组件并不需要在乎谁是它的子组件，它通过遍历克隆每个子组件，通过React.cloneElement给子组件增加属性。 在React中编写真正可重复使用的组件肯定有点棘手，如果你遇到这样的麻烦，那么这种map和clone方法可以帮助到你。 React.children.forEach1React.Children.forEach(children, function[(thisArg)]) 类似React.children.map，但是没有返回值。 React.Children.count1React.Children.count(children) 返回 children 中的组件总数，等于传递给 map 或 forEach 的回调将被调用的次数。 React.Children.only1React.Children.only(children) 返回 children 中的唯一子集。否则抛出异常。当您想要确保组件只有一个子级时，这可能会派上用场，如果不满足此条件，则会抛出错误。 12345678export default React.createClass(&#123; // ... render: function() &#123; const &#123;name, selectedValue, onChange, children&#125; = this.props; const renderedChildren = children(radio(name, selectedValue, onChange)); return renderedChildren &amp;&amp; React.Children.only(renderedChildren); &#125;&#125;); React.Children.toArray1React.Children.toArray(children) 将 children 不透明数据结构作为一个平面数组返回，并且 key 分配给每个子集。 如果你想在渲染方法中操作children集合，特别是如果你想在传递它之前重新排序或切割 this.props.children ，这将非常有用。 该方法将children组件的支持转换为纯JavaScript数组，这可以使您比React.Children.map提供更多的灵活性。React.Children.toArray最近在我想要渲染一个分隔符的列表中时，它们之间散布着很方便。这导致我创建一个完成这个的组件。 123456789101112131415161718192021import React from &apos;react&apos;;const IntersperseDividers = (&#123; children &#125;) =&gt; ( &lt;div&gt; &#123;React.Children.toArray(children).reduce((elements, child, i, array) =&gt; &#123; elements.push(child); if (i &lt; array.length - 1) &#123; elements.push(&lt;hr key=&#123;`$&#123;i&#125;--divider`&#125; /&gt;); &#125; return elements; &#125;, [])&#125; &lt;/div&gt;);const List = (&#123; data &#125;) =&gt; ( &lt;IntersperseDividers&gt; &#123;data.map((item, i) =&gt; ( &lt;div key=&#123;i&#125;&gt; &#123;item.value&#125; &lt;/div&gt; ))&#125; &lt;/IntersperseDividers&gt;);]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F08%2F02%2Fwebpack%2F%E8%BF%81%E7%A7%BB%E5%88%B0webpack2%2F</url>
    <content type="text"><![CDATA[迁移到webpack2Webpack is on the verge of having its latest major version released, and it’s expected to drop very soon. However, the main thing holding the release back is documentation, and the code is mostly written. I recently took the time to update our work project from Webpack 1 to 2, and thought I’d document the steps taken for anyone else who wants to make the move. You can also check out the migration guide on the Webpack documentation. Install the webpack2 The first thing to do is install the latest version. Because it’s not a stable release, you have to specify the exact beta version you’d like. At the time of writing it’s 2.1.0-beta.25: npm install --save-dev webpack@2.1.0-beta.25 If you’re using any other Webpack plugins, be aware that they might need updating. For example, the Extract Text Plugin has a v2 in beta also: npm install --save-dev extract-text-webpack-plugin@2.0.0-beta.4 module.loaders =&gt; module.rules This is not a breaking change because module.loaders will continue to be supported, but in the future it will be deprecated in favour of module.rules. This is just an easy renaming step. // before modules: { loaders: {...} } // after modules: { rules: {...} } resolve.modulesDirectories =&gt; resolve.modules Another renaming step, the resolve options have been renamed: // before resolve: { modulesDirectories: [...], } // after resolve: { modules: [...], } No webpack.optimize.OccurenceOrderPlugin It’s now included by default, so there is no need to have this in our config. Configuring loaders At work we’re using postcss and postcss-loader to load our CSS through Webpack. The loader used to expect a top level postcss key in the Webpack config. As of Webpack 2 this is no longer allowed; we can instead define an options key when we configure the loader. This replaces the query option from Webpack 1. Any plugin that looked for top level configuration will have to be swapped to this style. // before, in Webpack top level postcss: { plugins: ... } // after module: { rules: [{ test: /\.scss$/, use: [ { loader: &apos;postcss-loader&apos;, options: { plugins: ... } }, &apos;sass-loader&apos; ] }] } ExtractTextPlugin changes The above change to loader configuration also makes it way easier to configure multiple loaders; previously it would only be possible to pass an array of loaders in string form to some plugins, such as ExtractTextPlugin: // Webpack 1 ExtractTextPlugin.extract( &apos;style-loader&apos;, &apos;css-loader!postcss-loader!sass-loader&apos; ); This quickly got very hard to work with if you had to pass options: // Webpack 1 ExtractTextPlugin.extract( &apos;style-loader&apos;, &apos;css-loader?modules-true!postcss-loader!sass-loader&apos; ); But now Webpack 2 can deal with arrays of objects to configure loaders. We can replace the above with: // Webpack 2 var loaders = [ { loader: &apos;css-loader&apos;, options: { modules: true } }, { loader: &apos;postcss-loader&apos; }, { loader: &apos;sass-loader&apos; } ] Whereas in Webpack 1 we used the key query for configuring loaders, we now use options. ExtractTextPlugin can now take this array, rather than only allowing the string form: // Webpack 2 ExtractTextPlugin.extract({ fallbackLoader: &apos;style-loader&apos;, loader: loaders, }) Stop Babel from compiling ES2015 modules Webpack 1 wasn’t able to parse ES2015 modules, so Babel would convert them into CommonJS. Webpack 2 can parse ES2015 modules, and is able to eliminate dead code based on which modules are used, so it’s recommended that you tell Babel not to convert modules into CommonJS. You can do this by changing your .babelrc: // before &quot;presets&quot;: [&quot;es2015&quot;] // after &quot;presets&quot;: [ [&quot;es2015&quot;, { &quot;modules&quot;: false }] ] We’ve seen a good file size saving by doing this, and hopefully this will continue to improve in the future! Fin Webpack 2 offers better performance, improved bundling and a much nicer experience when configuring it. Given that the code is so stable, despite its beta status, I highly recommend giving it a go on your projects when you can.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F08%2F02%2Fwebpack%2Fwebpack%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[webpack的坑 引用jQuery插件时会报”jQuery is not defined”，解决方法： (1). Prefer unminified CommonJS/AMD over dist Most modules link the dist version in the main field of their package.json. While this is useful for most developers, for webpack it is better to alias the src version because this way webpack is able to optimize dependencies better (e.g. when using the DedupePlugin). // webpack.config.js module.exports = { ... resolve: { alias: { jquery: &quot;jquery/src/jquery&quot; } } }; However, in most cases the dist version works just fine as well. (2). Use the ProvidePlugin to inject implicit globals Most legacy modules rely on the presence of specific globals, like jQuery plugins do on $ or jQuery. In this scenario you can configure webpack, to prepend var $ = require(“jquery”) everytime it encounters the global $ identifier. var webpack = require(&quot;webpack&quot;); ... plugins: [ new webpack.ProvidePlugin({ $: &quot;jquery&quot;, jQuery: &quot;jquery&quot; }) ] (3). Use the imports-loader to configure this Some legacy modules rely on this being the window object. This becomes a problem when the module is executed in a CommonJS context where this equals module.exports. In this case you can override this with the imports-loader. Run npm i imports-loader --save-dev and then module: { loaders: [ { test: /[\/\\]node_modules[\/\\]some-module[\/\\]index\.js$/, loader: &quot;imports?this=&gt;window&quot; } ] } The imports-loader can also be used to manually inject variables of all kinds. But most of the time the ProvidePlugin is more useful when it comes to implicit globals. (4). Use the imports-loader to disable AMD There are modules that support different module styles, like AMD, CommonJS and legacy. However, most of the time they first check for define and then use some quirky code to export properties. In these cases, it could help to force the CommonJS path by setting define = false. module: { loaders: [ { test: /[\/\\]node_modules[\/\\]some-module[\/\\]index\.js$/, loader: &quot;imports?define=&gt;false&quot; } ] } (5). Use the script-loader to globally import scripts If you don’t care about global variables and just want legacy scripts to work, you can also use the script-loader. It executes the module in a global context, just as if you had included them via the &lt;script&gt; tag. (6). Use noParse to include large dists When there is no AMD/CommonJS version of the module and you want to include the dist, you can flag this module as noParse. Then webpack will just include the module without parsing it, which can be used to improve the build time. This means that any feature requiring the AST, like the ProvidePlugin, will not work. module: { noParse: [ /[\/\\]node_modules[\/\\]angular[\/\\]angular\.js$/ ] } 常见的loader { test: /\.js/, loader: &quot;babel-loader&quot;, query: { &quot;presets&quot;: [&quot;es2015&quot;, &apos;stage-0&apos;], plugins: [] }, exclude: /(node_modules)/ }, { test: /\.css$/, //注意：此处不能有autoprefix-loader loader: ExtractText.extract(&apos;style-loader&apos;, &apos;css-loader&apos;) }, { test: /\.(png|gif|jpg|jpeg)$/, loader: &quot;url?name=img/[hash:8].[ext]&quot; }, { test: /\.woff(\?v=\d+\.\d+\.\d+)?$/, loader: &apos;url?name=font/[name].[ext]&amp;limit=10000&amp;minetype=application/font-woff&apos; }, { test: /\.woff2(\?v=\d+\.\d+\.\d+)?$/, loader: &apos;url?name=font/[name].[ext]&amp;limit=10&amp;minetype=application/font-woff&apos; }, { test: /\.ttf(\?v=\d+\.\d+\.\d+)?$/, loader: &apos;url?name=font/[name].[ext]&amp;limit=10&amp;minetype=application/octet-stream&apos; }, { test: /\.eot(\?v=\d+\.\d+\.\d+)?$/, loader: &apos;file&apos; }, { test: /\.svg(\?v=\d+\.\d+\.\d+)?$/, loader: &apos;url?limit=10&amp;minetype=image/svg+xml&apos; } 样式的loader (1)style-loader|css-loader is the way to do it just with css (2)style-loader|css-loader|postcss-loader is the way to post-process css (3)style-loader|css-loader|less-loader is the way to do it if you want to use less (4)style-loader|css-loader|postcss-loader|less-loader is the way to post-process the compiled less (css) ES6引用art-template,报错：Module not found: Error: Cannot resolve module &#39;fs&#39;，解决方法： //webpack.config.js module.exports={ node: { fs: &quot;empty&quot; } }; 参考链接 webpack开发时打包第三方库都比较大，可以通过配置alias指向压缩版本： resolve: { alias: { modernizr$: path.resolve(__dirname, &quot;./.modernizrrc&quot;), bootstrap: path.join(__dirname, &quot;./node_modules/bootstrap/dist/js/bootstrap.min.js&quot;), bootstrapCss: path.join(__dirname, &quot;./node_modules/bootstrap/dist/css/bootstrap.min.css&quot;), fontAwesomeCss: path.join(__dirname, &quot;./node_modules/font-awesome/css/font-awesome.min.css&quot;) } } 引用第三方插件如：ulynlist，需要配置别名： alias: { &apos;ulynlist.table&apos;: path.join(__dirname, &apos;./src/sslib/ulynlist/ulynlist.table.js&apos;), &apos;ulynlist.pager&apos;: path.join(__dirname, &apos;./src/sslib/ulynlist/ulynlist.pager.js&apos;), artTemplate: path.join(__dirname, &apos;./node_modules/art-template&apos;) } import样式文件页面会有闪烁现象，这是可以通过extract-text-webpack-plugin抽取样式文件，就不会有这个问题了 使用ES6 + webpack + angular教程参考链接 合并jquery和第三方插件时，外面是读取不到$和jQuery的，所以我们可以通过expose-loader把jQuery对象导出到全局: You can either do this when you require it: require(&quot;expose?$!jquery&quot;); or you can do this in your config: loaders: [ { test: require.resolve(&apos;jquery&apos;), loader: &apos;expose?jQuery!expose?$&apos; } ] 相同的道理，如果插件里有this，则我们可以通过imports-loader把this当成window处理： { test: require.resolve(&apos;respond.js&apos;), loader: &apos;imports?this=&gt;window&apos; } 使用第三方插件，如果其没有判断commonjs这一层，则我们可以配合exports-loader和imports-loader使用，如eos3还有eos服务，eos3需要导出eos对象，eos服务的js需要导入eos这个对象： import &apos;exports?eos!./lib/eos3/eos3&apos;; //这里define设为false，防止组件判断为AMD模块 import &apos;imports?define=&gt;false,this=&gt;window!./lib/auth/dmService&apos;; webpack-dev-server默认是localhost访问，不能通过ip访问，我们可以配置如下： webpack-dev-server –host 0.0.0.0 大项目打包时经常内存溢出： 修改打包命令： 1node --max_old_space_size=4096 ./node_modules/webpack/bin/webpack.js --env=prod --progress --profile --colors]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F08%2F02%2Fwebpack%2Fwebpack%E5%AD%A6%E4%B9%A006%E2%80%94%E2%80%94%E6%80%8E%E4%B9%88%E5%86%99loader%2F</url>
    <content type="text"><![CDATA[webpack学习06——怎么写loader一个loader是一个node模块，导出一个函数。这个函数当资源被转换时会执行，这个loader有一个入参：待转换资源名称。可以在loader中通过this访问上下文。 一个同步的loader可以仅仅返回一个值。在其他情况下，loader可以通过this.callback(err, values)返回多个值。 一个loader被期望返回一个或两个值，第一个值返回字符串或buffer类型的javascript代码，第二个返回sourceMap。 在复杂的情况下，当多个loader链接时，仅仅只要最后一个loader返回资源文件，仅仅第一个loader期望返回一个或两个值（javascript代码或buffer）。 Example: module.exports = function(source){ return source; }; // // Identity loader with SourceMap support module.exports = function(source, map) { this.callback(null, source, map); }; 指南（按优先顺序排序，第一个应该得到最高优先级） 只做一个单一的任务loader可以被链接，他们不应该转换为javascript代码，如果他们不需要的话。例如：从模板中通过查询参数渲染html，我会编写一个从源代码中编译的loader，执行他并返回一个包含包含html的字符串，这是不好的。而是我应该编写装载程序在这个用例中的每一个任务，并将它们全部应用（流水线）： jade-loader: Convert template to a module that exports a function. apply-loader: Takes a function exporting module and returns raw result by applying query parameters. html-loader: Takes HTML and exports a string exporting module. generate modules that are modular加载程序生成模块应尊重相同的设计原则，如正常模块。例子：这是一个糟糕的设计：（不模块化，全局状态，…） require(&quot;any-template-language-loader!./xyz.atl&quot;); var html = anyTemplateLanguage.render(&quot;xyz&quot;); 标志本身缓存如果可能的话大多数装载机是可缓存的，所以他们应该标志本身作为缓存。只要在loader中调用cacheable。 //Cacheable identity loader module.exports = function(source){ this.cacheable(); return source(); }; not keep state between runs and modules一个加载程序应该独立于编译的其他模块（由装载程序发布的这些模块的期望）。一个程序应该独立于以前的编译的模块。 依赖如果loader需要依赖第三方资源（如从系统中读取文件），他们必须要写清楚，此信息用于无效的缓存装载机和编译在观看模式。 // Loader adding a header var path = require(&quot;path&quot;); module.exports = function(source) { this.cacheable(); var callback = this.async(); var headerPath = path.resolve(&quot;header.js&quot;); this.addDependency(headerPath); fs.readFile(headerPath, &quot;utf-8&quot;, function(err, header) { if(err) return callback(err); callback(null, header + &quot;\n&quot; + source); }); }; 解决依赖关系一些语言有自己的解决依赖图式，例如css的@import和url(...)。这些必须被模块系统解决。 有两个方法可以做到： 把他们转换成require； 使用this.resolve解析路径； 例子1：css-loader把依赖转换成require其他样式文件。例子2：less-loader不转换为require，因为因为所有的less文件需要编译一次跟踪变量和混合，因此，less-loader扩展less编译器一个自定义的路径解决方法，该自定义逻辑使用this.resolve解决模块的系统配置文件（走样，自定义模块目录，等）。If the language only accept relative urls (like css: url(file) always means ./file), there is the ~-convention to specify references to modules: url(file) -&gt; require(&quot;./file&quot;) url(~module) -&gt; require(&quot;module&quot;) 抽离公共代码don’t generate much code that is common in every module processed by that loader. Create a (runtime) file in the loader and generate a require to that common code. 不应嵌入绝对路径don’t put absolute paths in to the module code. They break hashing when the root for the project is moved. There is a method stringifyRequest in loader-utils which converts an absolute path to an relative one. Example: var loaderUtils = require(&quot;loader-utils&quot;); return &quot;var runtime = require(&quot; + loaderUtils.stringifyRequest(this, &quot;!&quot; + require.resolve(&quot;module/runtime&quot;)) + &quot;);&quot;; use a library as peerDependencies when they wrap itusing a peerDependency allows the application developer to specify the exact version in package.json if desired. The dependency should be relatively open to allow updating the library without needing to publish a new loader version. &quot;peerDependencies&quot;: { &quot;library&quot;: &quot;^1.3.5&quot; } programmable objects as query-optionthere are situations where your loader requires programmable objects with functions which cannot stringified as query-string. The less-loader, for example, provides the possibility to specify LESS-plugins. In these cases, a loader is allowed to extend webpack’s options-object to retrieve that specific option. In order to avoid name collisions, however, it is important that the option is namespaced under the loader’s camelCased npm-name.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F08%2F02%2Fwebpack%2Fwebpack%E5%AD%A6%E4%B9%A005%E2%80%94%E2%80%94%E9%95%BF%E6%9C%9F%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[webpack学习05——长期缓存有两种级别的添加hash方法： Compute a hash of all chunks and add it. Compute a hash per chunk and add it. 方法一：只有一个hash{ output: { path: path.join(__dirname, &quot;assets&quot;, &quot;[hash]&quot;), publicPath: &quot;assets/[hash]/&quot;, filename: &quot;output.[hash].bundle.js&quot;, chunkFilename: &quot;[id].[hash].bundle.js&quot; } } 方法二：每个块都有一个hashoutput: { chunkFilename: &quot;[chunkhash].bundle.js&quot; } Note that you need to reference the entry chunk with its hash in your HTML. You may want to extract the hash or the filename from the stats. In combination with Hot Code Replacement you must use option 1, but not on the publicPath config option. 从文件名获取状态You probably want to access the final filename of the asset to embed it into your HTML. This information is available in the webpack stats. If you are using the CLI you can run it with –json to get the stats as JSON to stdout. You can add a plugin such as assets-webpack-plugin to your configuration which allows you to access the stats object. Here is an example how to write it into a file: plugins: [ function() { this.plugin(&quot;done&quot;, function(stats) { require(&quot;fs&quot;).writeFileSync( path.join(__dirname, &quot;..&quot;, &quot;stats.json&quot;), JSON.stringify(stats.toJson())); }); } ] The stats JSON contains a useful property assetsByChunkName which is a object containing chunk name as key and filename(s) as value. Note: It’s an array if you are emitting multiple assets per chunk. I. e. a JavaScript file and a SourceMap. The first one is your JavaScript source.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F08%2F02%2Fwebpack%2Fwebpack%E5%AD%A6%E4%B9%A004%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[webpack学习04——压缩优化压缩为了压缩你的脚本（和你的样式，如果你用css-loader的话），webpack支持下面两个途径： --optimize-minimize 或者 new webpack.optimize.UglifyJsPlugin() webpack给你的模块和块赋予了id来区别他们，webpack可以为经常用到的id通过下面途径得到最小id长度： --optimize-occurrence-order resp. new webpack.optimize.OccurrenceOrderPlugin() 去重如果你使用第三方库有相同依赖时，会重复引用相同的文件，webpack可以找到并去重，默认是不开启的，可以使用一下方法开启： --optimize-dedupe resp. new webpack.optimize.DedupePlugin() 块优化限制快的最大大小 –optimize-max-chunks 15 new webpack.optimize.LimitChunkCountPlugin({maxChunks: 15})限制块的最小大小 –optimize-min-chunk-size 10000 new webpack.optimize.MinChunkSizePlugin({minChunkSize: 10000}) Webpack会照顾它通过合并块（它会合并块，有重复的模块）。不会有东西合并到入口块，所以不会影响初始页面加载时间。 单页应用A Single-Page-App is the type of web app webpack is designed and optimized for. You may have split the app into multiple chunks, which are loaded at your router. The entry chunk only contains the router and some libraries, but no content. This works great while your user is navigating through your app, but for initial page load you need 2 round trips: One for the router and one for the current content page. If you use the HTML5 History API to reflect the current content page in the URL, your server can know which content page will be requested by the client code. To save round trips to the server you can include the content chunk in the response: This is possible by just adding it as script tag. The browser will load both chunks parallel. &lt;script src=&quot;entry-chunk.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script src=&quot;3.chunk.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; You can extract the chunk filename from the stats. (stats-webpack-plugin could be used for exports the build stats) 多页应用var CommonsChunkPlugin = require(&quot;webpack/lib/optimize/CommonsChunkPlugin&quot;); module.exports = { entry: { p1: &quot;./page1&quot;, p2: &quot;./page2&quot;, p3: &quot;./page3&quot;, ap1: &quot;./admin/page1&quot;, ap2: &quot;./admin/page2&quot; }, output: { filename: &quot;[name].js&quot; }, plugins: [ new CommonsChunkPlugin(&quot;admin-commons.js&quot;, [&quot;ap1&quot;, &quot;ap2&quot;]), new CommonsChunkPlugin(&quot;commons.js&quot;, [&quot;p1&quot;, &quot;p2&quot;, &quot;admin-commons.js&quot;]) ] }; // &lt;script&gt;s required: // page1.html: commons.js, p1.js // page2.html: commons.js, p2.js // page3.html: p3.js // admin-page1.html: commons.js, admin-commons.js, ap1.js // admin-page2.html: commons.js, admin-commons.js, ap2.js Advanced hint: You can run code inside the commons chunk: var CommonsChunkPlugin = require(&quot;webpack/lib/optimize/CommonsChunkPlugin&quot;); module.exports = { entry: { p1: &quot;./page1&quot;, p2: &quot;./page2&quot;, commons: &quot;./entry-for-the-commons-chunk&quot; }, plugins: [ new CommonsChunkPlugin(&quot;commons&quot;, &quot;commons.js&quot;) ] }; See also multiple-entry-points example and advanced multiple-commons-chunks example.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F08%2F02%2Fwebpack%2Fwebpack%E5%AD%A6%E4%B9%A003%E2%80%94%E2%80%94%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[webpack学习03——样式嵌入样式{ test: /\.css$/, loader: &quot;style-loader!css-loader&quot; } 这种情况下会在页面添加style标签式的样式 抽成样式文件可以使用extract-text-webpack-plugin抽成样式文件。 var ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;); ... loaders: [ // Extract css files { test: /\.css$/, loader: ExtractTextPlugin.extract(&quot;style-loader&quot;, &quot;css-loader&quot;) }, // Optionally extract less files // or any other compile-to-css language { test: /\.less$/, loader: ExtractTextPlugin.extract(&quot;style-loader&quot;, &quot;css-loader!less-loader&quot;) } // You could also use other loaders the same way. I. e. the autoprefixer-loader ], plugins: [ new ExtractTextPlugin(&quot;[name].css&quot;) ] 所有样式文件合并成一个样式文件plugins: [ new ExtractTextPlugin(&quot;style.css&quot;, { allChunks: true }) ] 公共样式和CommonsChunkPlugin一起使用，commons块就会生成commons.css样文件。 plugins: [ new webpack.optimize.CommonsChunkPlugin(&quot;commons&quot;, &quot;commons.js&quot;), new ExtractTextPlugin(&quot;[name].css&quot;) ]]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F08%2F02%2Fwebpack%2Fwebpack%E5%AD%A6%E4%B9%A002%E2%80%94%E2%80%94%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2%2F</url>
    <content type="text"><![CDATA[webpack学习02——代码分割定义一个代码分割点commonjs: require.ensurerequire.ensure(dependencies, callback) example: //require.ensure仅仅加载而不执行模块 require.ensure([&quot;module-a&quot;, &quot;module-b&quot;], function(require) { var a = require(&quot;module-a&quot;); // ... }); AMD: requirerequire(dependencies, callback) example: //AMD的require加载并会执行模块 require([&quot;module-a&quot;, &quot;module-b&quot;], function(a, b) { // ... }); ES6模块webpack1是不支持原生es6模块的，可以通过babal转换 块的内容所有分隔的文件会成为一个块，这个块是由其依赖递归加进去的。 块压缩如果两个块包含同一个模块，他们会被合并成一个。这可能造成块有相同的父级。如果一个模块在一个块的所有父级中是可获取的，这个模块将会在这个块中删除。如果一个块包含另一个块的所有模块，则存储这个块，它实现多个块。 块加载根据配置target目标，将将块加载的运行时逻辑添加到包中。例如：web目标块通过jsonp加载。只有一个块被加载一次，并行请求被合并成一个。运行时检查加载的块是否完成多个块。 块的类型入口块一个入口块包含了请求时加载的模块。如果这个块包含模块0则加载并执行它，如果没有，它等待有请求模块0的块。 正常块一个正常的块不会在运行时加载，它仅仅包含一些模块，这个结构依赖于块加载算法，例如：如果目标是jsonp，则这些模块会包含一个jsonp回调函数，这个块当然还包含它负责的一些块id列表。 初始化块（非入口）一个初始化块是一个正常的块，不同的仅仅是压缩工具视它更重要，因为它计算向初始加载时间（像入口块），这个块类型可以结合CommonsChunkPlugin发生。 分隔app和vendor代码var webpack = require(&quot;webpack&quot;); module.exports = { entry: { app: &quot;./app.js&quot;, vendor: [&quot;jquery&quot;, &quot;underscore&quot;, ...], }, output: { filename: &quot;bundle.js&quot; }, plugins: [ new webpack.optimize.CommonsChunkPlugin(/* chunkName= */&quot;vendor&quot;, /* filename= */&quot;vendor.bundle.js&quot;) ] }; vendor块将会从移除所有在app块中的模块，使得bundle块仅仅包含你的代码而不包含其依赖。 &lt;script src=&quot;vendor.bundle.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; 多入口块加载多入口通过CommonsChukPlugin运行时被移动到公共块，入口文件变成初始化块。只有当初始块可以被加载时，其他入口块才可以被加载。 var webpack = require(&quot;webpack&quot;); module.exports = { entry: { a: &quot;./a&quot;, b: &quot;./b&quot; }, output: { filename: &quot;[name].js&quot; }, plugins: [ new webpack.optimize.CommonsChunkPlugin(&quot;init.js&quot;) ] } &lt;script src=&quot;init.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;b.js&quot;&gt;&lt;/script&gt; 公共块CommonsChunkPlugin可以移动发生在多个入口的模块到一个新的块（公共块），运行时也移动到公共块，这意味着旧的入口块已经变成初始化块。 压缩优化插件 LimitChunkCountPlugin MinChunkSizePlugin AggressiveMergingPlugin 命名块The require.ensure function accepts an additional 3rd parameter. This must be a string. If two split point pass the same string they use the same chunk. require.includerequire.include(request) require.include is a webpack specific function that adds a module to the current chunk, but doesn’t evaluate it (The statement is removed from the bundle). Example: require.ensure([&quot;./file&quot;], function(require) { require(&quot;./file2&quot;); }); // is equal to require.ensure([], function(require) { require.include(&quot;./file&quot;); require(&quot;./file2&quot;); }); require.include can be useful if a module is in multiple child chunks. A require.include in the parent would include the module and the instances of the modules in the child chunks would disappear.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F08%2F02%2Fwebpack%2Fwebpack%E5%AD%A6%E4%B9%A001%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[webpack学习01——简介 webpack是一个模块打包工具， webpack特性： 插件：webpack有大量的插件，大多数的功能是使用这个接口的内部插件，这使得webpack很很大的灵活性; 性能：webpack使用异步I/O和多级缓存机制，使得webpack有更快的速度，而且编辑速度超快； 加载器(loaders)：webpack通过定义loaders预处理文件，这允许你打包任何资源而不仅仅是javascript，你也可以自己写适合自己的加载器; 模块化：webpack支持AMD和CommonJs模块化规范，它能够聪明地分析你的代码，甚至有一个评估引擎来评估简单的表达式，这个允许你支持大多数现存模块化规范 代码分割：webpack允许你把代码分割成不同的块thunk，块是按需加载的，这个可以减少初始加载所发费的时间。 代码压缩：webpack可以压缩你的代码，它当然也支持通过哈希缓存； 开发工具：WebPACK支持调试简单sourceurls和sourcemaps。还可以通过development middleware和development server实现自动刷新功能; 多个目标：webpack的首要目标是web，但是它也支持在WebWorkers、Node.js中使用； 加载器： 转换文件； 加载器可以通过管道被链接，最后一个加载器则返回javascript，其他的加载器则可以返回任意的格式代码； 加载器可以是同步或异步的； 加载器在Node.js环境中运行，所以你可以做任何你想要的事情； 加载器支持查询参数； 加载器可以在配置中绑定到扩展名或正则表达式的监听； 加载器可以被发布到npm上或从npm中安装下来； Normal modules can export a loader in addition to the normal main via package.json loader. 加载器可以访问配置； 插件可以向加载器提供更多的特性和功能； 加载器可以调用额外的任意文件； 。。。 加载器解决方案 加载器类似模块，一个加载器导出一个兼容于Node的javascript函数，一般情况下，你通过npm管理你的加载器，当然你也可以作为文件在你的项目中使用 引用加载器：加载器一般以xxx-loader命名，xxx是其名字，例如：json-loader； 你可以通过全名xxx-loader或者短名xxx来使用加载器； 加载器的命名惯例和优先顺序是由resolveLoader.moduleTemplates配置决定的； 加载器的命名惯例一些情况下是很有用的，特别是在require()里面引用加载器的时候； 加载器的使用情况： 在require()语句内； //使用文件loader.js来转换file.txt文件 require(&apos;./loader!./dir/file.txt&apos;); //使用jade-loader，如果配置文件中已经有绑定到此文件的加载器，他们仍然会运行的 require(&apos;jade!./template.jade&apos;); //由less-loader-&gt;css-loader-&gt;style-loader转换顺序，由于有前缀`!`，所以如果在配置文件中已经 //有绑定到此文件的加载器，他们将不会运行 require(&apos;!style!css!less!bootstrap/less/bootstrap.less&apos;); 在配置文件中配置；（推荐这种方式） { module: { loaders: [ {test: /\.jade$/, loader: &apos;jade&apos;}, {test: /\.css$/, loader: &apos;style!css&apos;}, {test: /\.css$/, loaders: [&apos;style&apos;, &apos;css&apos;]} ] } } 在CLI命令行中配置； webpack --module-bind jade --module-bind &apos;css=style!css&apos; 加载器的查询参数 可以在加载器后面加上?添加多个查询参数，例如：url-loader?mimetype=image/png.大多数的加载器支持正常的格式?key=value&amp;key2=value2和JSON对象格式?{key: &quot;value&quot;, key2: &quot;value2&quot;} 在require()语句中： require(&apos;url-loader?mimetype=image/png!./file.png&apos;); 在配置中： {test: /\.png$/, loader: &apos;url-loader?mimetype=image/png&apos;} 或者 { test: /\.png$/, loader: &apos;url-loader&apos;, query: { mimetype: &apos;image/png&apos; } } 在CLI中： webpack --module-bind &quot;png=url-loader?mimetype=image/png&quot;]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML不同空格的特性和表现研究]]></title>
    <url>%2F2016%2F08%2F02%2Fcss%2FHTML%E4%B8%8D%E5%90%8C%E7%A9%BA%E6%A0%BC%E7%9A%84%E7%89%B9%E6%80%A7%E5%92%8C%E8%A1%A8%E7%8E%B0%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[Unicode编码空格 &amp;nbsp;: 不换行空格,用于不会被浏览器判断为可以在中间打断，比如：There is&amp;nbsp;Space，如果会换行，只会在There和is之间换行，而不会在is和Space之间换行。 跟随字体大小产生相应空白的空格：&amp;ensp;(1/2em)，&amp;emsp;(1em)，&amp;thinsp;(1/6em)，这类就很适合坐表单label的排版了，坑爹，终于找到好的解决方法了]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用css视口单位]]></title>
    <url>%2F2016%2F08%2F02%2Fcss%2F%E4%BD%BF%E7%94%A8css%E8%A7%86%E5%8F%A3%E5%8D%95%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[css提供了许多单位用来规定元素，最熟悉的莫属px、%、pt、em以及最近比较火的rem，还有其他两个vw、vh，它们是相对单位，但是不同于em和rem那样相对于当前元素或相对于根元素，他们是相对于视口，一个视口单位等于1%的视口的宽度（vw）或高度（vh）。 这是很有用的。vw单位可以用于一些有大小的规则（如：font-size、或者一个div的高度），下面是一些使用案例： 使标题固定如果你想让一个标题占满横向屏幕且让他固定在一行，你可以使用vw单位，这实际上是用原生的方法实现了jquery插件FitText的功能，但是相对于使用vw，FitText需要手动管理大小，使用检查工具，是一个快速的方法以确定适当的值。 //html &lt;h1&gt;Always a great fit!&lt;/h1&gt; //css h1{ font-size: 12vw; text-align: center; } Infinite LinesWhilst building the falcon633 WordPress theme (used on this site), I needed to create an angled background that would appear to continue indefinitely. This is achievable by 1) making sure that the angle in the centre stays the same regardless of window size and 2) setting the height to be relative to the viewport width. I used an SVG background for the overall cut-out then set the height based on the width using vw units. 简单的视频包装Let’s say you want to set the proportions of an element, an iframe, to stay at a fixed aspect ratio. You previously might have chosen to create a relative div filling the required space, then set carefully selected padding values with iframe inside absolutely positioned to cling to div on all sides (e.g. the approach demonstrated here). A better solution could be to use the vw and vh units. This way you can set your height and width directly on the element in question, whilst also keeping the ‘layers-for-layout’ number down. 全屏的hero Image你要做的只是在body和html上运用height: 100%，然后在元素上简单地使用width: 100vw; heihgt: 100vh就行了。 div居中一个常见的需求是要让一个div在页面中居中，这时候只要设置margin: 20vh 20vw; width: 60vw, height: 60vh; padding: 10vh 10vw即可。 浏览器支持情况IE9及以上]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular2遇到的问题.md]]></title>
    <url>%2F2016%2F08%2F02%2Fangular2%2F%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在组件时moduleId: module.id时，报Cannot find name &#39;module&#39;? 解决方法： You need to install node ambientDependencies. Typings.json &quot;ambientDependencies&quot;: { &quot;node&quot;: &quot;github:DefinitelyTyped/DefinitelyTyped/node/node.d.ts#138ad74b9e8e6c08af7633964962835add4c91e2&quot; } Another way can use typings manager to install node definition file globally: typings install dt~node --global --save Then your typings.json file will look like this: &quot;globalDependencies&quot;: { &quot;node&quot;: &quot;registry:dt/node#6.0.0+20160608110640&quot; } If you use Typescript 2^ just use the following command: npm install @types/node --global --save Or install it within the project: npm install @types/node --save and then add a reference to it from your bootstrap: ///&lt;reference path=&quot;../../node_modules/@types/node/index.d.ts&quot; /&gt; 而后出现Url.match is not a function? 解决方法： 报错：Property &#39;find&#39; does not exist on type &#39;Hero[]&#39;.? 解决方法：在typings.json中配置如下代码 { &quot;globalDependencies&quot;: { &quot;core-js&quot;: &quot;registry:dt/core-js#0.0.0+20160725163759&quot;, &quot;jasmine&quot;: &quot;registry:dt/jasmine#2.2.0+20160621224255&quot;, &quot;node&quot;: &quot;registry:dt/node#6.0.0+20160909174046&quot; } }]]></content>
      <tags>
        <tag>angular</tag>
      </tags>
  </entry>
</search>
